//!================================================================================================================================================
//? Работа JS
// https://habr.com/ru/post/579628/
// https://webdevblog.ru/kak-rabotaet-javascript/
//? Сначала по коду пробегается компилятор и записывает все переменные в лексическое окружение, все переменные будут undefined, к переменным объявленным через var можно будет обратиться до их определения в ходе выполнения кода, т.к. сначала срабатывает компилятор, а затем только js начинается выполняться. К переменным, объявленным через let и const до определения мы не имеем доступа, потому что они находятся в "временной мертвой зоне", было введено понятие, чтобы они не всплывали, как var переменные. Это понятие означает, что они уже хранятся в памяти, что под них выделено место, но доступ к ним будет только после их определения(иначе ошибка временной зоны).
//? Функции записываются в память полностью(function declaration), function expression работают, как обычные переменные.
//? JS однопоточный язык, а это значит, что код выполняется строчка за строчкой, последовательно.
//? При запуске кода, создается один большой глобальный контекст выполнения "execution context", внутри которого и выполняются все остальные строчки. Каждый вызов функции попадает в call stack, если функция вызывает другую - контексты выполнения, которые создают функции, наслаиваются друг на друга. Затем, когда больше не происходит вызовов функций внутри других функций, call stack очищается, и только после этого код продолжает идти дальше и выполнятся.










//!================================================================================================================================================
//? Переменные
// https://learn.javascript.ru/variables
//? можно использовать $ _ цифры, нельзя использовать тире и начинать переменную с цифры, а также зарезервированные имена(https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0)
//? отличаются let и var областью видимости, const нельзя переопределить напрямую, но можно переопределить свойство константного обьекта. Также в строгом режиме нельзя просто так определить переменную без ее объявления.










//!================================================================================================================================================
//? Var
// https://learn.javascript.ru/var
//? Для «var» не существует блочной области видимости, она будет изолирована только в функции или скриптом, все, в остальных случаях она вылазит из блока кода, в отличии от let и const, которые создаются в блоках кода
/*
if (true) {
    var test = true;   //используем var вместо let
}
alert(test);
*/

//? также объявление в глобальной области видимости через var записывает эту переменную в window обьект, а чтобы записать обычную переменную в глобальный обьект, необходимо напрямую обратиться к window и записать в него нужное значение
/*
var a = 1;
console.log(window.a);
*/

//? Также переменные через var можно объявлять и перезаписывать сколько угодно раз, а вот let и const вызовут ошибку, т.к. запрещено объявление одной и той же переменной
/*
var a = 1;
var a = 2;
console.log(a);
*/












//!================================================================================================================================================
//? Strict mode
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode


//? 1) Невозможно создать переменную без ее объявления.
/*
'use strict';
myAge = 18;   //приведет к ошибке в строгом режиме(variable is not defined), без него можно объявить переменную таким образом и никто не будет ругаться
*/


//? 2) Выдает TypeError на присваивания, которые нельзя делать, например запрет на присваивание глобальным переменным языка, присваивание значения свойству защищенного от записи обьекта
/*
'use strict';
var undefined = 5;   //выдаст TypeError
var Infinity = 5;   //выдаст TypeError

var obj1 = {};
Object.defineProperty(obj1, "x", { value: 42, writable: false });
obj1.x = 9;   //выдаст TypeError
*/


//? 3) В строгом режиме попытки удалить неудаляемые свойства будут вызывать исключения (в то время как прежде такая попытка просто не имела бы эффекта)
/*
'use strict'
delete Object.prototype;   //выдаст TypeError
*/


//? 4) Нельзя в функции определять аргументы имеющие одно и то же имя
/*
'use strict';
function name(a, a, b) {   //Duplicate parameter name not allowed in this context
    console.log(a, a, b);
}
name(1, 2, 3);
*/


//? 5) запрещает синтаксис восьмеричной системы счисления. Восьмеричный синтаксис не является частью ECMAScript, но поддерживается во всех браузерах с помощью дописывания нуля спереди к восьмеричному числу: 0644 === 420 и "\045" === "%". В ECMAScript 2015 восьмеричное число поддерживается также с помощью дописывания перед числом "0o"(ниже пример)
/*
'use strict';
console.log("\045");   //Octal escape sequences are not allowed in strict mode.

это можно использовать в строгом режиме
var a = 0o10;
*/


//? 6) запрещает устанавливать свойства примитивным значениям
/*
'use strict';
false.true = '';   //TypeError
14.sailing = 'home';  //TypeError
*/


//? 7) запрещает работать с with


//? 8) eval в строгом режиме не добавляет в окружающий контекст переменные, то есть они видны только внутри eval
// https://learn.javascript.ru/eval
/*
'use strict';
eval("let x = 5");
console.log(x);   //undefined, нет такой переменной
*/


//? 9) нельзя удалять примитивные переменные через delete
/*
'use strict';
let a = 'Dima';
delete a;  //Delete of an unqualified identifier in strict mode.
*/


//? 10) в строгом режиме происходит копирование всех аргументов переданных в функцию, то есть, при изменении аргумента массив arguments не изменяется, и также при изменении arguments по индексу не будет изменяться и переданный аргумент. В обычном же режиме происходило обновление и того и другого.
/*
'use strict';
function name(a) {
    a = 12;
    console.log(arguments);
    console.log(a);
}
name(1);
*/


//? 11) запрещает доступ в функции к arguments.calee
/*
'use strict';
let f = function() { return arguments.callee };
f();   //выдаст TypeError
*/


//? 12) скрывает в блоке изолированном функцию объявленную в нем
/*
{
    function f() {
        console.log(1);
    }
}
f();   //ошибка, нет такой функции
*/










//!================================================================================================================================================
//? Типы данных
// https://learn.javascript.ru/types


//? есть 8 типов данных
//? Number, BigInt, String, Boolean, null, undefined, Object, Symbol

//? 1) Number
//? к нему относятся Infinity, -Infinity и NaN и любые числа


//? 2) BigInt
//? js не может содержать числа больше (2**53-1) или же (9007199254740991) или -(2**53-1)
/*
let bigInt = 1234567890123456789012345678901234567890n;
let bigInt = BigInt('12334325234534252345345435');
*/


//? 3) String


//? 4) Boolean


//? 5) null
//? означает, что мы ссылаемся на что то несуществующее вообще, то есть этого просто нет
/*
console.log(a);   //ошибка, т.к а просто не существует
*/


//? 6) undefined
//? это значит, что у переменной нет какого то значения, ей не присвоено никакого значения, мы объявили переменную, но значения ее нет.
//? обычно null используется для присвоения переменной пустого или неизвестного значения, а undefined – для проверок, была ли переменная назначена.
/*
let age;
alert(age);   //выведет "undefined"
*/


//? 7) Object


//? 8) Symbol





//?================================================================================================================================================
//? Проверка типа переменной


//? typeof
//? Возвращает тип переданного аргумента в виде строки
//? есть пара нюансов при работе с этим оператором, на null он вернет тип обьект(это признанная ошибка языка), а для функции он вернет тип функция, хотя по факту функция в языке является обьектом, но это может быть достаточно удобно при работе



//? Array.isArray()
//? проверяет это массив или нет, потому что typeof вернет обьект











//!================================================================================================================================================
//? Преобразование типов
// https://learn.javascript.ru/type-conversions


//? К числу
/*
+undefined   //NaN
+null   //0
+true   //1
+false   //0
+string   //сначала по краям пробелы обрезаются, 0 - пустая строка(пробелы не считаются за символы), NaN - не число, number - если есть число в строке после обрезания пробелов
*/


//? К логическому
/*
0, null, undefined, '', NaN [].length   //false
{}, []   //true
*/


//? К строке просто конкатенацией со строкой





//?================================================================================================================================================
//? Преобразование обьектов
// https://learn.javascript.ru/object-toprimitive


//? по дефолту обьект преобразуется в [object Object] если со строкой складывают, в NaN если его приводят по дефолту к числу



//? Алгоритм преобразований к примитивам следующий:
//? Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует.
//? Иначе, если хинт равен "string" происходит попытка вызвать obj.toString(), затем obj.valueOf(), смотря что есть.
//? Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf(), затем obj.toString(), смотря что есть.


//? все методы по преобразования должны возвращать примитивное значение и только!


//? Symbol.toPrimitive
//? метод, если есть, определяет все преобразования обьекта, можно самому решать, во что он будет преобразовываться
//? обьект преобразуется в число, например если он приводится явно к числу, в этом методе будет hint number
//? к строке, если например будет alert, т.к. там только строковый тип данных используется, hint будет string
//? default, если будет конкатенация
/*
let a = {
    name: 'dima',
    age: 22,
    [Symbol.toPrimitive](hint) {
        console.log(hint);
        if (hint === 'string') {
            return this.name;
        }
        if (hint === 'default') {
            return this.name;
        }
        if (hint === 'number') {
            return this.age;
        }
    }
}
alert(a);   //dima
console.log(a + '');   //dima
console.log(+a);   //22
*/


//? toString/valueOf
//? если нет метода toPrimitive, то код сначала попробует вызывать toString для хинта string, valueOf для иных хинтов
/*
let a = {
    name: 'dima',
    age: 22,
    toString() {
        return this.name;
    },
    valueOf() {
        return this.age;
    }
}
alert(a);   //dima
console.log(a + '');   //'22'
console.log(+a);   //22
*/


//? в отсутствие Symbol.toPrimitive и valueOf, toString обработает все случаи преобразований к примитивам


//? Symbol.toStringTag
//? меняет поведение методов преобразования обьектов к строке, можно указать, какое строковое значение будет возвращено
/*
let obj = {
    [Symbol.toStringTag]: "User",
}
alert(obj);   '[object User]'
*/





//? преобразование в json toJSON
//? можно реализовать метод в обьекте, который будет вызывать при преобразовании обьекта в json, это тоже самое что и valueOf и toString
/*
let room = {
    number: 23,
    toJSON() {
        return this.number;
    }
};
console.log(JSON.stringify(room));
*/





//?================================================================================================================================================
//? Преобразование массивов


//? к числу
//? пустой массив будет 0, не пустой NaN
/*
console.log(+[]);          //0
*/


//? к строке
//? пустой массив будет '', если он не пуст, то значения его преобразуются в строку, а затем сконатенируются в одну строку
/*
console.log([1, 2, 3]+'');          //'1,2,3'
*/











//!================================================================================================================================================
//? Операторы
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators#%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence   приоритеты
// https://learn.javascript.ru/operators


//? Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».
//? Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный.
//? Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме.
// https://learn.javascript.ru/operators





//? Декремент и инкремент
//? постфиксная форма сначала вернет старое значение, а затем увеличит переменную, префиксная форма сначала увеличит значение а затем вернет результат.
/*
let a = 0;
let b = a++;   //постфиксная
console.log(a);   //1
console.log(b);   //0

let a = 0;
let b = ++a;   //префиксная
console.log(a);   //1
console.log(b);   //1
*/





//? Сравнение
// https://learn.javascript.ru/comparison


//? Строки
//? строки сравниваются в "алфавитном"(используется кодировка Unicode, а не настоящий алфавит) порядке посимвольно, а также маленькие буквы считаются больше, чем большие
/*
'a' < 'b'   //true
'a' > 'A'   //true
*/


//? Нестрогое сравнение
//? разные типы приводятся к числу, кроме обьектов, обьекты будут вызывать свои методы преобразования в примитивы
/*
интересный факт, значения ниже равны, потому что привели к числу, и оба false, значит они равны, но если отдельно привести каждое к логическому, то 0 будет false, а '0' будет true и сравнение будет другое.
let a = 0;
let b = '0';
a == b   //true
*/


//? Строгое сравнение
//? оператор строгого сравнения не приводит типы к единому, если один из них не подходит будет сразу возврат false
/*
1 === 1   //true
1 === '1'   //false
*/


//? Object.is
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is
//? существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях: работает с NaN, значения 0 и -0 разные
/*
Object.is(NaN, NaN) === true, здесь он хорош
Object.is(0, -0) === false, это редко используется, но технически эти значения разные
*/


//? Сравнение null undefined
/*
null === undefined   //false, эти значения различны, так как различны их типы
null == undefined   //true, эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка
*/


//? Сравнение обьектов
//? Обьекты никогда не равны друг другу, если это только не один и тот же обьект, сравниваются ссылки обьектов
//? но при сравнении примитивов с обьектами при нестрогом сравнении, обьекты сначала преобразуются к примитивам своими методами встроенными или же нашими кастомными
/*
let a = {};
a == '[object Object]'
*/





//?================================================================================================================================================
//? Условное ветвление, тернарный оператор, условия
// https://learn.javascript.ru/ifelse
/*
false ? 'это правда' : false ? 'это тоже правда' : 'а это ложь'   //а это ложь
*/





//? Логические операторы
// https://learn.javascript.ru/logical-operators
//? && || ! приводят значения к логическому типу


//? || запинается на правде, или возвращает последний ложный вариант.
//? Он работает так: Вычисляет операнды слева направо. Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда. Если все операнды являются ложными (false), возвращает последний из них.


//? && запинается на лжи или возвращает последний правдивый вариант, если они все правдивы.
//? Вычисляет операнды слева направо. Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда. Если все операнды были истинными, возвращается последний.
//? Приоритет И больше чем у ИЛИ


//? ! Приводит к логическому типу и возвращает противоположное
/*
let a = null;
console.log(!a);   //true
*/


//? !! Возвращает логический тип аргумента(приводит к логическому)


//? ?? Оператор объединения с null
// https://learn.javascript.ru/nullish-coalescing-operator
//? ?? вернет первый аргумент, если он не null/undefined, иначе второй.
//? можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined.
//? различие между || и ?? в том, что || возвращает первой ИСТИННОЕ значение, а ?? первое определенное(не null/undefined), то есть если у нас есть значение 0, то ?? вернет его, потому что оно определено, а || его не вернет, потому что оно ложно
/*
let user;
let userCash = a ?? 'anonim';   //присвоится аноним

let a;
let b;
let c = 1;
let d = a ?? b ?? c;   //d == 1
*/





//? Опциональная цепочка ?.
// https://learn.javascript.ru/optional-chaining
//? мы можем сначала проверить, если ли свойство у обьекта, и затем продолжить работу, также применимо и к методам
//? если цепочка прервется, то вернется undefined
/*
let a = {};
a.f?.();
a?.['name'];
*/

//? нельзя использовать для присваивания(если есть, то присвоить то то то то, так делать нельзя)

//? можно удалять свойства, если они есть
/*
let a = {};
delete a?.name;
*/










//!================================================================================================================================================
// https://learn.javascript.ru/while-for
//? Циклы

//? break используется, чтобы выйти из цикла, если цикл внутри цикла, то break выйдет только из текущего цикла, в котором он был вызван

//? continue используется, чтобы перейти к следующей итерации

//? mark(label) можно повесить на цикл, чтобы обратиться к конкретному циклу и выйти из него
/*
mark: for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5; j++) {
        if (j === 2) {
            break mark;
        }
        console.log(j);
    }
}
*/


//? for
//? в цикле for можно убрать части цикла(начало, условие, шаг)
/*
let i = 0;
for ( ; i < 5; ) {
    i++;
}
*/










//!================================================================================================================================================
//? Switch
// https://learn.javascript.ru/switch

//? выполняет строгое сравнение

//? если по ходу выполнения был заход в case(то есть выполнение условия), то будут все последующие case, если в них не прописан break
/*
let a = 2;
switch (a) {
    case 1:
        console.log(1);
    case 2:
        console.log(2);   //выполнится без break
    case 10:
        console.log(3);   //выполнится без break
}
*/


//? группировка case
/*
switch (a) {
    case 1:
    case 2:
        console.log(1);
}
*/










//!================================================================================================================================================
//? Functions Функции
// https://learn.javascript.ru/arrow-functions
// https://learn.javascript.ru/function-basics
// https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8#.D0.9B.D0.B5.D0.BA.D1.81.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_vs._.D0.B4.D0.B8.D0.BD.D0.B0.D0.BC.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D0.BE.D0.B1.D0.BB.D0.B0.D1.81.D1.82.D0.B8_.D0.B2.D0.B8.D0.B4.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D0.B8
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/function
// https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0


//? функция это обьект первого класса(может быть возвращена и передана как параметр...)


//? функция имеет полный доступ к внешним переменным, но сначала ищет их внутри себя


//? аргументам функции можно присвоить значения по умолчанию(если их не передать будет undefined у аргумента)
/* function f() return; let a = f();   //undefined*/


//? Function Declaration включает хостинг(всплытие функций) в глобальном пространсве(аналогия с var). В строгом режиме не всплывают выше блока, в котором объявлены
/* function sayHi() { alert( "Привет" ) } */


//? Function Expression объявляет функцию по ходу выполнения кода
/* let sayHi = function() { alert( "Привет" ) } */


//? arguments - массив аргументов функции, arguments в строгом режиме не связан с каждым аргументом, если изменить один, другой не изменится
//? но если передать обьект, и в функции либо через arguments.<свойство>, либо просто через обращение к аргументу изменить свойство, мы модифицируем переданный обьект
/*
function f(a) {
    arguments[0] = 1;
    console.log(arguments);   //1
    console.log(a);   //0
}
f(0);
*/





//?================================================================================================================================================
//? Стрелочные функции Arrow functions


//? у стрелочной функции всегда тот контекст, в котором она определена. Стрелочной функции нельзя задать контекст через привязку, она будет всегда иметь тот контекст, в котором была создана


//? они не имеют обьект arguments


//? если один аргумент, можно опустить скобки, и не писать return если выражение помещается в одну строку
/* let f = a => a*2; */





//?================================================================================================================================================
//? /Рекурсия/
// https://learn.javascript.ru/recursion

//? Когда функция производит вложенный вызов, происходит следующее:
//? Выполнение текущей функции приостанавливается.
//? Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
//? Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
//? После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.


//? рекурсия хранит в памяти n различных контекстов, что следовательно влияет на производительность





//?================================================================================================================================================
//? /LexicalEnvironemt/Лексическое окружение/Замыкания/
// https://learn.javascript.ru/closure
// http://jsflow.org/docs/create-exec-phase
// https://webdevblog.ru/kak-rabotaet-javascript/





//? LexicalEnvironemt
//? В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment
//? LexicalEnvironemt существует для всех блоков кода {}, то есть оно создается в условиях, циклах, функциях


//? Объект лексического окружения состоит из двух частей:
//? 1) Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).  "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта»
//? 2) [[Environment]] ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок) или outer

//? Лексическое окружение – это специальный внутренний объект
//? «Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение объекта должно оставаться таким, как было описано.





//? Один вызов – одно лексическое окружение. Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.
/*
function makeCounter() {
    let count = 0;

    return function incr() {
        return ++count;
    }
}
let counter1 = makeCounter();   //вызвали makeCounter и создали одно лексическое окружение для функции counter1, теперь когда она будет вызываться постоянно будет ссылка на это окружение
console.log(counter1());   //будет увеличиваться потому что внутри нет такой переменной и она будет браться из лексического окружения родительской функции
console.log(counter1());
console.log(counter1());
*/
//? Также тут внутренняя функция имеет доступ к переменным наружней, потому что они есть в памяти, лексическое окружение будет до тех пор, пока будет ссылка на него, в данном примере внутрненняя функция имеет доступ к переменным наружней и они используются и следовательно лексическое окружение наружней будет доступно





//? Сборка мусора в функциях
//? Обычно лексическое окружение очищается и удаляется после того, как функция выполнилась
/*
function f() {
    let value1 = 123;
    let value2 = 456;
}
f();   //Здесь два значения, которые технически являются свойствами лексического окружения. Но после того, как f() завершится, это лексическое окружение станет недоступно, поэтому оно удалится из памяти.
*/
//? Но, если есть вложенная функция, которая всё ещё доступна после выполнения f, то у неё есть свойство [[Environment]], которое ссылается на внешнее лексическое окружение, тем самым оставляя его достижимым, «живым». Если функцию ниже вызвать несколько раз то будет создано несколько лексических окружений, которые будут держаться в памяти до тех пор, пока будет доступна ссылка на функцию возвращенную из f();
/*
function f() {
    let value = 123;
    return function g() { alert(value); }
}
let g = f();
g();        //пока что есть ссылка на окружение родительской функции
g();        //пока что есть ссылка на окружение родительской функции
g = null;   //а сейчас мы удалили ссылку на функцию, которая имела ссылку на окружение родительской функции
*/


//? Важный пример:
/*
function makeArmy() {
    let shooters = [];
    let i = 0;
    while (i < 10) {
        let shooter = function() {
            alert(i);
        };
        shooters.push(shooter);
        i++;
    }

    return shooters;
}
let army = makeArmy();
army[0](); // у 0-го стрелка будет номер 10
army[5](); // и у 5- номер 10
*/
//? это происходит потому что переменная i объявлена в лексическом окружении makeArmy, и когда цикл отработает функция shooter будет ссылаться на значение 10. Это потому, что i была определена не в теле цикла, а снаружи него. Чтобы избежать этих проблем можно переписать на цикл for или использовать внутри другую переменную
/*
function makeArmy() {
    let shooters = [];
    let i = 0;
    while (i < 10) {
        let j = i;
        let shooter = function () { // функция shooter
            alert(j); // должна выводить порядковый номер
        };
        shooters.push(shooter);
        i++;
    }
    return shooters;
}
let army = makeArmy();
army[0](); // 0
army[5](); // 5
*/


//? Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы. Если функция была создана в глобальном окружении, то там будет ссылка на него
//? Не имеет значения, какой способ объявления функции используется: Function Declaration или Function Expression. Все функции получают свойство [[Environment]], которое ссылается на лексическое окружение, в котором они были созданы





//? Замыкание
//? Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение и это - new Function, при создании функции подобным образом в ее [[Environment]] записывается только глобальная область видимости).
//? То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным.
//? Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, как работает лексическое окружение.





//? Временная мертвая зона
//? Также есть понятие временная мертвая зона. Когда компилятор идет по коду и видит, например, что в функции идет обращение к переменной, которая определена позже, ошибки не будет, ошибка будет, если вызвать функции до объявления переменной.
/*
function func() {           //начало временной мертвой зоны
    console.log(myVar);
};
let myVar = 3;          //конец мертвой зоны
func();         //вызов функции после окончания временной мертвой зоны
*/
//? Тут также есть прикол с typeof оператором. Дело в том, что в первом консоле будет ошибка, т.к. переменная запрошена во время мертвой зоны, а второй переменной просто нет
/*
console.log(typeof foo);        //Uncaught ReferenceError: foo is not defined
console.log(typeof aVariableThatDoesNotExist);         //undefined
let foo;
*/


//? Всплытие/LexicalBinding
//? Из-за компиляции в функции worker сначала объявится функция value, а затем при РАБОТЕ кода она поменяется на 10, и внешний консоль лог выведет 100, т.к. внутри функции была изменена локальная переменная
/*
let value = 100;
function worker() {
    value = 10;
    return;
    function value() {}
}
worker();
console.log(value);     //100

тут же из-за всплытия будет записано вторая функция, то есть во время компиляции будет записана вторая функция
function outer() {
    function inner() {
        return 3;
    }
    return inner();
    function inner() {
        return 8;
    }
}
let result = outer();
console.log(result);

var value = 10;         //в лексическом undefined
let worker = function() {
    console.log("Первое значение: " + value);           //в лексическом undefined во время компиляции, при выполнении тоже
    var value = 20;                                     //тут определяем значение
    console.log("Второе значение: " + value);           //тут уже в лексическом определено значение
};
worker();
console.log("Третье значение: " + value);               //берется значение из текущего окружения
*/

//? Почему функции объявленные, через function всплывают? Когда компилятор проходит по коду, он записывает такие функции сразу в лексическое окружение, как объявленные, а все остальные он записывает как undefined, и устанавливает их значения только во время выполнения программы. То есть вот почему в функции, которая написана следующим образом, будут доступны переменные, потому что они уже "предзаписаны в лексическое окружение"
/*
во время компиляции будет такое лексическое окружение: {a: undefined, f:()=>{},}

let a = 1;
f();
function f() {
    console.log(a);     //при компиляции тут будет ссылка на undefined, а значение а присвоится только во время работы программы
}
*/





//?================================================================================================================================================
//? IIFE  Immediately-Invoked Function Expressions
// https://learn.javascript.ru/closure#iife


//? Раньше в JS не было лексического окружения на уровне блоков кода, поэтому использовались самовызывающиеся функции


//? IIFE - immediately-invoked function expressions
//? функция, которая объявляются и сразу же сама себя вызывает
/*
(() => {
    console.log(1);
})()
*/





//?================================================================================================================================================
//? Объект функции, NFE Named Function Expression
// https://learn.javascript.ru/function-object


//? Функция это обьект, а значит у нее есть свои методы и свойства

//? свойство - это не переменная, оно не имеет своего лексического окружения, то есть оно всегда относится к этой функции

//? length - показывает сколько параметров принимает функция
/*
function f2(a, b) {};
alert(f2.length);   //2
*/

//? name - имя функции

//? можно также определить пользовательские свойства функции, например счетчик, чтобы узнать сколько раз она вызывалась
/*
function say() {
    say.counter++;
}
say.counter = 0;   //начальное значение
say();
say();
say();
say();
console.log(say.counter);   //4
*/





//? NFE Named Function Expression
//? при function expression можно задать сразу имя переменной и самой функции, в этом есть плюс, когда мы внутри функции хотим отбратиться к ней же. А вот если мы из переменной sayHi удалим значение функции, то внутри, при обращении к sayHi мы получим ошибку, т.к. такая переменная не будет содержать функции(надо обращаться к func внтури функции)
/*
let sayHi = function func(who) {
    if (who) {
        alert(`Hello, ${who}`);
    } else {
        sayHi("Guest");   // Ошибка: sayHi не является функцией
    }
};
let welcome = sayHi;
sayHi = null;
welcome();   // Ошибка, вложенный вызов sayHi больше не работает!
*/





//?================================================================================================================================================
//? Синтаксис New Function
// https://learn.javascript.ru/new-function


//? Функцию можно объявлять через оператор new, куда первым аргументом приходят аргументы в виде строки, вторым - тело функции в виде строки
/*
let sum = new Function('a', 'b', 'return a + b');
alert(sum(1, 2)); // 3
*/


//? У такой объявленной функции [[environment]] ссылка будет ссылать на глобальный обьект
/*
function f() {
    let value = 18;
    return new Function('return value');   //это работать не будет, т.к. ссылка есть только на глобальную область видимости
}
console.log(f()());
*/





//?================================================================================================================================================
//? setTimeout и setInterval
// https://learn.javascript.ru/settimeout-setinterval


//? Эти функции поставляются окружением в котором воспроизводится JS


//? Принимают в виде параметров функцию, задержку и аргументы, которые надо передать в функцию
//? эти функции возвращают идентификатор таймера, чтобы можно было его обнулить
/*
function f(...args) {
    console.log(...args);
}
let id = setTimeout(f, 2000, 1, 2, 2, 3, 4, 5);
clearTimeout(id);
*/


//? Преимущества рекурсивного setTimeout перед setInterval:
//? Рекурсивный метод ждет сначала выполнения кода внутри функции, а только затем запускает таймер еще раз, т.е. если код ресурсоемкий setTimeout будет более точен во времени, а setInterval будет запускаться независимо от того, был ли выполнен код внутри функции или нет


//? Интервалы лучше всего ВСЕГДА отменять, когда они больше не нужны, потому что внешние переменные, к которым они обращаются, будут в памяти до тех пор, пока работают интервалы!!!. Для производительности лучше всего всегде очищать таймеры


//? setTimeout с нулевой задержкой
//? причины, почему функция отработает не сразу:
//? 1 - браузер сам подставит задержку 10мс
//? 2 - это то, что сначала таймер попадет в событийный цикл, а только потом в стек выполнения функций, поэтому он запустится не прям сразу
/*
setTimeout(() => {
    console.log('timer');
}, 0);
console.log(1);
*/





//?================================================================================================================================================
//? Decorators Декораторы
// https://learn.javascript.ru/call-apply-decorators


//? Принимают в себя функцию и как то модифицируют ее
/*
function delay(f, time) {
    return (...args) => {
        setTimeout(() => {
            f(...args);
        }, time);
    }
}
function f(arg) {
    console.log(arg);
}
let d1000 = delay(f, 1000);
d1000('test');
*/





//?================================================================================================================================================
//? Привязка контекста
// https://learn.javascript.ru/bind
// https://learn.javascript.ru/call-apply


//? В примере ниже мы привязываем контекст конкретно к обьекту и передаваемому аргументу
/*
function askPassword(ok, fail) {
    let password = prompt("Password?", '');
    if (password == "rockstar") ok();
    else fail();
}
let user = {
    name: 'John',

    login(result) {
        alert(this.name + (result ? ' logged in' : ' failed to log in'));
    }
};

askPassword(user.login.bind(user, true), user.login.bind(user, false));
*/


//? call и apply отличаются только синтаксисом, одна функция принимает арументы через запятую, другая массив аргументов, и обе вызывают функцию сразу же с этими аргументами





//?================================================================================================================================================
//? Каррирование/Curry
// https://learn.javascript.ru/currying-partials


//? Каррирование функции, это модифицирование функции таким образом, чтобы ее можно было вызывать разным количеством вызовов, делается это для того, чтобы замкнуть определенный нужный нам аргумент, чтобы в дальнейшем не передавать его
/*
function curry(_function) {
    return function curried(...arguments1) {
        if (arguments1.length >= _function.length) {
            return _function.apply(this, arguments1);
        } else {
            return (...arguments2) => {
                return curried.apply(this, arguments1.concat(arguments2));
            }
        }
    }
}

function log(a, b, c) {
    return a + b + c;
}

let one = curry(log);
console.log(one(1, 1, 1));
console.log(one(1)(2)(3));
*/
//? Логика такая, что мы модифицурем функцию, возвращая новую, и если новая функция принимает аргументов столько же, сколько и модифицируемая, то мы просто вызываем ее, если нет, то снова возвращаем функцию и вызываем модифицирующую функцию curried, куда передаем сконкатенированные аргументы.
//? По поводу зачем apply?, в блоке else он нужен для того, чтобы привязать массив arguments1 и постоянно конкатенировать именно с ним, иначе будет происходить конкатенация с внутренним массивом при каждом проваливании в блок кода else, это можно увидеть, поставив консоль лог на массив arguments1 перед if блоком.










//!================================================================================================================================================
//? Promises Промисы
// https://learn.javascript.ru/promise-basics


//? Промис(обещание), это класс для работы с асинхронными функциями
//? Принимает функцию, в которую прокидывается 2 аргумента resolve, reject, первый можно вызывать, когда все ок, и асинхронная операция завершилась, второй - когда закончилась ошибкой


//? Может вернуть либо успешное значение либо ошибку, сразу вызвать и то и то нельзя





//? then, catch, finally

//? then в цепочке вызовов отработает, когда промис закончится, then принимает 2 аргумента в виде функций, и вызывает первую, когда промис выполнился успешно, второй - когда с ошибкой
//? по сути catch делает тоже самое
/*
promise.then(
    function(result);   //обработает успешное выполнение
    function(error);   //обработает ошибку
);
*/





//?================================================================================================================================================
//? Цепочка промисов
//https://learn.javascript.ru/promise-chaining


//? в then можно создать новый промис и вернуть его, и получается мы в каждом then можем создать асинхронную функцию, которая будет выполняться последовательно и будут ждать другие
//? в примере ниже я создал промис и вызвал resolve через 2 секунды, все это время в then, мой код ждал меня, затем я снова во втором then создал асинхронную функцию и вернул ее из then, и следующий после then выполнится только когда вернется значение из предыдущего
/*
console.log('before promise');
let p = new Promise((resolve, reject) => {
    console.log('start async function');

    setTimeout(() => {
        console.log('async code');
        resolve();
    }, 2000);
});
p
    .then(() => {
        console.log('resolve then');
    })
    .then(() => {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log('second async function');
                resolve();
            }, 2000);
        })
    })
    .then(() => {
        console.log('sync function after async');
    });
*/


//? В цепочке промисов мы можем выкинуть ошибку в блоке catch, и отработает следующий catch, может быть удобно, если в один промис определенная ошибка, то мы можем перейти к другому catch блоку который для такой ошибки и предназначен


//? Если в промисе выпала ошибка и у нас нет блока catch, то наш скрипт упадет полностью, но также можно отследить такие ошибки через глобальный слушатель 'unhandledrejection', который вешается на window





//?================================================================================================================================================
//? Promise API
// https://learn.javascript.ru/promise-api


//? Promise.all
//? ждет выполнения всех переданных ему в виде массива(или любого перебираемого обьекта) промисов, и только затем вызывается функция then, а как результат у функции then будет массив всех значений промисов переданных, а также они будут в той же последовательности, в которой были переданы


//? если хоть один промис был закончен с ошибкой, то all немедленно завершится и будет вызван блок catch


//? в Promise.all помимо промисов можно также передать обычные значения, которые затем также будут собраны в массив по окончанию
/*
let _1 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('1');
        resolve();
    }, 1000);
});
let _2 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('2');
        resolve();
    }, 2000);
});
let _3 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('3');
        resolve();
    }, 3000);
});

Promise.all([_1, _2, _3])
    .then((res) => {
        console.log(res);   //[undefined, undefined, undefined] потому что наши промисы ничего не возвращали
        console.log('after waiting all promises');
    });
*/


//? Promise.allSettled
//? этот метод делает все тоже самое, что и all, только если один промис был выполнен с ошибкой, то он не упадет, а продолжит работу, затем также соберет все промисы в массив преобразив в обьект каждый из них у которого будет одно поле это value, второе это status(fulfilled, rejected)
/*
let _1 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('1');
        resolve();
    }, 1000);
});
let _2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('2');
        reject();
    }, 2000);
});
let _3 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('3');
        resolve();
    }, 3000);
});

Promise.allSettled([_1, _2, _3])
    .then((res) => {
        console.log(res);
        console.log('after waiting all promises');
    });
*/

//? В старых браузерах может понадобиться полифилл
//? Логика такая: при передаче промисов методу all, мы проходимся по ним map'ом, и когда он будет выполняться, map наш будет менять насильно в статус выполнен, и уже в обработчике мы будем создавать обьект со значениями
/*
let _1 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('1');
        resolve();
    }, 1000);
});
let _2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('2');
        reject();
    }, 2000);
});
let _3 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('3');
        resolve();
    }, 3000);
});

Promise.all([_1, _2, _3]
    .map(p => Promise.resolve(p)
        .then(
            (value) => {
                console.log('then in map');
                return { value, status: 'good' }
            },
            (error) => {
                console.log('catch in map');
                return { value: error, status: 'bad' }
            },
        )
    )
).then(res => {
    console.log(res);
});
*/


//? Promise.race
//? Ждет первого готового и запускает then блок, в который прокидывает значения готового промиса
/*
let _1 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('1');
        resolve();
    }, 1000);
});
let _2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('2');
        reject();
    }, 2000);
});

Promise.race([_1, _2, _3]).then(res => {
    console.log(res);
});
*/


//? Promise.resolve/reject
//? Создает промис насильно с определенным результатом, нужен тогда, когда мы обязательно должны получить промис из определенного выражения
//? Ниже записи идентичны
/*
let promise = new Promise(resolve => resolve('done'));
let promise2 = Promise.resolve('done2');
console.log(promise);
console.log(promise2);
*/










//!================================================================================================================================================
//? Async/await
// https://learn.javascript.ru/async-await


//? Движок будет парсить async await в промисы, в нативном js у нас нет такой возможности
//? То есть функция, к которой был применен async будет промисом, после ее вызова можно будет применить цепочку из then
//? В самом теле функции можно использовать оператор await для того, чтобы ждать асинхронные операции в теле функции(получается если у нас в теле функции есть несколько Promisов, то мы можем не писать их через then, а просто поставить перед промисом оператор await, и код внутри функции пойдет дальше только после того, как промис будет выполнен)
/*
async function f() {
    await new Promise((resolve) => {
        setTimeout(() => {
            console.log('async 2000');
            resolve();
        }, 2000)
    });
    console.log('after async operation');
}
f();
*/


//? У такой конструкции обработка ошибок будет через обычный try..catch, либо же мы можем к самой функции, если у нас нет такого обработчки, приенить catch конструкцию, т.к. все равно async преобразует метод в промис
/*
async function f() {}
f().catch((err) => {});
*/


//? Также можно преобразовывать методы классов в асинхронные функции
/*
class A{
    constructor() {}
    async log() {
        console.log('some');
    }
}
*/










//!================================================================================================================================================
//? Сборщик мусора
// https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0
// https://learn.javascript.ru/garbage-collection


//? сборщик удаляет обьеты те, на которые больше нет ссылок, даже если удаляемый обьект имеет ссылки на другие, он будет удален, потому что важны только ссылающиеся на него связи
/*
let user = {name: 'dima'};
user = null;   //сборщик видит, что мы не ссылаемся на обьект и удаляет его


let user = {name: 'dima'};
let admin = user;
user = null;   //пока что еще обьект есть, так как на него ссылается admin
admin = null;   //сборщик удаляет обьект
*/










//!================================================================================================================================================
//? Objects обьекты
// https://learn.javascript.ru/object


//? пустой обьект является true всегда


//? объявляется
/*
let a = new Object();
let b = {};
*/


//? обращение со свойствами
/*
delete object.name;   //удалить
delete object['long name of key']   //удалить
*/


//? динамическое создание ключей с помощью квадратных скобок
/*
let a = 'name';
let obj = {
    [a]: 'dima',   //создаст свойство с ключом 'name'
}
*/


//? in оператор для проверки свойства в обьекте, передается в строке, потому что если передать переменную в виде ключа, то значит название свойства обьекта находится в этой переменной.
//? В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, когда оно не подходит, и нужно использовать "in". это когда свойство существует, но содержит значение undefined:
/*
let a = {name: 'Alex'};
console.log('name' in a);   //true
*/


//? перебор обьектов через for in.  key - ключи, a[key] - значения
/*
let a = {name: 'dima', age: 22};
for (let key in a) {}
*/


//? свойства в обьекте сортируются в след. порядке: сначала идут целочисленные(это те, которые можно из строки перевести в число и обратно не потеряв смысла), а затем все остальные в порядке добавления
/*
let a = {
    '49',
    '1',
    dima: 'dima',
}
consolt.log(a)   //1, 49, dima
*/





//?================================================================================================================================================
//? Сравнение обьектов
//? 2 обьекта равны только тогда, когда это один и тот же обьект
//? Обьекты никогда не равны друг другу, если это только не один и тот же обьект, сравниваются ссылки обьектов
//? но при сравнении примитивов с обьектами при нестрогом сравнении, обьекты сначала преобразуются к примитивам своими методами встроенными или же нашими кастомными
/*
let a = {};
a == '[object Object]'
*/


//? обьекты копируются по ссылке, то есть если переменной присвоить другой обьект, то обе переменные будут ссылаться и изменять один и тот же обьект





//?================================================================================================================================================
//? Копирование обьектов

//? поверхностное копирование, копирует только верхние значения(если свойство будет обьектом, то оно скопируется по ссылке)
//? Object.assign
/*
let o1 = {
    a: 1,
}
let o2 = {
    d: 4,
}
let obj = Object.assign({}, o1, o2);
obj.a = 10;
*/





//? глубокое копирование
//? for in, логика такая, что мы перебираем обьект и присваиваем новое значение в другой обьект
/*
function cloneDeep(newObject, objectToBeCloned) {
    for (let key in objectToBeCloned) {
        if (typeof objectToBeCloned[key] !== 'object') {
            newObject[key] = objectToBeCloned[key];
        } else {
            newObject[key] = {};
            cloneDeep(newObject[key], objectToBeCloned[key]);
        }
    }
}
*/


//? JSON.parse JSON.stringify/JSON.parse(JSON.stringify)
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
let newObj = JSON.parse(JSON.stringify(obj));
obj.secondObj.one = 'изменил';
console.log(obj);
console.log(newObj);
*/





//?================================================================================================================================================
//? Преобразование обьектов
// https://learn.javascript.ru/object-toprimitive


//? по дефолту обьект преобразуется в [object Object] если со строкой складывают, в NaN если с числом и он всегда равен true


//? все методы по преобразования должны возвращать примитивное значение и только!


//? Алгоритм преобразований к примитивам следующий:
//? Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует.
//? Иначе, если хинт равен "string" происходит попытка вызвать obj.toString(), затем obj.valueOf(), смотря что есть.
//? Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf(), затем obj.toString(), смотря что есть.





//? Symbol.toPrimitive
//? метод, если есть, определяет все преобразования обьекта, можно самому решать, во что он будет преобразовываться
//? обьект преобразуется в число, например если он приводится явно к числу, в этом методе будет hint number
//? к строке, если например будет alert, т.к. там только строковый тип данных используется, hint будет string
//? default, если будет конкатенация
/*
let a = {
    name: 'dima',
    age: 22,
    [Symbol.toPrimitive](hint) {
        console.log(hint);
        if (hint === 'string') {
            return this.name;
        }
        if (hint === 'default') {
            return this.name;
        }
        if (hint === 'number') {
            return this.age;
        }
    }
}
alert(a);   //dima
console.log(a + '');   //dima
console.log(+a);   //22
*/


//? toString/valueOf
//? если нет метода toPrimitive, то код сначала попробует вызывать toString для хинта string, valueOf для иных хинтов
/*
let a = {
    name: 'dima',
    age: 22,
    toString() {
        return this.name;
    },
    valueOf() {
        return this.age;
    }
}
alert(a);   //dima
console.log(a + '');   //'22'
console.log(+a);   //22
*/


//? в отсутствие Symbol.toPrimitive и valueOf, toString обработает все случаи преобразований к примитивам


//? Symbol.toStringTag
//? меняет поведение методов преобразования обьектов к строке, можно указать, какое строковое значение будет возвращено
/*
let obj = {
    [Symbol.toStringTag]: "User",
}
alert(obj);   '[object User]'
*/





//?================================================================================================================================================
//? Флаги и дескрипторы свойств обьекта
// https://learn.javascript.ru/property-descriptors


//? У свойств обьекта есть 3 флага:
//? writable – если true, свойство можно изменить, иначе оно только для чтения(ошибки при присвоении этому свойству нового значения будут выброшены только в use strict, иначе проигнорируются)

//? enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют

//? configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя


//? Object.defineProperty(obj, propertyName, descriptor)
//? По умолчанию при обычном создании обьекта через {}, все флаги установлены true, но мы также можем изменить их потом, как нам нужно
/*
Object.defineProperty(obj, 'name', {
    writable: false,
    configurable: false,
    enumerable: false,
});
*/


//? Object.defineProperties(object, descriptors)
//? метод для определения сразу нескольких дескрипторов свойств
/*
let obj = {};
Object.defineProperties(obj, {
    name: {value: 'dima', writable: false, configurable: false, enumerable: false},
});
*/


//? Object.getOwnPropertyDescriptors
//? получить все дескрипторы свойств обьекта, вместе с Object.defineProperties можно клонировать свойства сразу с его флагами
/*
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
*/





//?================================================================================================================================================
//? Обьект может иметь только один прототип, но большую цепочку

//? При обращении к свойству обьекта, обьект сначала ищет его внутри себя, а затем в своих прототипах

//? Если мы наследуемся от обьекта, и у родительского обьекта мы поменяем значение свойства, то оно изменится и в дочернем обьекте(вернее будет сказать, что дочерний обьект будет ссылаться на свойство в прототипе, а оно, естественно, будет изменено)










//!================================================================================================================================================
//? Prototype/Прототип
// https://learn.javascript.ru/prototype-inheritance


//? прототип - то, от чего наследуемся
//? prototype есть только у классов и функций(объявленных через function)


//? __proto__
//? есть у всех классов, обьектов и функций(т.к. это тоже обьект) и является это свойство ссылкой на prototype родителя, а также через него можно задавать прототип
//? у классов также есть __proto__ и ссылается он на Function.prototype, т.к. класс это функция и создан класс был через new Function


//? чтобы понять, чему равен __proto__ в конкретном обьекте(классе), надо точно понять с помощью какого конструктора он был создан. Например {} был создан через new Object, значит его прото будет равно Object.prototype, class One например является функцией и был создан через new Function, а значит Function.prototype будет результатом ссылки из прото
//? __proto__ ссылается всегда на prototype класса с помощью которого он был создан(в этом prototype как раз есть конструктор, с помощью которого и был создан обьект)





//? class Parent {}
//? class Child extends Parent{}
// ? console.log([].__proto__ === Array.prototype);                                                     был создан с помощью Array
//? console.log({}.__proto__ === Object.prototype);                                                     создан с помощью Object
//? console.log(Array.__proto__ === Function.prototype);                                                был создан с помощью Function
//? console.log(String.__proto__ === Function.prototype);                                               был создан с помощью Function
//? console.log(Function.__proto__ === Function.prototype);                                             был создан с помощью Function
//? console.log(Object.__proto__ === Function.prototype);                                               был создан с помощью Function
//? console.log(Object.prototype.__proto__ === null);                                                   прото прототипа обьект null
//? console.log(Function.prototype.__proto__ === Object.prototype);                                     был создан с помощью Object
//? console.log(Parent.__proto__ === Function.prototype);                                               был создан с помощью Function
//? console.log(Child.__proto__ === Parent.prototype.constructor && Child.__proto__ === Parent);        был создан с помощью Parent.constructor
//? console.log(Child.prototype.__proto__ === Parent.prototype);                                        был создан с помощью Parent





//? prototype не равен никаким другим прототипам, он единственный в своем роде!!! То есть он равен только __proto__ которое на него ссылается и все
//? prototype есть только у классов и функций(объявленных через function)


//? Обьект может иметь только один прототип, но большую цепочку

//? При обращении к свойству обьекта, обьект сначала ищет его внутри себя, а затем в своих прототипах

//? Если мы наследуемся от обьекта, и у родительского обьекта мы поменяем значение свойства, то оно изменится и в дочернем обьекте





//? Способы установки прототипов:

//? __proto__
//? Это геттер сеттер для установки прототипа обьекту
/*
let animal = {
    legs: 4,
}
let dog = {
    name: 'Alex',
    age: 5,
}
dog.__proto__ = animal;
console.log(dog);
console.log(dog.__proto__);   //animal   -   тоже самое что и [[Prototype]]
*/


//? setPrototypeOf
//? Устанавливает на обьект прототип


//? Object.create(null);
//? создание обьекта без протипа вообще, но и естественно не будет методов обьекта


//? При использовании геттера и сеттера и методов родительского обьекта, где используется this, this будет равен обьекту, на котором используется метод
//? Это на самом деле очень важная деталь, потому что у нас может быть большой объект со множеством методов, от которого можно наследовать. Затем наследующие объекты могут вызывать его методы, но они будут изменять своё состояние, а не состояние объекта-родителя.
/*
let animal = {
    legs: 4,
    value: 100,
    get info() {
        return this.legs + ' ' + this.value;
    },
}
let dog = {
    name: 'Alex',
    age: 5,
    dog.__proto__ = animal,
}
dog.value = 300;
console.log(dog.info);
*/


//? for..in проходится не только по свойствам обьекта но и еще по свойствам прототипа





//?================================================================================================================================================
//? F.prototype
// https://learn.javascript.ru/function-prototype


//? Для функции конструктора можно указать перед ее созданием прототип, от которого она будет наследоваться, указать можно напрямую через prototype. Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
/*
function One() {
    this.name = 'Alex';
}
One.prototype = { age: 22 };
let person = new One();
console.log(person);
*/





//?================================================================================================================================================
//? Встроенные прототипы
// https://learn.javascript.ru/native-prototypes


//? У всех значений кроме null и undefined есть встроенные прототипы, именно по этому мы можем вызывать на значениях методы и работать с ними

//? При обращении к примитивам js как бы создает из примитива обькт, выполняет метод, который нам нужен был, и возвращает этот обьект снова к примитиву

//? Мы можем сами менять встроенные методы прототипов и переписывать язык









//!================================================================================================================================================
//? /This/Контекст/
// https://learn.javascript.ru/object-methods
// https://tproger.ru/translations/javascript-this-keyword/


//? Контекст определяется ВО ВРЕМЯ ВЫЗОВА ФУНКЦИИ


//? контекст у вызова функции обычной - undefined(strict mode), window(обычный код)
/*
function f() {
    console.log(this);   //undefined
}
*/


//? контекст вызова стрелочной функции - контекст в котором она была определена, то есть контекст родителя, если она вызвана в глобальной области - window
//? стрелочная функция берет контекст из лексического окружения родителя
/*
let f = () => {
    console.log(this);   //window
}
*/


//? методы обьекта ссылаются на сам обьект, который его вызвал, то есть метод имеет контекст вызвавшего обьекта. То есть если один обьект имеет метод, и другой наследуется от первого, то второй будет вызывать метод родителя, и следовательно контекст будет второго обьекта, т.к. он вызывает метод.
/*
let obj = {
    a: 'dima',
    f() {
        console.log(this);   //метод ссылает на обьект, который его вызвал
        let s = () => {
            console.log(this);   //стрелочная функция ссылается на контекст родителя
        }
        s();
    }
}
obj.f();


let obj = {
    name: 'dima',
    f() {
        console.log(this);
    },
}
let obj2 = {
    age: 22,
};
Object.setPrototypeOf(obj2, obj);
obj2.f();   //obj2 покажет, т.к он и вызывал метод
*/


//? стрелочный метод обьекта не имеет контекста обьекта, в отличии от класса(но привязать их нельзя ни тот ни тот)
/*
let obj = {
    f: () => {
        console.log(this);
    }
}
obj.f();   //window  у обьектов у стрелочных методов нет контекста обьекта

class User {
    constructor(age) {this.age = age}
    f = () => {
        console.log(this);
    }
}
let user = new User(22);
user.f();   //user  у экземпляров класса есть контекст экземпляра
*/


//? методы отделенные от обьекта в переменную не будут иметь собственного контекста, this всегда зависит от того, КТО вызывает метод, тоже самое происходит, когда мы передаем функцию, как колбэк
// https://learn.javascript.ru/object-methods#vnutrennyaya-realizatsiya-ssylochnyy-tip
/*
let obj = {
    name: 'dima',
    f() {
        console.log(this);
    },
}
let obj2 = {
    age: 22,
    f2: obj.f,
};
obj2.f2();   //obj2  мы отделили метод от obj, но вызывает его второй обьект, поэтому obj2


let obj = {
    name: 'dima',
    f() {
        console.log(this);
    },
}
let f = obj.f;
f();   //undefined  мы отделили метод, и вызываем глобально, поэтому контекста нет, это теперь просто функция

setTimeout(obj.f, 1000);   //undefined  т.к. мы отделили метод, надо привязать, чтобы избежать этого
*/


//? this в конструкторе это новосозданный экземпляр обьекта
/*
function User(name, age) {
    this.name = name;
    this.age = age;
    this.f = () => {
        console.log(this);
    }
}
let obj = new User('dima', 22);
obj.f();   //obj

class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    f = () => {
        console.log(this);
    }
}
let user = new User('dima', 22);
user.f();   //user
*/
//? new вызов в конструкторах обязателен!! из за него может теряться контекст!!(проблема для не обычного режима кода)
/*
new User();
*/


//? bind call apply
//? методы не работают со стрелочной функцией, стрелочной функции нельзя задать контекст через привязку, она будет всегда иметь тот контекст, в котором была создана
/*
class User {
    constructor(age) {
        this.age = age;
    }
    f() {
        console.log(this);
    }
    f2 = () => {
        console.log(this);
    }
}
let a = new User(22);
let b = {
    name: 'dima',
}
a.f.bind(b)();   //b, обычную функцию привязали
a.f2.bind(b)();   //a, потому что стрелочная
a.f();   //a
*/


//? bind жестко связывает функцию с переданным контекстом, создает функцию новую, которую затем надо вызвать
/*
function f(a) {
    console.log(this * a);
}
f.bind(3)(6);
*/


//? в событиях DOM, this ссылается на элемент, на котором начинается событие, если функция обычная, если стрелочная, то хуй знает, что там будет










//!================================================================================================================================================
//? Функции конструкторы
// https://learn.javascript.ru/constructor-new

//? new.target
//? в теле конструктора можно вызвать new.target, с помощью которого можно проверить была функция вызвана через new или нет
/*
function User(age) {
    if (!new.target) throw TypeError('забыл New оператор при создании!')
    this.age = age;
}
*/


//? возврат значения из конструктора
//? если возвращаем обьект, то вернем его, если примитив, то вернем новосозданный экземпляр обьекта


//? если конструктор ничего не принимает, можно опустить скобки вызова(для класса и функций)










//!================================================================================================================================================
//? Classes Классы
// https://learn.javascript.ru/class


//? Класс - это синтаксический сахар над функцией конструктором(есть пара нюансов)
//? Синтаксис класса делает следующее:
//? Создается функция конструктор с именем класса, а ее вызов будет содержать тело constructor
//? Все методы класса записываются в прототип этого класса
//? Все геттеры сеттеры также записываются в прототип этого класса
//? Свойства класса создаются при вызове оператора new, то есть они находятся именно в самом экземпляре класса

//? В итоге в прототипе класса A.prototype будет содержаться функция конструктор(constructor) и все методы объявленные в этом классе
/*
class A {
    constructor(age) {
        this.age = age;
    }
    sayAge() {
        return this.age;
    }
}
let agedPerson = new A(22);
*/





//?================================================================================================================================================
//? Наследование классов
// https://learn.javascript.ru/class-inheritance


//? Вот пример того, что методы записываются в прототип класса, а свойства в экземпляры
/*
class A {
    constructor(age) {
        this.age = age;
    }

    sayAge() {
        return this.age;
    }
}

let a = new A(22);
let a2 = new A(100);

a2.age = 123213213;
console.log(a.sayAge());   //22
console.log(a2.sayAge());   //123213213

a2.__proto__.sayAge = function () {   // тут я переопределил метод именно в прототипе класса A, а значит он поменялся у обоих созданных обьектов
    return 'а вот хер там, верну строку';
}

console.log(a.sayAge());   //'а вот хер там, верну строку';
console.log(a2.sayAge());   //'а вот хер там, верну строку';
*/

//? Тут я перезаписываю метод в прототип наследуемого класса
/*
class A {
    constructor(age) {
        this.age = age;
    }

    sayAge() {
        return this.age;
    }
}
class B extends A {
    constructor(age, name) {
        super(age);
        this.name = name;
    }
    sayAge() {
        return `${this.age} перезаписал, он теперь в прототипе класса B`;
    }
}
let b = new B(22, 'Alex');
console.log(b);
console.log(b.sayAge());   //`${this.age} перезаписал, он теперь в прототипе класса B`; потому что метод записался в прототип класса B и перезаписал предыдущий, до предыдущего нет доступа
*/


//? После extends разрешены любые выражения
//? Синтаксис создания класса допускает указывать после extends не только класс, но любое выражение. Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от многих условий и затем наследовать их.
/*
function f(phrase) {
    return class {
        sayHi() { alert(phrase) }
    }
}
class User extends f("Привет") {}
new User().sayHi(); // Привет
*/


//? Если мы хотим достучаться до родительского класса и вызвать у него свойство или метод, нам нужно обратиться через super к свойству или методу
//? Также в конструкторе вызов super() вызывает из прототипа конструктор родительского класса
//? То есть грубо говоря вызовом super мы обращаемся к родительскому классу


//? У стрелочных функций нет super
//? для того, чтобы с super нормально работать, нужно понимать какой контекст в функции, в которой мы вызваем super, super как бы связан с контекстом
//? т.к. у обычных функций контекст undefined, то и super не отработает
/*
class A {
    constructor(age) {
        this.age = age;
    }
}
class B extends A {
    constructor(age, name) {
        super(age);
        this.name = name;
    }
    sayAge() {
        setTimeout(function () { console.log(super.age()) }, 1000);   //такое не запустится
    }
}
*/





//?================================================================================================================================================
//? Статические свойства и методы
// https://learn.javascript.ru/static-properties-methods


//? В классе можно объявить статические свойства и методы, они не будут записаны в "прототип" класса, а будут находится только в данном классе
/*
class User {
    static age = '32';
    constructor() {
        this.level = 22;
    }
    static sayHi() {
        console.dir(this);
    }
}

let a = new User();
a.sayHi();   //не сработает, т.к. sayHi есть только у класса, тоже самое и со свойством age
console.log(User.a);
*/


//? Статические значения наследуются и также будут доступны в конкректном дочернем классе





//?================================================================================================================================================
//? Приватные и защищенные поля
// https://learn.javascript.ru/private-protected-properties-methods


//? Есть соглашение всеобщее программистов, что защищенные поля, к которым нельзя получать напрямую доступ вне класса начинаются с _
/*
class A{
    _forbidden = true;
}
*/


//? Приватные поля и методы начинаются с #
//? Они не наследуются, то есть доступ к ним есть ТОЛЬКО в конкретном классе и все, нет ни в наследуемых классах ни в экзмеплярах обьекта
//? Единственный способ получения значения вне класса это геттер или функция
//? Такие поля сначала объявляются сверху перед конструктором
//? Также получить доступ через ['#name'] нельзя, специальная защита свойств
/*
class First {
    #hidden;
    constructor() {
        this._name = 'Alex';
        this.#hidden = 'hidden';
    }
    get hidden() {
        this.#logThis();
        return this.#hidden;
    }
    #logThis = () => {
        console.log('this');
    }
}
class Second extends First {
    constructor() {
        super();
    }
}
let obj1 = new First();
let obj2 = new Second();
console.log(obj1);
console.log(obj2);
console.log(obj2.hidden);
*/





//?================================================================================================================================================
//? Instanceof
// https://learn.javascript.ru/instanceof


//? Показыват, наследуется ли наш обьект от определенного класса, он считает классы также в цепочке прототипов, если мы создали массив, то он будет и instanceof Object и instanceof Array
/*
let arr = [1, 2, 3];
alert( arr instanceof Array ); // true
alert( arr instanceof Object ); // true
*/





//?================================================================================================================================================
//? Примеси
// https://learn.javascript.ru/mixins


//? Примесь, это подмешивание в класс методов и свойств из другого обьекта
//? Получается, мы в прототип класса подмешиваем нужные нам методы, и те же методы можно потом подмешть в другой нужный нам класс, но чтобы он не зависел от первого
/*
let sayHiMixin = {
    sayHi() {
        alert(`Привет, ${this.name}`);
    },
    sayBye() {
        alert(`Пока, ${this.name}`);
    }
};
class User {
    constructor(name) {
        this.name = name;
    }
}
Object.assign(User.prototype, sayHiMixin);
new User("Вася").sayHi();   //Привет, Вася!
*/










//!================================================================================================================================================
//? Symbol символы
// https://learn.javascript.ru/symbol


//? символы никогда не равны друг другу, даже если задать одинаковое описание


//? символы одинаковы, если они заданы глобально через Symbol.for и имеют одно и то же описание, в других случая всегда разные
/*
let id1 = Symbol("id");
let id2 = Symbol("id");
alert(id1 == id2);   //false
*/


//? символы не преобразуются в стороки сами по себе, если мы хотим их вывести, нам надо явно самим преобразовать их toString


//? можно получить описание символа через description
/*
let a = Symbol('id');
console.log(a.description);
*/


//? скрытность свойства
//? обратиться к свойству в обьекте, которое записано через символ можно через []
/*
let a = Symbol('id');
let obj = {
    [a]: '1',
}
console.log(obj[a]);
*/


//? for in не перебирает свойства - символы
//? Object.keys(obj) не видит их также
//? Object.assign() копирует абсолютно все свойства
//? Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами
//? Reflect.ownKeys(obj) который возвращает все ключи объекта, включая символьные


//? Symbol.for  глобальные символы
//? если мы хотим использовать глобально символы, мы можем определить их и обращаться через описание символа, и нам гарантированного вернется один и тот же
//? если его не было, мы записали в переменную а символ с описанием, и если он уже создан, мы берем символ из глобального пространства и записываем в b, а значит они равны
/*
let a = Symbol.for('id');
let b = Symbol.for('id');
console.log(b === a);
*/
//? но так мы можем получить только глобальные символы, ниже код уже не сработает
/*
let a = Symbol.for('id');
let b = Symbol('id');
console.log(b === a);   //false
*/


//? Symbol.keyFor
//? получить описание символа по символу, работает только для глобальных символов
/*
let a = Symbol.for('id');
let b = Symbol('id');
let c = Symbol.for('id');
console.log(Symbol.keyFor(a) === Symbol.keyFor(c));   //true, 2 глобальных символа имеют одно и то же описание
console.log(Symbol.keyFor(b));   //undefined, не глобальный символ
*/










//!================================================================================================================================================
//? Работа с примитивами. Почему у примитивов есть методы?
// https://learn.javascript.ru/primitives-methods


//? при вызове "." у примитива js создает обьект, у которого есть все методы, которые мы можем использовать(например toFixed), как только мы вызываем метод этот, js удаляет обьект и возвращает примитив


//? также можно создавать примитив через new, но это крайне не желательно, т.к. при таком создании мы создаем обьект, а не примитив, а следовательно это может привести к ошибкам
/*
let a = new String('');
if (a) {
    console.log(a);
}
*/


//? null/undefined не имеют методов, попытка вызвать свойство приведет к ошибке










//!================================================================================================================================================
//? Числа
// https://learn.javascript.ru/number


//? большие числа можно записать через "e"
/*
let a = 1000;
let b = 1e3;
a === b;    //true

let c = 1e-4;   //0.0001
*/


//? неточности вычислений
//? в формате IEEE 754 всегда такая ошибка, поэтому надежный способ, округлять числа до нужного количества знаков после запятой
/*
alert( 0.1 + 0.2 == 0.3 );   //false
alert( 0.1 + 0.2 );   //0.30000000000000004
*/


//? isNaN вернет true, если это не число, почему нельзя использовать сравнение с NaN?, потому что NaN не равен ничему другому, даже себе NaN===NaN   //false
/*
isNaN(NaN);   //true
*/


//? isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным(конечным)
/*
console.log(isFinite(12));   //true
console.log(isFinite('23'));   //true
console.log(isFinite('23fsd'));   //false
*/


//? Второй аргумент parseInt(str, radix), мы можем задать, в какой системе счисления мы ищем числа в строке










//!================================================================================================================================================
//? String строки
// https://learn.javascript.ru/string

//? можно использовать спецсимволы, например перевод строки "\n"


//? строки можно перебирать через for of, т.к. у них есть символ итератор


//? Обращение к символу по индексу
//? обращаться к определенном символу можно через [] или через str.charAt(), если не будет значения в первом случае вернется undefined, во втором пустая строка
//? charAt отличается от [], тем, что метод вернет пустую строку, если нет такого символа, а [] вернет undefined, также метод может принимать булеан значения и преобразует их в числа










//!================================================================================================================================================
//? Array массивы
// https://learn.javascript.ru/array


//? это обьект по сути, поэтому также копируется по ссылке


//? перебор массива
// https://learn.javascript.ru/array#perebor-elementov


//? for..of работает только с теми типами данных, для которых задан Symbol.iterator!!!
//? for..of рекомендуется или for обычный

//? for in тоже можно, но если наш массив является каким то массивом с допольнительными свойствами и методами, они также будут включены в перебор, в отличии от for of


//? Array.isArray()
//? проверяет это массив или нет, потому что typeof вернет обьект


//? в функциях перебора массива(filter, и т.д) можно передать последний аргумент thisArg, который установит this в функции на переданный
// https://learn.javascript.ru/array-methods#bolshinstvo-metodov-podderzhivayut-thisarg





//? Пребразование массивов
//? массивы преобразуются к строке по своему
//? пустой массив будет '', если он не пуст, то значения его преобразуются в строку, а затем сконатенируются в одну строку через запятую










//!================================================================================================================================================
//? Итерируемые перебираемые обьекты/Symbol.iterator
// https://learn.javascript.ru/iterable
// https://www.youtube.com/watch?v=7wtbNNiOh30&ab_channel=%D0%92%D0%BB%D0%B0%D0%B4%D0%B8%D0%BB%D0%B5%D0%BD%D0%9C%D0%B8%D0%BD%D0%B8%D0%BD


//? Symbol.iterator
//? метод с помощью которого есть возможность перебирать массивы, map, set, строки, а также все те обьекты, где используем этот метод, через for..of, Array.from, spread.
//? Symbol.iterator - функция, которая возвращает обьект с методом next, который возвращает обьект с полями done, value. Каждый раз итератор увеличивается на один и возвращает следующее нужное нам значение, пока верно условие


//? Важная оговорка!
//? Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
//? Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.


//? если мы создали класс с методом итерации и потом наследуемся от него, то метод итерации пожно перезаписать










//!================================================================================================================================================
//? Map Set
// https://learn.javascript.ru/map-set


//? MAP
//? Map может содержать в виде ключей все, что угодно и обьекты и т.д; в отличии от обьекта хранит ключи в том порядке, в каком они были записаны


//? в Map можно задавать только итерируемые значение, который содержат ключ-значения
/*
new Map([
    [1,1],
    [true, false],
    [name, 'dima'],
]);
*/


//? Map from object
//? сначала нужно перевести обьект в массив массивов Object.entries, и затем создать Map
/*
let obj = {
    name: 'bla',
    age: 22,
    gdsf: 'sdfsdf',
    '1': '1',
};
let map = new Map(Object.entries(obj));
*/


//? Object from entries
//? можно вызвать на Map entries метод и затем результат запихнуть в Object.fromEntries
/* Object.fromEntries(map.entries()) */





//? Методы
//? map.set(key, value) – записывает по ключу key значение value

//? map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует

//? map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false

//? map.delete(key) – удаляет элемент по ключу key

//? map.clear() – очищает коллекцию от всех элементов

//? map.size – возвращает текущее количество элементов

//? map.keys() – возвращает итерируемый объект по ключам

//? map.values() – возвращает итерируемый объект по значениям

//? map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of
/*
for (const iterator of map.keys()) {
    console.log(map.get(iterator));
}
*/


//? Map from array
//? сначала массив надо перевести в entries, и затем создать map
/*
let arr = ['Dima', 22, true, 'not married'];
let map2 = new Map([...arr.entries()]);
console.log(map2);
*/


//? Array from Map
//? вроде как нет методов нормальных, только через перебор и пуш в массив
/*
let arr = ['Dima', 22, true, 'not married'];
let map2 = new Map([...arr.entries()]);   ||   let map2 = new Map(Object.entries(arr));

let arrFromMap = [];
for (const iterator of map2) {
    arrFromMap.push(iterator[1]);
}
console.log(arrFromMap);
*/





//?================================================================================================================================================
//? SET


//? set хранит только уникальные значения


//? Методы
//? set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set

//? set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false

//? set.has(value) – возвращает true, если значение присутствует в множестве, иначе false

//? set.clear() – удаляет все имеющиеся значения

//? set.size – возвращает количество элементов в множестве


//? методы перебора те же, что и у map


//? Set from Object и обратно
/*
let obj = {
    name: 'bla',
    age: 22,
    gdsf: 'sdfsdf',
    '1': '1',
    'name': '123123',
    'age': 100
}
let set = new Set(Object.entries(obj));   //создал set
console.log(Object.fromEntries(set));   //снова в обьект
*/


//? Set from array
//? в отличии от Map, Set можно создать из простого массива, и сразу удалить все повторявшиеся значения
/*
let arr = [1, 3, 4, 4, 4, 4, 4, 4, 'dima', 22];
let set = new Set(arr);
console.log(set);
*/










//!================================================================================================================================================
//? WeakMap WeakSet
// https://learn.javascript.ru/weakmap-weakset


//? WeakMap - не предотвращает удаление свойства, если ключом выступал обьект, который был удален из кода. Т.е. если мы удалим обьект, то он пропадет и из weakmap
/*
let obj = { name: 'dima' };
let wMap = new WeakMap().set(obj, 'обьект');
obj = null;
console.log(wMap.get(obj));   //undefined
console.log(wMap.has(obj));   //false
*/


//? У него есть только след. методы:
//? weakMap.get(key)

//? weakMap.set(key, value)

//? weakMap.delete(key)

//? weakMap.has(key)


//? потому что чистщик мусора может удалить сразу обнуленный обьект, а может потом удалить разом сразу несколько обьектов для оптимизации, поэтому в разное время могут быть разные значения в этой структуре данных





//?================================================================================================================================================
//? WeakSet
//? может содерждать в себе только обьекты
//? имеет то же самое поведение, что и WeakMap










//!================================================================================================================================================
//? Деструктуризирующее присваивание
// https://learn.javascript.ru/destructuring-assignment


//? можно вытащить по отдельному индексу значение и сразу присвоить в переменную, можно также пропустить ненужные значения
/*
let arr = [1, 2, 3, 'alex', 4];
let [one, two, , name] = arr;
console.log(one, two, name);
console.log(arr);
*/


//? Деструктурирующее присваивание не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные


//? можно сразу присваивать в обьект
/*
let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');
alert(user.name); // Ilya
*/


//? можно также установить значения по умолчанию
/*
let [one = 1, two = 2] = [];
*/





//?================================================================================================================================================
//? Деструктуризация с обьектами
//? если мы из обьекта вытаскиваем другой обьект, из которого нам также надо вытащить свойство, то обьект будет недоступен, т.к. мы деструктуризируем его значение
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};

let { name = 'Alex', age, secondObj: { one, two } } = obj;   //secondObj не будет доступен
console.log(name, age, one, two);
console.log(obj);
*/


//? также можно менять на ходу название переменной
/*
let obj = {age: 22};
let {age: NewAge} = obj;
*/


//? важный момент, заранее если объявить переменные, нужно будет при деструктуризации блок кода обернуть в ()
/*
let obj = {
    name: 'Dima',
    age: 22,
};
let name, age;
({ name, age } = obj);   //без скобок будет ошибка, т.к. компилятор посчитает, что это отдельный блок кода
console.log(name, age);
*/










//!================================================================================================================================================
//? Date Дата
// https://learn.javascript.ru/date
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date










//!================================================================================================================================================
//? JSON
// https://learn.javascript.ru/json
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON


//? JSON поддерживает следующие типы данных:
//? Объекты { ... }, Массивы [ ... ]
//? Примитивы: строки, числа, логические значения true/false, null

//? Важное ограничение: не должно быть циклических ссылок.





//? есть всего 2 метода:
//? stringify - парсит в json формат
//? принимает еще 2 параметра(Массив свойств для кодирования или функция соответствия function(key, value)) и (Дополнительное пространство (отступы), используемое для форматирования.)
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
console.log(JSON.stringify(obj));
*/


//? parse - достает обьект из json
//? функция может принимать 2 параметр, функцию по преобразованию значений
//? функция выдаст ошибку, если json не корректный, поэтому лучше обрабатывать try..catch
/**
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
console.log(JSON.parse(JSON.stringify(obj)));
*/





//? также можно использовать комбинацию методов для глубокого копирования
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
let newObj = JSON.parse(JSON.stringify(obj));
obj.secondObj.one = 'изменил';
console.log(obj);
console.log(newObj);
*/


//? toJSON
//? можно реализовать метод в обьекте, который будет вызывать при преобразовании обьекта в json, это тоже самое что и valueOf и toString
/*
let room = {
    number: 23,
    toJSON() {
        return this.number;
    }
};
console.log(JSON.stringify(room));
*/










//!================================================================================================================================================
//? Обработка ошибок
// https://learn.javascript.ru/try-catch


//? try…catch…finally
//? Try..catch работает синхронно, и если внутри try у нас асинхронный скрипт, то наш трай кэтч не поймает его, т.к. он уже запустит код асинхронный и пойдет дальше


//? Throw Оператор
//? выкидывает ошибку (error, referenceerror и т.д.)


//? Если у нас в блоке try есть return чего-то, то сначала выполнится finally(если в нем есть return, то вернется значение из finally, если нет, то просто отработает скрипт) и вернется значение из блока try
/*
function func() {
    try {return 1;}
    catch (e) {}
    finally {return 2;}
}
let a = func();
console.log(a);
*/


//? мы можем обработать ошибку на всем документе вызвав onerror слушатель на window
/*
globalThis.addEventListener('error', () => {
    console.log('ошибка');
});
throw new Error('bla');
*/










//!================================================================================================================================================
//? Modules Модули
// https://learn.javascript.ru/modules-intro


//? Статические импорты
//? ниже импорты и экспорты служат для задания костяка приложения, и они статичны, чтобы всякие сборщики могли потом собрать приложение

//? Чтобы указать файлу скрипта, что это модуль, нужно добавить аттрибут type="module", чтобы были доступны экспорт и импорт


//? модули являются отложенными (deferred)(тоже самое, что и deferred аттрибут для скрипта), то есть выполнение кода будет только после того, как загрузится весь dom


//? в модулях всегда 'use strict'


//? экспортируемая функциональность, даже если она импортируется в несколько модулей будет вызвана один раз, то есть например функция, которую импортируем в несколько файлов, будет вызвана один раз


//? все подключенные скрипты-модули отработают в порядке подключения, сначала полностью отработает первый, второй, и т.д., естественно, ассинхронные функции будут выполнены когда до них дойдет очередь



//? export
//? обычный синтаксис, можно также экспортировать as "", то есть переименовывать при экспорте переменную
/*
export let a = 1;
let b = 2;
export b as b1;

import {a} from '';
*/


//? export default
//? экспортировать можно по дефолту, то есть при импорте не надо ставить фигурные скобки, как в обычном импорте
//? есть подводный камень, что импортированную по дефолту переменную можно обозвать как хочешь, это может принести проблемы
/*
export defaule let a = 1;

import b from '';
*/


//? import
//? существут директива для импорта значений из одного файла в другой, также можно переименовывать переменную, чтобы она была доступна под другим названием
/*
import {a as b} from '';
*/


//? import*
//? импорт всего как "", импортируем все экспортированные значения, как один обьект
/*
import * as object from '';
*/





//?================================================================================================================================================
//? Динамические импорты
// https://learn.javascript.ru/modules-dynamic-imports


//? import()
//? позволяет динамически импортировать модуль в файл, по условию и т.д, такой импорт может работать в обычных скриптах без указания аттрибута типа модуль


//? этот метод возврщает промис, в котором резултат - это обьект модуля










//!================================================================================================================================================
//? Proxy
// https://learn.javascript.ru/proxy
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy
// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots


//? Обьект прокси оборачивается вокруг функции, массива или обьекта и может перехватывать различные действия совершаемые над обьектом(установка значений, получений и т.д.)
//? Прокси – это обёртка вокруг объекта, которая «по умолчанию» перенаправляет операции над ней на объект, но имеет возможность перехватывать их.
//? Проксировать можно любой объект, включая классы и функции.


//? Создается через new Proxy
/*
let a = {};
let proxy = new Proxy(a, handler);
*/
//? Proxy – это особый, «экзотический», объект, у него нет собственных свойств. С пустым handler он просто перенаправляет все операции на target.





//? Прокси оборачивается вокруг цели и вторым аргументом мы описываем перехватчики
/*
let numbers = [0, 1, 2];
numbers = new Proxy(numbers, {
    get(target, prop) {
        if (prop in target) {
            return target[prop];
        } else {
            return 0;
        }
    },
});
console.log(numbers[2]);
*/
//? в данном примере мы поставили перехватчик на гет, и если такого значения нет в массиве, то вернем 0 по дефолту


//? разные хэндленры принимают разные аргументы, они не везде одни и те же


//? Важное правило и пожелание
//? Прокси обьект должен перезаписать тот обьект, к которому был применен, иначе можно легко запутаться кто есть кто. То есть мы перезаписываем в переменную проксировнный обьект.
/*
let a = {};
a = new Proxy(a, {});
*/


//? Прокси !== оригинальный обьект
//? То есть если в set установим обьект, как ключ, а затем проксируем его, то мы не сможем получить обьект из этой коллекции





//?================================================================================================================================================
//? Reflect
// https://learn.javascript.ru/proxy#reflect
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect


//? Следует использовать всегда, когда мы хотим перенаправить действие на изначальный проксированный обьект


//? Для каждого внутреннего метода, перехватываемого Proxy, есть соответствующий метод в Reflect, который имеет такое же имя и те же аргументы, что и у ловушки Proxy.


//? Служит этот класс для сохранения контекста
//? без рефлекта контекст будет теряться, если мы наследуемся от проксированного обьекта
//? например тут ниже без него сработало бы так: при обращении к admin.name он начал бы искать геттер и нашел его в прототипе, в проксированном user, там бы сработал перехватчик, и вызывался бы метод перехвата с this=target, а target это user изначальный, поэтому мы вызывали через reflect этот метод, куда передали третьим параметром receiver "контекст вызова"
/*
let user = {
    _name: 'Dima',
    get name() {
        return this._name;
    }
};
user = new Proxy(user, {
    get(target, prop, receiver) {
        return Reflect.get(target, prop, receiver);
    }
});

let admin = { _name: 'Admin' };
Object.setPrototypeOf(admin, user);

console.log('user', user.name);   //Dima
console.log('admin', admin.name);   //Admin   (без рефлекта вывелось бы Dima)
*/
//? Так что return Reflect... даёт простую и безопасную возможность перенаправить операцию на оригинальный объект и при этом предохраняет нас от возможных ошибок, связанных с этим действием.










//!================================================================================================================================================
//? Eval is evil
// https://learn.javascript.ru/eval


//? Позволяет воспроизвести переданную как строку строку кода

//? В строгом режиме создает свое лексическое окружение, поэтому нельзя снаружи eval достучаться до кода внутри

//? Внутри eval есть доступ к наружным переменным
/*
function f() {
    let a = 2;
    eval('alert(a)');   //2
}
f();
*/










//!================================================================================================================================================
//* ПОТОМ ПРОЧЕСТЬ НА ПОТОМ
//? Побитовые операторы
// https://learn.javascript.ru/bitwise-operators










//!================================================================================================================================================
//? BigInt
// https://learn.javascript.ru/bigint


//? BigInt нужен для работы с огромными числами, т.к. для обычных памяти не хватает


//? Такие числа всегда должны быть целыми и не возвращют дробные результаты, т.е. операции с ними возвращают всегда целое число


//? Также их нельзя смешивать с обычными при работе


//? Чтобы преобразовать после работы bigint в обычное число используется Number() функция
//? Конвертирование bigint в число всегда происходит неявно и без генерации ошибок, но если значение bigint слишком велико и не подходит под тип number, то дополнительные биты будут отброшены, так что следует быть осторожными с такими преобразованиями.
//? Унарный оператор + является хорошо известным способом конвертировать произвольное значение value в число. Данный оператор не поддерживается при работе с BigInt числами.


//? Операторы сравнения и логические операции ведут себя также, как с обычым числом, т.е. 0n это false и т.д.


//? Сравнение с числом при строгом будет выдывать ошибку, т.к. это другой тип данных, при обычном же все будет хорошо сравниваться, но если число больше, чем 2**53-1, то могут возникать ошибки при сравнении










//!================================================================================================================================================
//* ПОТОМ ПРОЧЕСТЬ НА ПОТОМ
//? Intl Интернационализация
// https://learn.javascript.ru/intl
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Intl
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
// https://index.minfin.com.ua/reference/currency/code/        ***коды валют










//!================================================================================================================================================
//? Window/Глобальный обьект
// https://learn.javascript.ru/global-object
// https://developer.mozilla.org/ru/docs/Web/API/Window


//? Window - это глобальный обьект браузера, то есть этот обьект доступен везде в коде, во всех модулях и т.д. потому что он глобальный


//? Каждая среда исполнения имеет собственный глобальный обьект(например в Node.js - global)
//? Поэтому, если код возможно будет где то запускаться помимо браузера, то ввели стандартизированное обращение к глобальному обьекту через globalThis, который поддерживается практически везде, так что можно пользоваться им спокойно










//!================================================================================================================================================
//? DOM/Document Object Model/BOM/Browser Object Model/CSSOM/Cascading Object Model
// https://learn.javascript.ru/dom-nodes
// https://learn.javascript.ru/browser-environment#dom-document-object-model
// https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction
// https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model
// https://developer.mozilla.org/en-US/docs/Web/API/Document        ***интерфейс


//? Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.


//? BOM - Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.
//? Например: Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее). Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.


//? Document
//? HTML документ - набор тегов, которые и являются обьектами DOM
//? Для получения и работы с DOM мы используем document, это точка входа в работу с домом, оттуда можно получить доступ к body, html(documentElement), doctype, head и т.д.
//? Document не одно и тоже, что и window, window, это самая верхняя в иерархии точка входа, это все окно браузера, а document, это документ, который загружен в текущем окне и именно отсюда доступно содержимое веб-страницы


//? document.body может быть равен null, если скрипт был поставлен тег head, и если он не "отложен", то мы не сможем получить доступ к body


//? Только для чтения
//? Все коллекции, которые мы получаем через querySelector и т.д., все они только для чтения, мы не можем написать lastChild = <div></div>, для этого надо использовать другие методы


//? DOM коллекции живые
//? Почти все DOM-коллекции, за небольшим исключением, живые. Другими словами, они отражают текущее состояние DOM. Если мы сохраним ссылку на elem.childNodes и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически.
//? Статическими коллекциями являются те, которые были созданы через querySelectorAll, в них всегда будут изначальные элементы, во всех остальных getElementsBy* будут динамическими, а также обращения через children тоже будут возвращать динамические коллекции
/*
let spans = document.querySelector('#test').children;
console.log(spans);   //3 span
spans[1].remove();
console.log(spans);   //2 span
*/





//?================================================================================================================================================
//? Навигация по DOM и взаимодействие с элементами
// https://learn.javascript.ru/dom-navigation
// https://developer.mozilla.org/ru/docs/Web/API/Element


//? Навигация по DOM:
//? Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling
//? Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling





//?================================================================================================================================================
//? Поиск элементов
// https://learn.javascript.ru/searching-elements-dom


//? Методы поиска:
//? document.getElementById
//? ищет элемент по указанному id, есть еще дополнительное поведение, которое не желательно использовать, это то, что в коде мы можем просто написать обращение к id элемента и мы получим его, сделано это для поддержки старого кода
//? применяется только на документ
/*
<div id="test"></div>
в коде***
console.log(test);   //сработает такое, и надо избегать подобного
*/

//? elem.querySelector/elem.querySelectorAll
//? querySelector - возвращает первый найденный элемент
//? querySelectorAll - принимает css селектор и возвращает по указанному селектору все элементы найденные, может применяться не только на document но и на элемент, также может принимать в себя псевдокласс, например :hover. Также этот метод возвращает статическую коллекцию

//? elem.matches
//? метод не ищет, а просто принимает в себя селектор и возвращает булеан значение по соответствию
/*
elem.matches('a[href$="zip"];
*/

//? elem.closest
//? принимает селектор и ищет в цепочке родителей/предков соответствие на данный селектор, начиная с самого себя
/*
<div>  <span></span>  <span></span>  </div>
let spans = document.querySelector('#test').children;
console.log(spans[0].closest('#test'));   //вернет div

let spans = document.querySelector('#test').children;
console.log(spans[0].closest('span'));   //вернет сам себя, потому что поиск начинается с себя
*/

//? elem.getElementsByTagName
//? ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.

//? elem.getElementsByClassName
//? возвращает элементы, которые имеют данный CSS-класс.

//? document.getElementsByName
//? возвращает элементы с заданным атрибутом name. Очень редко используется.





//? Статические коллекции и динамические
//? Статическими коллекциями являются те, которые были созданы через querySelectorAll, в них всегда будут изначальные элементы, во всех остальных getElementsBy* будут динамическими, а также обращения через children тоже будут возвращать динамические коллекции
/*
let spansParent = document.querySelectorAll('#test');
console.log(spansParent);
spansParent[0].remove();
console.log(spansParent);

let spansParent2 = document.getElementsByTagName('div');
console.log(spansParent2);
spansParent2[0].remove();
console.log(spansParent2);
*/





//?================================================================================================================================================
//? Свойства узлов
// https://learn.javascript.ru/basic-dom-node-properties


//? Каждый узел дома создается через наследование от других классов
//? Существуют следующие классы:
//? EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

//? Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. Но есть определённые классы узлов, которые наследуют от него: Text – для текстовых узлов, Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев.

//? Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: nextElementSibling, children и методы поиска: getElementsByTagName, querySelector. Браузер поддерживает не только HTML, но также XML и SVG. Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement.

//? HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы:

//? HTMLInputElement – класс для тега <input>,
//? HTMLBodyElement – класс для тега <body>,
//? HTMLAnchorElement – класс для тега <a>,  …и т.д, каждому тегу соответствует свой класс, который предоставляет определённые свойства и методы.
//? Таким образом, полный набор свойств и методов данного узла собирается в результате наследования.


//? nodeType
//? Свойство nodeType предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.
//? Его значением является цифра:
//? elem.nodeType == 1 для узлов-элементов, elem.nodeType == 3 для текстовых узлов, elem.nodeType == 9 для объектов документа, и т.д.


//? nodeName и tagName
//? выводят имя тега, разница в том, что tagName вернет что то только для тегов, которые являются элементами, nodeName есть у любых типов узлов


//? innerHTML
//? Вставить HTML код и прочесть его. Свойство innerHTML есть только у узлов-элементов.
//? при установке нового кода, старый будет перезаписан, а значит, если мы хотим просто добавить, надо сконкатенировать значения
//? так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.
/*
element.innerHTML = '<p>HELLO WORLD</p>';
*/


//? outerHTML
// https://learn.javascript.ru/basic-dom-node-properties#outerhtml-html-elementa-tselikom
//? свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.
//? Будьте осторожны: в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте. То есть если мы получили элемент, затем модифицировали его, то в ссылке на элемент будет все также находится старый код, поэтому надо снова получить элемент
/*
<div>Привет, мир!</div>

<script>
  let div = document.querySelector('div');
  div.outerHTML = '<p>Новый элемент</p>';   //заменяем div.outerHTML на <p>..
  alert(div.outerHTML); // <div>Привет, мир!</div>   // Содержимое div осталось тем же!
</script>
*/
//? То есть, при div.outerHTML=... произошло следующее: div был удалён из документа. Вместо него был вставлен другой HTML <p>Новый элемент</p>. В div осталось старое значение. Новый HTML не сохранён ни в какой переменной. Здесь легко сделать ошибку: заменить div.outerHTML, а потом продолжить работать с div, как будто там новое содержимое. Но это не так. Подобное верно для innerHTML, но не для outerHTML.
//? Мы можем писать в elem.outerHTML, но надо иметь в виду, что это не меняет элемент, в который мы пишем. Вместо этого создаётся новый HTML на его месте. Мы можем получить ссылки на новые элементы, обратившись к DOM.


//? textContent
//? Вставить текст в элемент и прочесть его
/*
element.textContent = 'HELLO WORLD';
*/


//? nodeValue/data
// https://learn.javascript.ru/basic-dom-node-properties#nodevalue-data-soderzhimoe-tekstovogo-uzla
//? Свойство innerHTML есть только у узлов-элементов. У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data


//? hidden
//? аттрибут, который скрывает элемент(по сути тоже самое, что и display: none)





//?================================================================================================================================================
//? Аттрибуты и свойства
// https://learn.javascript.ru/dom-attributes-and-properties


//? Когда создается дом, браузер парсит все аттрибуты и если они стандартные, то записывает их в обьект этого тега, например type будет доступен как свойство type в обьекте этого тега, все же остальные аттрибуты можно получить только с помощью методов
/*
<input type="phone"/>
*/


//? Все аттрибуты регистронезависимы, то есть 'id'==='ID', а также их значения всегда строки


//? Методы:
//? elem.hasAttribute(name)
//? проверяет наличие атрибута

//? elem.getAttribute(name)
//? получает значение  атрибута

//? elem.setAttribute(name, value)
//? устанавливает значение атрибута

//? elem.removeAttribute(name)
//? удаляет атрибут

//? elem.attributes
//? получить все аттрибуты елемента


//? Dataset
//? Можно использовать как обычные аттрибуты, так и аттрибуты с припиской data-, есть плюс в использовании второго варианта, что первые(могут когда нибудь ввестись в язык и быть нативными, что конечно маловероятно), поэтому аттрибуты можно также записывать кастомные с приставкой data-, и они будут также доступны с помощью методов, а также их можно получить через dataset свойство элемента, где в этом обьекте имена аттрибутов будут в camelCase
/*
let test = document.querySelector('#test');
test.setAttribute('custom-attribute-prop', true);
test.setAttribute('data-custom-attribute-prop', true);

console.dir(test.attributes['custom-attribute-prop'].value);
console.dir(test.getAttribute('data-custom-attribute-prop'));
console.dir(test.dataset.customAttributeProp);
*/





//?================================================================================================================================================
//? Изменение документа
// https://learn.javascript.ru/modifying-document


//? createElement
//? создает элемент, который затем надо поместить на страницу

//? createTextNode
//? создаёт текстовый узел (редко используется)

//? element.append()
//? Добавляет элемент в конец родителя

//? element.prepend()
//? Добавляет элемент вначло родителя

//? element.before(div)
//? Перед каким то элементом

//? element.after(div)
//? После какого то элемента

//? element.remove()
//? Удалить элемент из документа

//? element.replaceWith(div)
//? Какой элемент мы хотим заменить элементом в скобках

//? element.insertAdjacentHTML/Text/Element
//? Вставить HTML код перед, после и т.д.
//? "beforebegin" – вставить html непосредственно перед elem, "afterbegin" – вставить html в начало elem, "beforeend" – вставить html в конец elem, "afterend" – вставить html непосредственно после elem
/*
element.insertAdjacentHTML('afterend', '<h1>HELLO WORLD</h1>');
*/

//? element.cloneNode()
//? клонирует указанный элемент, принимает булеан параметр, если true - то глубоко копирует, вместе с детьми, если false - то только элемент с аттрибутами и классами


//? При перемещении узла, когда мы получили его и хотим поместить его в другое место на странице, он удалится автоматически со старого места, так что нет необходимости удалять его


//? DocumentFragment
// https://learn.javascript.ru/modifying-document#document-fragment
//? Специальный дом узел который служит оберткой для передачи списка узлов, который затем удаляется со страницы, то есть не парсится
/*
<ul id="ul"></ul>

<script>
function getListContent() {
    let fragment = new DocumentFragment();
    for(let i=1; i<=3; i++) {
        let li = document.createElement('li');
        li.append(i);
        fragment.append(li);
    }
    return fragment;
}
ul.append(getListContent());   //не отобразится в доме
</script>
*/


//? document.write
// https://learn.javascript.ru/modifying-document#neskolko-slov-o-document-write
//? Древний метод добавления содержимого на страницу, вызов функции этой генерирует здесь и сейчас строку
//? Вызов document.write работает только во время загрузки страницы. Если вызвать его позже, то существующее содержимое документа затрётся. Так что после того, как страница загружена, он уже непригоден к использованию, в отличие от других методов DOM, которые мы рассмотрели выше. Это его недостаток. Есть и преимущество. Технически, когда document.write запускается во время чтения HTML браузером, и что-то пишет в документ, то браузер воспринимает это так, как будто это изначально было частью загруженного HTML-документа. Поэтому он работает невероятно быстро, ведь при этом нет модификации DOM. Метод пишет прямо в текст страницы, пока DOM ещё в процессе создания. Так что, если нам нужно динамически добавить много текста в HTML, и мы находимся на стадии загрузки, и для нас очень важна скорость, это может помочь. Но на практике эти требования редко сочетаются. И обычно мы можем увидеть этот метод в скриптах просто потому, что они старые.





//?================================================================================================================================================
//? Styles Classes Стили Классы
// https://learn.javascript.ru/styles-and-classes


//? className
//? предоставляет классы элемента в виде строки
//? если мы присваиваем значение className, то мы заменяем уже все существующие классы, иногда полезно иногда нет


//? classList
//? предоставляет классы элемента в виде массива, а также методы для манипуляций с классами





//? Стили заданные через скрипт, то есть инлайном перебивают абсолютно все стили, то есть у них высший приоритет


//? style
//? стили задаются через присваивание значений этому обьекту, записываются названия стилей в camelCase
//? этот обьект только для задания значений, ничего прочитать мы не сможем
/*
document.body.style.backgroundColor = 'green';
*/
//? Стили с браузерным префиксом, например, -moz-border-radius, -webkit-border-radius преобразуются по тому же принципу: дефис означает заглавную букву
/*
button.style.MozBorderRadius = '5px';
button.style.WebkitBorderRadius = '5px';
*/

//? сброс стилей
//? просто присваиваем пустую строку, это значит, что мы устанавливаем значение по умолчанию


//? cssText
//? позволяет в строке записать сразу несколько стилей для элемента, но это свойство не добавляет, а ЗАМЕНЯЕТ все существующие стили
//? То же самое можно сделать установкой атрибута: div.setAttribute('style', 'color: red...')
/*
div.style.cssText = `
    color: red;
    background-color: yellow;
    width: 100px;
    text-align: center;
`;
*/


//? getComputedStyle
// https://developer.mozilla.org/ru/docs/Web/API/Window/getComputedStyle
//? возвращает объект, содержащий значения всех CSS-свойств элемента, полученных после применения всех активных таблиц стилей, и завершения базовых вычислений значений, которые они могут содержать

//? метод принимает сам элемент, и может принять псевдоэлемент, чтобы узнать его стили

//? лучше всего использовать в этом обьекте конкретный свойства(например не margin, marginLeft), потому что есть некие несоответствия в браузерах и дефолтное поведение отличается

//? Стили, применяемые к посещённым :visited ссылкам, скрываются! Посещённые ссылки могут быть окрашены с помощью псевдокласса :visited. Но getComputedStyle не даёт доступ к этой информации, чтобы произвольная страница не могла определить, посещал ли пользователь ту или иную ссылку, проверив стили. JavaScript не видит стили, применяемые с помощью :visited. Кроме того, в CSS есть ограничение, которое запрещает в целях безопасности применять к :visited CSS-стили, изменяющие геометрию элемента. Это гарантирует, что нет обходного пути для «злой» страницы проверить, была ли ссылка посещена и, следовательно, нарушить конфиденциальность.





//?================================================================================================================================================
//? Metrics Размеры и прокрутка страницы
// https://learn.javascript.ru/size-and-scroll


//? Важная деталь с padding!!!
//? если у нас много текста, то на него padding-bottom не работает, то есть текст может находиться там, где у нас есть падинг снизу, если текста много


//? offsetParent
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent
//? в свойстве offsetParent находится предок элемента, который используется внутри браузера для вычисления координат при рендеринге. то есть, ближайший предок, который удовлетворяет следующим условиям: является CSS-позиционированным (CSS-свойство position равно absolute, relative, fixed или sticky), или <td>, <th>, <table>, или <body>, то есть для обычных тегов в основном будет ссылка на body
//? Существует несколько ситуаций, когда offsetParent равно null:
//? для скрытых элементов (с CSS-свойством display:none или когда его нет в документе).
//? для элементов <body> и <html>.
//? для элементов с position:fixed.


//? свойства offsetLeft/offsetTop содержат координаты x/y относительно верхнего левого угла offsetParent


//? offsetWidth/offsetHeight
//? эти два свойства – самые простые. Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки и падинг


//? clientLeft/clientTop
//? это отступы от внешней части элемента до внутренней, если считать по простому, то это ширина рамок, но не все так просо, если же у нас полоса прокрутки будет слева, то и она будет засчитана в это значение(clientLeft). Как раз и получится, что отступ внутренней части от внешней


//? clientWidth/Height
//? это ширина и высота внутренней части элемента, включая падинг, но не включая рамку, и полосу прокрутки
//? это не точно???если паддингов нет и есть полоса прокрутки, то вернет значение вместе с полосой прокрутки


//? scrollWidth/Height
//? эти свойства – как clientWidth/clientHeight, но также включают в себя прокрученную (которую не видно) часть элемента.


//? scrollLeft/scrollTop
//? свойства, которые показывают прокрученные значения сверху и слева(которые не видно)
//? эти свойства изменяемы, и ими можно изменять прокрутку элемента





//? не использовать width/heigth из getComputedStyle
// https://learn.javascript.ru/size-and-scroll#ne-stoit-brat-width-height-iz-css
//? потому что эти значения зависят от значения 'box-sizing', а также они могут быть равны 'auto'


//? Примеры
/*
let test = document.querySelector('#test');

console.log('clientHeight', test.clientHeight);
console.log('clientWidth', test.clientWidth);
console.log('clientLeft', test.clientLeft);
console.log('clientTop', test.clientTop);
console.log('offsetParent', test.offsetParent);
console.log('offsetTop', test.offsetTop);
console.log('offsetLeft', test.offsetLeft);
console.log('offsetWidth', test.offsetWidth);
console.log('offsetHeight', test.offsetHeight);
console.log('scrollHeight', test.scrollHeight);
console.log('scrollTop', test.scrollTop);
console.log('contentWidth', test.clientWidth - parseFloat(getComputedStyle(test).paddingLeft) - parseFloat(getComputedStyle(test).paddingRight));   //ширина контента без всего
*/






//?================================================================================================================================================
//? Размеры и прокрутка окна
// https://learn.javascript.ru/size-and-scroll-window


//? documentElement.clientHeight
//? высота текущего окна без полосы прокрутки


//? documentElement.clientWidth
//? ширина текущего окна без полосы прокрутки


//? window.innerWidth/Height
//? отличаются от вышеперечисленных свойств тем, что включают в себя полосу прокрутки


//? documentElement.scrollHeight/scrollWidth
//? полная высота документа. а этом элементе, для страницы в целом, эти свойства работают не так, как предполагается. В Chrome/Safari/Opera, если нет прокрутки, то documentElement.scrollHeight может быть даже меньше, чем documentElement.clientHeight! С точки зрения элемента это невозможная ситуация. Чтобы надёжно получить полную высоту документа, нам следует взять максимальное из этих свойств:
/*
let scrollHeight = Math.max(
    document.body.scrollHeight, document.documentElement.scrollHeight,
    document.body.offsetHeight, document.documentElement.offsetHeight,
    document.body.clientHeight, document.documentElement.clientHeight
);
*/


//? documentElement.scrollLeft/scrollTop
//? получение текущей прокрутки. Существует баг, что в safari надо использовать document.body


//? window.pageYOffset/pageXOffset
//? получение текущей прокрутки


//? scrollTo, scrollBy, scrollIntoView
//? Прокрутка документа и элементов. Обычно можно прокручивать элементы меняя им scrollTop/scrollLeft, но также можно использовать эти методы
//? прокрутка не работает, пока дом не загружен полностью


//? Запретить скролл можно с помощью overflow='hidden'


//? Примеры
/*
console.log('clientHeight', document.documentElement.clientHeight);
console.log('clientWidth', document.documentElement.clientWidth);
console.log('innerHeight', window.innerHeight);
console.log('innerWidth', window.innerWidth);
console.log('scrollHeight', document.documentElement.scrollHeight);
console.log('scrollWidth', document.documentElement.scrollWidth);
console.log('scrollTop', document.documentElement.scrollTop);
console.log('scrollLeft', document.documentElement.scrollLeft);
console.log('pageYOffset', window.pageYOffset);
console.log('pageXOffset', window.pageXOffset);
*/





//?================================================================================================================================================
//? Координаты
// https://learn.javascript.ru/coordinates


//? element.getBoundingClientRect
//? метод возвращает координаты элемента относительно окна(экрана), то есть расчет всегда относительно верхнего левого угла экрана идет:
//? bottom - нижняя граница элемента относительно верха окна(может быть отрицательным, когда элемент выходит за границы)
//? top - левый верхний угол элемента относительно верха окна
//? left - левый верхний угол элемента относительно левой части окна
//? right - правая граница элемента относительно левой части окна
//? height - высота
//? width - ширина

//? top/left не всегда равный x/y, если например, задать x/y координаты 200/200, и ширину с высотой -200/-200, то top/left значения будут равны нулям


//? elementFromPoint(x, y)
//? возвращает самый глубоко вложенный элемент в окне по данным координатам
//? Для координат за пределами окна метод elementFromPoint возвращает null Метод document.elementFromPoint(x,y) работает, только если координаты (x,y) относятся к видимой части содержимого окна. Если любая из координат представляет собой отрицательное число или превышает размеры окна, то возвращается null.










//!================================================================================================================================================
//? События Events
// https://learn.javascript.ru/introduction-browser-events
// https://developer.mozilla.org/ru/docs/Web/Events        ***все события


//? in html
//? можно подписаться в самом html файле


//? element.onClick
//? можно подписаться вызывав определенное свойство обьекта тега, повторное присвоение обработчика перезапишет его, а чтобы обнулить его таким образом можно передать null


//? addEventListener
// https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener
//? вешаем обработчик на элемент через этот метод
//? при объявлении таким образом обработчика, мы можем сколько угодно повесить обработчиков на один и тот же элемент, но чтобы удалить обработчик, нужно точно знать ссылку на функцию, которая является обработчиком
/*
bla.addEventListener('click', (e) => {});   //такой обработчик нельзя обнулить

function click(e) {}   //а вот такой вариант сработает
bla.addEventListener('click', click);
bla.removeEventListener('click', click);
*/
//? принимает 3 параметра: само событие, обработчик, и обьект настроек
//? обьект настроек это: capture - boolean(отвечает за то, когда будет поймано событие, на погружении - true, на всплытие - false по дефолту),        once - boolean(обработчик будет вызван один раз и удален),        passive - boolean(обработчик никогда не может быть отменен через preventDefault)

//? handler принимает в себя обьект event, который содержит информацию по событию


//? получить доступ к элементу можно через this, это будет тот элемент, на котором висит обработчик события


//? Обработчики некоторых событий можно назначать только через addEventListener. Существуют события, которые нельзя назначить через DOM-свойство, но можно через addEventListener. Например, таково событие DOMContentLoaded, которое срабатывает, когда завершена загрузка и построение DOM документа.





//?================================================================================================================================================
//? Всплытие и погружение
// https://learn.javascript.ru/bubbling-and-capturing


//? все события(почти) проходят 2 фазы, погружение и всплытие, от документа, до самого вложенного элемента, внутри того, на котором висит обработчик, и обратно до документа
//? отсюда делаем вывод, что если у нас есть клик на body, и внутри него есть кнопка, на которой тоже есть клик, то при клике на кнопку, событие будет всплывать, и вызывать клик событие на всех элементах, на которых висит это событие, следовательно клик по кнопке вызовет и на кнопке событие и на body


//? this/event.target/currentTarget
//? this и currentTarget указывают на элемент, на котором ВИСИТ обработчик события, он не изменен никогда
//? target же, указывает на вложенный элемент, который находится внутри элемента, на котором висит обработчик события, и на котором как был вызван этот обработчик
/*
<div class='test' onclick='log'>
    <p>Click me</p>
</div>

function log(e) {
    console.log(e.target);   //если будет клик по p, то тут будет p(потому что этот элемент вызвал событие)
    console.log(e.currentTarget || this);   //в любом случае будет сам элемент на котором висит событие
}
*/


//? stopPropagation
//? отменяет всплытие события, советуют не отменять просто так его, т.к. это может быть достаточно удобно для сбора статистики, такой метод отменяет всплытие дальше, но на такущем элементе все обработчики этого события будут вызваны
//? вместо отмены всплытия можно решить попробовать проблему через делегирование
/*
document.body.addEventListener('click', (e) => {
    console.log('click body');
})

inside.addEventListener('click', (e) => {
    e.stopPropagation();   //т.к. остановили всплытие, событие до боди не дойдет
    console.log(e.target);
});
*/


//? stopImmediatePropagation
//? отменяет ВСЕ обработчики на данном элементе, кроме того, который сейчас отрабатывает, то есть если на элементе 2 обрабтчика клика и в первом мы вызываем метод, то второй обработчик не вызовется
/*
inside.addEventListener('click', (e) => {
    e.stopImmediatePropagation();
    console.log(e.target);
    console.log(e.currentTarget);
});
inside.addEventListener('click', (e) => {
    console.log('второй обработчик, и сюда не должно дойти');   //не вызовется, т.к. stopImmediatePropagation прекратит
});
*/


//? event.eventPhase
//? указывает на какой фазе было поймано событие


//? если на одном элементе несколько обработчиков, они все сработают в порядке объявления





//?================================================================================================================================================
//? Делегирование событий
// https://learn.javascript.ru/event-delegation


//? принцип работы такой, что вместо того, чтобы вешать событие на кучу элементов, которые мы хотим обработать, мы вешаем на их родителя и с помощью условий мы обрабатываем нужные нам элементы.
//? Плюс такой схемы в том, что если у нас элементы создаются динамически, то на всех на них будет срабатывать обработчик, но если же мы получили элементы, перебрали их черерз цикл и на каждый навесили обработчик, то при добавлении элемента на нем не будет обработчика


//?Всегда используйте метод addEventListener для обработчиков на уровне документа Когда мы устанавливаем обработчик событий на объект document, мы всегда должны использовать метод addEventListener, а не document.on<событие>, т.к. в случае последнего могут возникать конфликты: новые обработчики будут перезаписывать уже существующие. Для реального проекта совершенно нормально иметь много обработчиков на элементе document, установленных из разных частей кода.





//?================================================================================================================================================
//? Действия браузера по умолчанию
// https://learn.javascript.ru/default-browser-action


//? у браузеров есть дефолтное поведение, например клик по ссылке переходит на новую страницу, зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение и т.д.


//? event.preventDefault()
//? отменяет действия браузера по умолчанию, можно вызвать этот метод, а можно из обработчика, который назначен через on<событие> вернуть false
/*
<a href="/" onclick="return false">Нажми здесь</a>
<a href="/" onclick="event.preventDefault()">здесь</a>
*/


//? event.defaultPrevented
//? было ли поведение прекращено





//?================================================================================================================================================
//? Генерация пользовательских событий
// https://learn.javascript.ru/dispatch-events
// https://developer.mozilla.org/ru/docs/Web/API/Event/Event


//? мы можем создавать свои кастомные события, и вешать на элементы эти события, а затем в нужный нам момент диспатчить эти события на элементы
//? Event принимает имя евента, и обьект настроек:        bubbles: true/false – если true, тогда событие всплывает,        cancelable: true/false – если true, тогда можно отменить действие по умолчанию. Позже мы разберём, что это значит для пользовательских событий,        composed: true/false – если true, тогда событие будет всплывать наружу за пределы Shadow DOM
/*
const myCustomEvent = new Event('myCustomEvent', { bubbles: true });
let test = document.querySelector('#test');
document.addEventListener('myCustomEvent', (e) => {
    e.stopPropagation();
    console.log(e);
});
test.dispatchEvent(myCustomEvent);
*/
//? CustomEvent
//? лучше создавать подобные события через CustomEvent, т.к. в обьекте второго параметра можно указать доп. свойство detail, в которое можно запихнуть кучу информации, которая будет доступна через event.detail.<any>
/*
elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
});
elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "Вася" }
}));
*/
//? то есть смысл в этом в том, что мы можем на элемент повесить свое событие, и диспатчить его в нужный нам момент времени, и в этом событии как то реагировать на него(скрывать элемент и т.д)


//? для специфичных событий есть свои конструкторы со своими плюшками(например в MouseEvent есть данные о положении мыши) и лучше создавать такие события именно через подобные конструкторы


//? event.isTrusted
//? было ли событие сгенерировано браузером, или наше пользовательское событие. true - для браузерных, false - кастомные





//? вложенные события обрабатываются синхронно
// https://learn.javascript.ru/dispatch-events#vlozhennye-sobytiya-obrabatyvayutsya-sinhronno
//? это значит, что если у нас есть обработчик на кнопке, внутри которого мы диспатчим событие куда то, то сначала выполнится код перед диспатчем, затем выполнится код в кастомном обработчике события, и затем продолжит выполняться код в обработчике на кнопке
/*
<button id="menu">Меню (нажми меня)</button>
<script>
    menu.onclick = function() {
        alert(1);

        menu.dispatchEvent(new CustomEvent("menu-open", {
            bubbles: true
        }));

        alert(2);
    };
    document.addEventListener('menu-open', () => alert('вложенное событие'))
</script>
***Порядок вывода: 1 → вложенное событие → 2.
*/





//?================================================================================================================================================
//? События мыши
// https://learn.javascript.ru/mouse-events-basics


//? некоторые события есть и на тачскринах для совместимости

//? также одно событие может порождать другие, то есть, mousedown => mouseup => click


//? which
//? на какой кнопке произошло событие:      event.which == 1 – левая кнопка,        event.which == 2 – средняя кнопка,         event.which == 3 – правая кнопка


//? shift, alt, ctrl и meta
//? все события мыши имею инфу о нажатых клавишах модификаторах:        shiftKey: Shift,        altKey: Alt (или Opt для Mac),        ctrlKey: Ctrl,        metaKey: Cmd для Mac


//? clientX/Y, pageX/Y
//? все события мыши имею координаты:       относительно окна: clientX и clientY,       относительно документа: pageX и pageY





//? Движение мыши
// https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave


//? relatedTarget
//? дополнительным свойством является relatedTarget, это тот элемент, на котором была мышь до текущего элемента(если с div перенести на span мышь, то div - relatedTarget, span - target), но на mouseout все наоборот(event.target – это элемент, с которого курсор ушёл, event.relatedTarget – это элемент, на который курсор перешёл)
//? может быть null и означает, что курсор или вышел или зашел из пределов окна


//? mouseover пропуск элементов
//? браузер генерирует события не на каждый пиксель, а с определенным интервалом, это значит, что если пользователь будет двигать слышком быстро мышью, то некоторые элементы не успеют отработать событие

//? но в одном можно быть уверенным, если было событие mouseover(или интер), то будет mouseout, его перескачить нельзя, если уже было вхождение

//? событие mouseover, происходящее на потомке, всплывает. Поэтому если на родительском элементе есть такой обработчик, то оно его вызовет.


//? mouseout
//? важная вещь, что это событие генерируется и на потомках элемента, на котором висит событие. По логике браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным и верхним по z-index.
/*
<div id="test">
    <span>example</span>
</div>
*/
//? когда мышь зайдет на span, сработает событие mouseout, т.к. это потомок на котором висит событие


//? mouseenter/mouseleave
//? они похожи на маусовер и маусаут, но есть пара отличий важных:      они не всплывают, и она не срабатывают на потомках, только на самих себе
//? они очень просты, но т.к. они не всплывают нельзя их делегировать





//? Клавиатурные события
// https://learn.javascript.ru/keyboard-events


//? keydown/keyup
//? нажатие и отпускание клавиши


//? event.code/key
//? key - символ события, то есть сам символ, которые был сейчас использован, например буква а в верхнем или нижнем регистре(то есть key изменяем), code - код события, он всегда один и тот же, например KeyZ(при нажатии на zZ)
//? если изменить язык ввода, то key изменится на символ другого языка, но код останется тем же
//? есть плюсы и минусы использования обоих: если хотим поддерживать клавиши, меняющиеся при раскладке - key, если хотим поддерживать события даже при переключении на другой язык - code, но code может не работать в некоторых местах(например KeyZ), из за разных раскладок у разных пользователей


//? event.repeat
//? была ла зажата клавиша надолго?


//? дефолтные нажатия, такие как delete, page up, отменяются так же через preventDefault почти во всех браузерах


//? keypress, а также свойства keyCode, charCode, which считаются устаревшими
// https://learn.javascript.ru/keyboard-events#dela-minuvshih-dney





//?================================================================================================================================================
//? События указателя
// https://learn.javascript.ru/pointer-events
// https://developer.mozilla.org/ru/docs/Web/API/Pointer_events


//? раньше отдельно использовали события мыши и тач ивенты, но писать код, чтобы поддерживать и тач, и мышь, и перо проблемотично, поэтому сделали события указателя, которые поддерживаются везде, кроме очень старых версий браузера


//? есть много новых свойств, вот пара из них:
//? isPrimary – равно true для основного указателя (первый палец в мульти-тач)

//? pointerType – тип указывающего устройства. Должен быть строкой с одним из значений: «mouse», «pen» или «touch»

//? pointerId – уникальный идентификатор указателя, вызвавшего событие. Идентификатор генерируется браузером. Это свойство позволяет обрабатывать несколько указателей, например сенсорный экран со стилусом и мульти-тач
//? pointerId присваивается не на всё устройство, а для каждого касающегося пальца. Если коснуться экрана 5 пальцами одновременно, получим 5 событий pointerdown, каждое со своими координатами и индивидуальным pointerId. События, связанные с первым пальцем, всегда содержат свойство isPrimary=true.

//? width – ширина области соприкосновения указателя (например, пальца) с устройством. Если не поддерживается, например мышью, то всегда равно 1

//? height – высота области соприкосновения указателя с устройством. Если не поддерживается, например мышью, то всегда равно 1

//? pressure – степень давления указателя в диапазоне от 0 до 1. Для устройств, которые не поддерживают давление, принимает значение 0.5 (нажато) либо 0

//? tangentialPressure – нормализованное тангенциальное давление

//? tiltX, tiltY, twist – специфичные для пера свойства, описывающие положение пера относительно сенсорной поверхности





//?================================================================================================================================================
//? Scroll/Прокрутка
// https://learn.javascript.ru/onscroll


//? Прокрутку нельзя отменить вызвал preventDefault, потому что событие скролл появляется только после самой прокрутки, можно отменить либо через overflow hidden, или же отменить только то действие, которое вызывает эту прокрутку, например keydown стрелок










//!================================================================================================================================================
//? Forms/Формы
// https://learn.javascript.ru/form-elements


//? document.forms
//? все формы документа можно получить через document.forms, где каждая форма будет под своим именем(аттрибут name), либо можно получить по индексу


//? elements
//? затем в форме можно получить уже все инпуты через elements, где они будут доступны по имени и также по индексу
//? fieldset так же будет доступен через elements, и также внутри него доступны элементы формы через elements
//? вместо form.elements.login мы можем написать form.login, то есть напрямую по имени обратиться


//? element.form
//? все элементы формы могут сослаться на форму через form, то есть обратные ссылки есть





//? select/option
// https://learn.javascript.ru/form-elements#select-i-option

//? select.options/value/selectedIndex – коллекция из подэлементов <option>, значение выбранного в данный момент <option>, номер выбранного <option>


//? new Option
//? можно создать новый селект таким способом и поместить его на страницу





// https://learn.javascript.ru/focus-blur
//? focus/blur
//? события фокус и блюр можно повесить на элементы, так и вызвать эти методы у элементов
//? эти события не всплывают, но их можно перехватить на фазе погружения


//? focusin/focusout
//? тоже самое что и выше события, но они всплывают





// https://learn.javascript.ru/events-change-input
//? change
//? происходит, при окончании изменении элемента, при потере фокуса, но для элементов select и input типа чекбокс, это событие сработает сразу при выборе значения


//? input
//? каждый раз при изменении значения(при вставке с помощью мыши и голосового ввода)


//? cut/copy/paste
//? относятся к ClipboardEvent классу, их можно отменить через preventDefault и отменить вставку и т.д.





// https://learn.javascript.ru/forms-submit
//? submit
//? форму можно отправить через input/button type="submit", или нажав enter в инпуте, а также вызывав на форме метод submit вручную










//!================================================================================================================================================
//? Page events/события страницы
// https://learn.javascript.ru/onload-ondomcontentloaded


//? у страницы есть 4 жизенных цикла(события), DOMContentLoaded, load, beforeunload, unload


//? DOMContentLoaded
//? страница польностью загружена, но внешние ресурсы типа картинок могут еще подгружаться, то есть только dom и ничего больше
//? когда браузер обрабатывает HTML-документ и встречает тег <script>, он должен выполнить его перед тем, как продолжить строить DOM. Это делается на случай, если скрипт захочет изменить DOM или даже дописать в него (document.write), так что DOMContentLoaded должен подождать
/*
<script>
    document.addEventListener("DOMContentLoaded", () => {
        alert("DOM готов!");   //второй
    });
</script>

<script>
    alert("Библиотека загружена, встроенный скрипт выполнен");   //первый
</script>
*/

//? внешние таблицы стилей не затрагивают DOM, поэтому DOMContentLoaded их не ждёт. Но здесь есть подводный камень. Если после стилей у нас есть скрипт, то этот скрипт должен дождаться, пока загрузятся стили:
/*
<link type="text/css" rel="stylesheet" href="style.css">
<script>
    alert(getComputedStyle(document.body).marginTop);   скрипт не выполняется, пока не загрузятся стили
</script>
*/


//? window.onload
//? событие ждет загрузки абсолютно всего


//? window.onunload
//? когда пользователь уходит со страницы, тут обычно выполняют какие то очень не затратные скрипты, например отправка статистики, отменить выход со страницы мы тут не можем
//? естественно, событие unload – это тот момент, когда пользователь нас покидает и мы хотим сохранить эти данные. для этого существует специальный метод navigator.sendBeacon(url, data), описанный в спецификации https://w3c.github.io/beacon/. Он посылает данные в фоне. Переход к другой странице не задерживается: браузер покидает страницу, но всё равно выполняет sendBeacon.


//? window.onbeforeunload
//? когда пользователь собирается уйти со страницы и закрыть окно, тут можно отменить это событие
/*
window.onbeforeunload = () => {
    return false;
}
*/


//? document.readyState
//? статус документа:       "loading" – документ загружается.       "interactive" – документ был полностью прочитан.        "complete" – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены.


//? readystatechange
//? редко используется, существует для отслеживания статуса загрузки документа





//?================================================================================================================================================
//? onload/onerror
// https://learn.javascript.ru/onload-onerror


//? эти события можно повесить на все ресурсы у которых есть внешний src










//!================================================================================================================================================
//? Scripts/скрипты
// https://learn.javascript.ru/script-async-defer


//? когда браузер строит страницу, и доходит до скрипта, он должен его дождаться, потому что там может быть логика какая то по работе с домом, но скрипт может быть очень большим и может заблокировать страницу, а также такой скрипт не видит страницу ниже себя


//? defer
//? аттрибут говорит браузеру, чтобы скрипт загружался в фоновом режиме вместе с html и запускался после загрузки скрипта(по готовности)
//? скрипты с defer никогда не блокируют страницу. Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.
//? атрибут defer предназначен только для внешних скриптов
//? маленький скрипт загрузится первым, но выполнится вторым. Браузеры сканируют страницу на предмет скриптов и загружают их параллельно в целях увеличения производительности. Поэтому и в примере выше оба скрипта скачиваются параллельно.


//? async
//? скрипт абсолютно независим, он не ждет никого и запускается по готовности сразу, в любой очереди, вообще ему похуй на все


//? динамически созданные скрипты ведут себя также, как и async










//!================================================================================================================================================
//? MutationObserver/Наблюдатель за изменениями
// https://learn.javascript.ru/mutation-observer
// https://developer.mozilla.org/ru/docs/Web/API/MutationObserver


//? служит для наблюдения за изменениями в доме


//? создается экземпляр MutationObserver, куда передается колбэк, а затем в этот observer передается элемент, за которым хотим вести наблюдение, и обьект настроек
/*
let node = document.getElementById('test');
let observer = new MutationObserver((e) => {
    console.log(e);
});
observer.observe(node, {
    subtree: true,
    childList: true,
    characterData: true,
    attributeOldValue: true,
    characterDataOldValue: true,
});
node.textContent = 'added text';
let child = node.append(document.createElement('span'));
node.textContent = 'added text again';
*/


//? объекты mutationObserver используют внутри себя так называемые «слабые ссылки» на узлы, за которыми смотрят. Так что если узел удалён из DOM и больше не достижим, то он будет удалён из памяти вне зависимости от наличия наблюдателя.










//!================================================================================================================================================
//? Selection/Range/Выделение
// https://learn.javascript.ru/selection-range
// https://developer.mozilla.org/ru/docs/Web/API/Range
// https://developer.mozilla.org/ru/docs/Web/API/Selection


//? range
//? range обьект служит для управления диапозонами выделения, мы можем сами устанавливать диапозоны выделения и манипулировать им, в этом обьекте направление только вперед
//? сам по себе такой обьект ничего не делает, мы должны получить обьект selection и добавить range, чтобы он отработал document.getSelection().addRange(range);





//? onselectstart
//? событие срабатывает при начале выделения на элементе


//? onselectionchange
//? когда выделение изменено. этот обработчик можно поставить только на document





//? selection
//? получить этот обьект можно через document.getSelection()

//? в firefox можно добавить несколько выделений, в остальных браузерах только одно выделение имеет место быть





//?================================================================================================================================================
//? выделение в инпутах

//? инпуты сами по себе предоставляют свойства и события для работы с выделением, т.к. там обычный текст и нам не нужно создавать дополнительных каких то обьектов для работы с ним


//? input.selectionStart – позиция начала выделения (это свойство можно изменять)

//? input.selectionEnd – позиция конца выделения (это свойство можно изменять)

//? input.selectionDirection – направление выделения, одно из: «forward» (вперёд), «backward» (назад) или «none» (без направления, если, к примеру, выделено с помощью двойного клика мыши)

//? input.onselect – срабатывает, когда начинается выделение










//!================================================================================================================================================
//? EventLoop/Событийный цикл
// https://learn.javascript.ru/event-loop
// http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D


//? поток выполнения в браузере и node.js основан на событийном цикле


//? если немного упростить принцип работы, то существует всего 3 сущности для работы цикла, call stack, web apis, callback queue
//? принцип работы следующий, возьмем в пример код ниже
/*
$.on('button', 'click', function onClick() {
    setTimeout(function timer() {
        console.log('You clicked the button!');
    }, 9000);
});

console.log("Hi!");

setTimeout(function timeout() {
    console.log("Click the button!");
}, 10000);

console.log("Welcome to loupe.");
*/
//? сначала в callStack выполнится функция получения кнопки, и добавится этот слушатель в web apis, где будет ждать клика по кнопке
//? затем в стэк попадет консоль лог "Hi!" и стэк очистится
//? далее попадет в стэк setTimeout, и таймер добавится в апи браузера, где будет ждать выполнения таймера, стэк очищается
//? далее мы допустим делаем клик по кнопке, этот клик, этот колбэк попадет в очередь, и будет ждать, пока выполнится код ниже
//? выводится консоль лог самый последний "Welcome to loupe.", он попадает в стэк и стэк очищается после выполнения
//? затем из очереди срабатывает колбэка клика по кнопке, он помещается в стэк выполнения, сверху помещается таймаут, затем он идет в апи браузера, и стэк очищается
//? в апи браузера работают сразу 2 таймера, который был запущен с таймером 10секунд и после клика по кнопке, первый сработает после клика, затем второй
//? когда таймер сработает на 9 секунд после клика кнопки, функция коолбэк таймера попадет в очередь, и дальше туда же попадет функция колбэк 10 секундного таймера
//? затем колбэк таймера после клика попадет в стэк, сверху добавится консколь лог "You clicked the button!", стэк очищается
//? и только потом, когда стэк пуст, будет добавлен из очереди второй таймер, который десятисекундный, он также попадет в стэк, сверху будет консоль лог "Click the button!", и стэк очистится

//? в стэк попадают задачи из очереди, только тогда, когда он пуст










//!================================================================================================================================================
//? Открытие окон/методы window/popup
// https://learn.javascript.ru/popup-windows


//? window.open
//? открывает новое окно, третьим аргументом можно передать настройки этого окна, позицию и т.д., метод возвращает ссылку на новое окно, с которым можно взаимодействовать(но это только если у нас один и тот же источник, совпадают домен, протокол и порт)
//? в современных браузерах попапы блокируются, если он был открыт не по желанию пользователя(например, клик)


//? window.opener
//? к открывшему окну можно обратиться через это свойство, оно всегда равно null, кроме попапов


//? window.close
//? закрывает окно, но сейчас делают, что это возможно только, если это попап, т.е. открыто окно было через open


//? iframe
//? тоже самое и с другим окном встроенным в iframe, если у них разный домен и т.д. доступ к нему запрещен, если один и тот же, то мы можем изменять содержимое


//? window.frames
//? доступ ко всем фреймам страницы, можно получить по индексу или по имени


//? window.postMessage
//? позволяет отправить сообщение в другое окно(ограничения такие же)

//? event.message
//? позволяет отлавливать подобные сообщения из других окон, сработает, если метод отправки прошел все хорошо(защиту)










//!================================================================================================================================================
//*ПОТОМ ПРОЧЕСТЬ НА ПОТОМ
//? Blob
// https://learn.javascript.ru/blob


//? 


//? URL.createObjectURL
//? принимает обьект blob или file, и создает ссылку на этот обьект, которую можно потом использовать в src, например картинки
/*
let input = document.getElementById('file');
input.addEventListener('change', function () {
    const file = new Blob([this.files[0]], { type: this.files[0].type });
    const url = URL.createObjectURL(file);
    const img = document.createElement('img');
    img.src = url;
    document.body.append(img);
});
*/


//? URL.revokeObjectURL(url)
//? удаляет внутрненнюю ссылку на обьект, что позволяет его удалить сборщику мусора










//!================================================================================================================================================
//? File/FileReader
// https://learn.javascript.ru/file


//? file это обьект о файле, который доступен нам из инпута, либо при перетаскивании файла, наследуется от blob


//? filereader
//? обьект для преобразования blob и file в разные данные(текст, url, и т.д.), все эти действия такие как readAs<something>, занимают какое то время, поэтоу нужно на них ставить обработчики событий
/*
let input = document.getElementById('file');
input.addEventListener('change', function () {
    const inputFile = this.files[0];
    const reader = new FileReader();
    const img = document.createElement('img');
    reader.readAsDataURL(inputFile);
    reader.onload = function (e) {
        img.src = reader.result;
        document.body.append(img);
    }
});
*/










//!================================================================================================================================================
//? Fetch/Сетевые запросы
// https://learn.javascript.ru/fetch
// https://learn.javascript.ru/fetch-api        ***список настроек второго аргумента
// https://learn.javascript.ru/xmlhttprequest


//? поддерживается в современных браузерах, в страрых может понадобиться полифилл, а также фетч это обертка над старым добрым XMLHttpRequest
//? первым параметром принимает url, вторым всевозможные настройки запроса, возвращает запрос промис, и ответ, кстати, надо тоже обработать и преобразовать в нужный нам вариант(текстовый, json, blob и т.д)
//? также важный момент, что fetch запрос упадет(вернет ошибку) только когда нет интернета или нет такого сайта вообще, в остальных случаях ошибки не будет, поэтому мы можем проверить условием со свойством 'ok' или со 'status'


//? ok
//? свойство возвращает true, если статус в диапозоне 200-299, то это все круто и ответ пришел без ошибок


//? status
//? вернет код статуса запроса(404,500)


//? text, json, formData и т.д
//? методы преобразования ответа в соответствующие данные, все возвращают промис


//? чтобы запушить на сервер что нибудь, нужно передать в обьекте настроек body, и преобразовать его в нужный нам тип, а также установить 'Content-Type' в headers





//?================================================================================================================================================
//? AbortController
// https://developer.mozilla.org/ru/docs/Web/API/AbortController


//? служит для отмены запроса fetch, но плоховато пока что поддерживается
//? мы создаем контроллер и оттуда сигнал передаем в обьект настроек фетч, который будет слушать метод контроллера аборт и при его вызове наш запрос отменится, также можно слушать отмененное действие на сигнале
/*
const controller = new AbortController();
const signal = controller.signal;
signal.addEventListener('abort', (e) => {
    console.log('отменено', e);
});
fetch('https://jsonplaceholder.typicode.com/todos/1', {
    signal
})
    .then(res => {
        if (res.ok) {
            return res.json();
        }
    })
    .then(res => console.log(res))
    .catch(e => console.log(e));

controller.abort();
*/





//?================================================================================================================================================
//? Url
// https://learn.javascript.ru/url
// https://developer.mozilla.org/ru/docs/Web/API/URL/URL


//? конструктор для создания url путей, удобен, потому что внутри себя сразу есть возможность достать протокол, хэш, порт и т.д
//? но пока что не везде поддерживается





//?================================================================================================================================================
//? formdata
// https://learn.javascript.ru/formdata


//? при создании обьекта мы как аргумент передаем форму, чтобы все поля формы сразу считались при создании, мы должны им всем задать аттрибут name, ВАЖНО! в консоли этот обькт почему то всегда пустой, поэтому проверить мы его не сможем)


//? можно добавлять дополнительно свои поля, удалять, получать и т.д.

//? append/set
//? 2 похожих метода, но append добавляет в этот обьект поля по имени, и имя может повторяться, а вот set сначала удалит все свойства с этим именем и потом запишет новое
//? чтобы добавить blob в формдату, нужно передать 3 аргумента, вместо двух, это ключ, сам blob, а также имя файла


//? при отправке на сервер такого обьекта headers тип контента установится автоматически

