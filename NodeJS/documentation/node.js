//? Документация
// https://metanit.com/web/nodejs/2.3.php
// https://nodejs.org/api/globals.html
/*
**
***
****
*****/
//!================================================================================================================================================
//? NodeJs


//? Окружение и рантайм для js на сервере
//? Работает в любом окружении, где есть node(npm). Для запуска необходимо проинициилизировать проект командой npm init

//? Обычно сервер запускает приложение, а у нас приложение запускает сервер



//? Плюс:
//? в том, что она не выделяет на каждый запрос новый новый тред, то есть процессор не загрязняется разными тредами, а все работает в одном потоке, который плюс еще и не блокируется из за eventLoop, а то же выделение процессов и затем получение данных из них крайне трудоемкая задача
//? Минус:
//? что у нас теперь один процесс отвечает за все приложение, если его взломают, или он упадет - упадет все приложение
//? течет память
//? callback hell
//? node_modules со своим непонятным кем то написаным кодом, если есть что то нативное в ноде, лучше использовать что то нативное



//? Node однозначно не подходит для систем реального времени, из за garbage collector(да, его можно отключить через флаг и вызывать вручную), но все равно мы не можем гарантировать сколько времени он займет(для такого используются только условные C/C++, никакие Java/C# не справятся с этим тоже), в остальном на Node - можно писать все



//? Главный смысл написания кода в ноде - асинхронность, желательно использовать по максимому все методы из библиотек асинхронные, например node:/fs/promises



//? Нода работает под капотом с кодом написанным и на C/C++, и на js
/*
**
***
****
*****/
//? /Составляющие/
//?     V8Engine - движок для запуска js
//?     Libuv - eventLoop, threadpool, async i/o
//?     C/C++ addons
//?     nodeJs api
//?     standartLibrary (модули Events, FileSystem и тд)
//?     nodeJs C/C++ которые можно вызвать через js
//?     http parser
//?     opend SSl
//?     zlib - встроенный модуль, который предоставляет инструменты для сжатия и распаковки данных, используя популярные алгоритмы сжатия, такие как gzip, deflate, brotli и другие
/*
**
***
****
*****/
//?================================================================================================================================================
//? Nodemon
// https://www.npmjs.com/package/nodemon
// npm install --save-dev nodemon
//? Пакет для перезапуска приложения при обнаружении изменений

//? для запуска в package.json нужно добавить скрипт, который будет запускать приложение, например "dev": "nodemon scripts/script.js"
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Modules/Модули/

//? Модули в js являются самовызвающейся функцией, которая принимает импортируемые файлы и экспортирует сущности
//? При импортировании, модуль отработает только один раз, при повторных импортах заново функциона модуля не будет вызван


//? CommonJs/EsModules
//? Модули для браузера работают только с import, require не будет работать, это только возможность ноды, но если мы используем бандлеры типа вебпака, то он сам под капотом будет пересобирать наш проект и заменять require на import везде по коду
//? В модули commonjs можно в module.exports присваивать абсолютно любые сущности
//? Также в commonjs можно использовать функцию import динамическую, это возможно делать не только в браузере

//? Они отличаются следующим:
//? 1) require можно делать в любом месте файла, даже в условиях/import только на верхнем уровне
//? 2) require загружает весь модуль целиком, даже если нужны определенные сущности/выборочная загрузка, весь модуль не тянется
//? 3) require не имеет асинхронности/import можно делать асинхронно, динамический импорт
//? 4) require импортируемые сущности являются константами, напрямую их изменять нельзя. Выдается ошибка


//? Чтобы в node использовать es модули:
//? 1) .mjs расширение можно использовать
//? 2) в package.json указать type: module
/*
**
***
****
*****/
//!=============================================================================
//? /EventLoop/
//? реализуется библиотекой libuv
//? внутри нода по дефолту работает с 4 потоками, которые можно увеличить при желании



//? nextTick
//? регистрация колбэка, он будет вызван в конце текущего тика с наивысшим приоритетом выполняется
//? тик - это когда стэк освободился от какой то операции. будь то микро/макро/таски и тд



//?     Инициализация
//? когда запускается приложение, Node.js инициализирует его, загружает модули и устанавливает необходимые обработчики событий.
//?     nextTick
//?     microtasks
//?     Timers
//?     nextTick
//?     microtasks
//?     I/O Callbacks
//? здесь выполняются колбэки, связанные с операциями ввода/вывода, которые завершились, но не являются таймерами (например, сетевые запросы).
//?     nextTick
//?     microtasks
//?     Idle, Prepare
//? внутренние операции, которые не требуют прямого вмешательства пользователя. Обычно этот этап пропускается.
//?     nextTick
//?     microtasks
//?     Poll
//? в этой фазе Node.js проверяет, есть ли колбэки, ожидающие выполнения. Если есть, они обрабатываются. Если нет, и если есть таймеры, poll приостанавливается до тех пор, пока не истечёт таймер или не произойдёт I/O событие.
//?     nextTick
//?     microtasks
//?     Check
//? в этой фазе выполняются колбэки, запланированные с помощью setImmediate(). Эти колбэки выполняются после завершения poll.
//?     nextTick
//?     microtasks
//?     Close Callbacks
//? обрабатываются колбэки для закрывающихся ресурсов, таких как сокеты или таймеры.
/*
**
***
****
*****/
//!=============================================================================
//? /Worker threads/
//? дополнительные потоки для выполнения дорогостоящих операций, чтобы не блокировать основной цикл
//? не надо создавать для работы с обычными async i/o(filesystem), тк обычный поток справляться с этим будет хорошо
//? треды могут делить память через SharedArrayBuffer
//? можно создавать дочерние треды


//? некоторые api уже работают с тредам, например fileSystem, dns.lookup, pipes, crypto
//?     сначала мы из js дергаем функцию
//?     дергается реализация c++
//?     выделяется тред
//?     как только в треде произошли расчеты отдается обратно в js посредством вызова колбэка который мы зарегестрировали при инициализации



//? по умолчанию их 4, мы можем увеличить их до 1000+
//? почему всего 4? потому что идет основа, что у нас 4х ядерный процессор который сможет параллельно выполнять всего 4 процесса, мы также можем выделить создать больше тредов, но тогда их он будет выполнять последовательно

//? в примере ниже каждые 4 ответа будут примерно одинаковыми, тк по дефолту 4 треда работают параллельно и они выполняют код плюс минус одинаково, а криптография под капотом как раз работает с тредами


//? process.env.UV_THREADPOOL_SIZE = 16 можно изменить для параллельности, если ядер больше чем 4
/*
const crypto = require('crypto')
const start = performance.now();
for (let index = 0; index < 50; index++) {
  crypto.pbkdf2('test', 'salt', 100000, 65, 'sha512', () => {
    console.log(performance.now() - start);
  })
}
75.63875
79.338458
84.276375
87.209916
149.40783299999998
149.5545
158.716791
159.62075
*/



//? При создании указывается путь к файлу, либо data:, либо можно передать строковый скрипт и разрашить eval



//?     isMainThread - запущен ли код в главном потоке
//?     markAsUntransferable - запрещает передавать обьект в тред
//?     parentPort - если это тред, то будет ссылка на создателя
//?     SHARE_ENV - делить ли окружение между тредами
//?     setEnvironmentData/getEnvironmentData - устанавливает общие данные между текущим тредом и всеми тредами созданными из текущего контекста
//?     workerData - копия данных при создании треда
/*
**
***
****
*****/
//!=============================================================================
//? /process/Process/
//? информация по текущему потоку



//?     exit - останавливает приложение
//? в треде останавливает выполнение треда, а не всей программы
/*
**
***
****
*****/
//!================================================================================================================================================	
//? /http/
//? Модуль для создания сервера, просшулки событий и т.д.

/*
const server = http.createServer((req, res) => {
    if (req.method === 'GET') {
        res.statusCode === 200;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.end('Привет');
    }
});

server.listen(3000, '127.0.0.1', () => {
    console.log('listen 3000');
});
*/
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Express/
// https://expressjs.com/ru/guide/routing.html
// npm i express
// npm install @types/express

//? Приложение создается вызовом функции express, к результату которого уже можно применять логику


//? listen
//? метод запуска сервера, который запускает приложение на заданном порту


//? Все пути приложения регистрируются в порядке их написания
//? на каждый запрос на сервер, каждый ответ мы должны завершать, иначе он будет крутиться в бесконечном цикле, либо end, либо отправить что то на клиента


//? get, post
//? методы, по которым мы слушаем запросы на наше приложение
//? первый параметр путь, все остальные - это колбэки обработки, которые принимают request, response, next
//? чтобы устанавливать заголовки ответов и т.д. используются методы response
//? next методы дает разрешение дать выполнится следующему колбэку, без него ответ не будет выполнен


//? all
//? метод, что то по сути типа middleware, который запускается перед основным методом обработки. Например all по пути '/hello', он будет сначала обрабатывать все запросы, а затем через next метод пересылать результат дальше по обработчикам


//? examples
/*
const port = 8000;
const server = express();
server.listen(port, () => console.log('listen'));
server.get('/', (req, res) => {
    res.redirect('/hello', 200);
});
server.get('/hello', (req, res) => {
    res.setHeader('Content-Type', 'text/plain');
    res.setHeader('X-captcha', 'captcha token');
    res.cookie('value', 'value', {});
    res.send('Hello');
    res.end();
});
*/


//? router
//? express.Router(), прослойка для удобного комплектования путей
//? в одном месте создается роутер
/*
export const userRouter = express.Router();
userRouter.post('/login', (req, res) => {
    res.send('login');
});
userRouter.post('/register', (req, res) => {
    res.send('register');
});
*/
//? и в другом он подключается через use
/*
server.use('/users', userRouter);
*/


//? use
//? прослойка запросов, можно использовать для отдельного пути, также можно использовать не только для какого то определенного роута, но и для всего приложения, для этого не нужно никакой путь прописывать

//? также можно использовать для обработки неотловленных ошибок, все колбэки в ноде первым аргументом могут принимать ошибку, которую мы как раз может обработать в хуке в use
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Глобальные обьекты/модули/modules/
// https://medium.com/web-standards/es-modules-cartoon-dive-71f42c1e851a
// https://nodejs.org/api/globals.html      глобальные доступные переменные в global

//? global - глобальный обьект, аналогия window в бразуерном js



//? Модульные переменные(в каждом отдельном модуле имеет свои значения(не синглтон))
//? __dirname - путь до папки проекта
//? __filename - путь до запущенного скрипта
//? module
//? exports
//? require



//? Модули в nodejs используют формат commonjs(module.exports, require)
//? module.exports - для того, чтобы экспортировать функционал из файла
//? require - глобальная функция, которая позволяет получать экспортированный функционал



//? Чтобы использовать какую то функциональность в node, например работу с файловой системой, events, путями файлов, нужно импортировать данный функционал из соответствующих модулей
/*
**
***
****
*****/
//!=============================================================================
//? /path/
// https://nodejs.org/api/path.html

//? Модуль path предоставляет утилиты для работы с путями к файлам и каталогам. Для работы с ним нужно его импортировать.


//? Работа модуля в разных операционных системах может отличаться, например path.basename может привести к разным результатам в windows и posix
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Events/
//? Библиотека ноды предоставляющая eventEmitter и вообще сущности для работы с ивентами
//? с помощью нее можно подписываться, отправлять события, и т.д.



//? Методы модуля
//? getEventListeners по данному ивент эмиттеру берет зарегестрированные колбэки(rawListeners грубо говоря)


//? once преобразует в промис ивент, также можно abortSignal использовать для отмены
// https://nodejs.org/dist/latest-v17.x/docs/api/events.html#awaiting-multiple-events-emitted-on-processnexttick
/*
const ee = new EventEmitter();
await once(ee, 'error')
*/
/*
**
***
****
*****/
//? /EventTarget/
//? тоже самое что и в вебе, только тут нет всплытый событий
/*
**
***
****
*****/
//? /EventEmitter/
//? Класс, отвечающий за обработку событий, в браузере аналогия - EventTarget

//? on, addListener, off, removeListener, removeAllListeners, once, prependListener, prependListenerOnce
//? методы добавления - удаления ивентов
//?     removeAllListeners может принимать ивент, который нужно удалить
//?     once - один раз прослушать и удалить подписку
//?     prependListenerOnce/prependListener - в начало добавить обработчк, потому что они вызываются в порядке добавления
//?     listenerCount - сколько зарегестрировано обработчиков на данный ивент
//?     eventNames
//?     newListener event
//?     removeListener event
//?     getMaxListeners
//?     listeners
//?     off
//?     on
//?     setMaxListeners - по дефолту будет ворнинг если больше 10 слушателей на eventEmitter, infinity/0 говорят что можно любое количество устанавливать, имеет приоритет над setMaxListeners
//?     defaultMaxListeners можно для всего приложения установить event.defaultMaxListeners
//?     rawListeners - по ключу достает зарегестрированные колбэки по ивенту, и можно вызвать эти колбэки напрмямую грубо говоря



//? Чтобы отловить ошибку, нужно подписаться на событие error, связанное с этим ивент эмиттером
//? Чтобы отловить асинхронную ошибку которая была в обработчике, нужно создать с captureRejections
/*
const ee = new EventEmitter({captureRejections: true}); //если не будет параметра, то ошибку которая в обработчике test возникнет, error событие не отловит

ee.on('error', e => console.log('error', e))
ee.on('test', async () => throw new Error())
ee.emit('test');


? либо глобально для всего приложения
const events = require('events');
events.captureRejections = true;
*/
/*
**
***
****
*****/
//!=============================================================================
//? /Childprocess/Child_process/
//? можно создавать дочерние процессы, например запустить какой то файл, тот же самый bash



//?     exec - запустить команду создает терминал новый
//?     execFile - запустить файл, но не создается терминал, а значит ввод вывод нельзя делать
/*
**
***
****
*****/
//!================================================================================================================================================
//? /perfomance/
//? глобальный обьект, который содержит данные о работе приложения. Время начала работы и т.д.
/*
**
***
****
*****/
//!=============================================================================
//? /Security/Безопасность/
//? не создавать на каждый запрос worker thread, тк легко задудосят сайт