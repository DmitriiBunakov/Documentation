//? Документация
// https://metanit.com/web/nodejs/2.3.php
// https://nodejs.org/api/globals.html



//!================================================================================================================================================
//? NodeJs

//? Работает в любом окружении, где есть node(npm). Для запуска необходимо проинициилизировать проект командой npm init
//? Если проект скачали с хранилища, нужно его проинициализировать npm install или npm i


//? При отправке данных с клиента на сервер, все данные отправляются маленькими данными для оптимизации, они разбиваются на buffer'ы, чанки(chunks)















//!================================================================================================================================================
//? /Modules/Модули/

//? Модули в js являются самовызвающейся функцией, которая принимает импортируемые файлы и экспортирует сущности
//? При импортировании, модуль отработает только один раз, при повторных импортах заново функциона модуля не будет вызван


//? CommonJs/EsModules
//? Модули для браузера работают только с import, require не будет работать, это только возможность ноды, но если мы используем бандлеры типа вебпака, то он сам под капотом будет пересобирать наш проект и заменять require на import везде по коду
//? В модули commonjs можно в module.exports присваивать абсолютно любые сущности
//? Также в commonjs можно использовать функцию import динамическую, это возможно делать не только в браузере

//? Они отличаются следующим:
//? 1) require можно делать в любом месте файла, даже в условиях/import только на верхнем уровне
//? 2) require загружает весь модуль целиком, даже если нужны определенные сущности/выборочная загрузка, весь модуль не тянется
//? 3) require не имеет асинхронности/import можно делать асинхронно, динамический импорт
//? 4) require импортируемые сущности являются константами, напрямую их изменять нельзя. Выдается ошибка


//? Чтобы в node использовать es модули:
//? 1) .mjs расширение можно использовать
//? 2) в package.json указать type: module





//?================================================================================================================================================
//? Nodemon
// https://www.npmjs.com/package/nodemon
// npm install --save-dev nodemon
//? Пакет для перезапуска приложения при обнаружении изменений

//? для запуска в package.json нужно добавить скрипт, который будет запускать приложение, например "dev": "nodemon scripts/script.js"









//!================================================================================================================================================	
//? /http/
//? Модуль для создания сервера, просшулки событий и т.д.

/*
const server = http.createServer((req, res) => {
    if (req.method === 'GET') {
        res.statusCode === 200;
        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.end('Привет');
    }
});

server.listen(3000, '127.0.0.1', () => {
    console.log('listen 3000');
});
*/










//!================================================================================================================================================
//? /Express/
// https://expressjs.com/ru/guide/routing.html
// npm i express
// npm install @types/express

//? Приложение создается вызовом функции express, к результату которого уже можно применять логику


//? listen
//? метод запуска сервера, который запускает приложение на заданном порту


//? Все пути приложения регистрируются в порядке их написания
//? на каждый запрос на сервер, каждый ответ мы должны завершать, иначе он будет крутиться в бесконечном цикле, либо end, либо отправить что то на клиента


//? get, post
//? методы, по которым мы слушаем запросы на наше приложение
//? первый параметр путь, все остальные - это колбэки обработки, которые принимают request, response, next
//? чтобы устанавливать заголовки ответов и т.д. используются методы response
//? next методы дает разрешение дать выполнится следующему колбэку, без него ответ не будет выполнен


//? all
//? метод, что то по сути типа middleware, который запускается перед основным методом обработки. Например all по пути '/hello', он будет сначала обрабатывать все запросы, а затем через next метод пересылать результат дальше по обработчикам


//? examples
/*
const port = 8000;
const server = express();
server.listen(port, () => console.log('listen'));
server.get('/', (req, res) => {
    res.redirect('/hello', 200);
});
server.get('/hello', (req, res) => {
    res.setHeader('Content-Type', 'text/plain');
    res.setHeader('X-captcha', 'captcha token');
    res.cookie('value', 'value', {});
    res.send('Hello');
    res.end();
});
*/


//? router
//? express.Router(), прослойка для удобного комплектования путей
//? в одном месте создается роутер
/*
export const userRouter = express.Router();
userRouter.post('/login', (req, res) => {
    res.send('login');
});
userRouter.post('/register', (req, res) => {
    res.send('register');
});
*/
//? и в другом он подключается через use
/*
server.use('/users', userRouter);
*/


//? use
//? прослойка запросов, можно использовать для отдельного пути, также можно использовать не только для какого то определенного роута, но и для всего приложения, для этого не нужно никакой путь прописывать

//? также можно использовать для обработки неотловленных ошибок, все колбэки в ноде первым аргументом могут принимать ошибку, которую мы как раз может обработать в хуке в use










//!================================================================================================================================================
//? /Глобальные обьекты/модули/modules/
// https://medium.com/web-standards/es-modules-cartoon-dive-71f42c1e851a
// https://nodejs.org/api/globals.html      глобальные доступные переменные в global

//? global - глобальный обьект, аналогия window в бразуерном js


//? __dirname - путь до папки проекта
//? __filename - путь до запущенного скрипта


//? Модули в nodejs используют формат commonjs(module.exports, require)
//? module.exports - для того, чтобы экспортировать функционал из файла
//? require - глобальная функция, которая позволяет получать экспортированный функционал


//? Чтобы использовать какую то функциональность в node, например работу с файловой системой, events, путями файлов, нужно импортировать данный функционал из соответствующих модулей




//?================================================================================================================================================
//? path
// https://nodejs.org/api/path.html

//? Модуль path предоставляет утилиты для работы с путями к файлам и каталогам. Для работы с ним нужно его импортировать.


//? Работа модуля в разных операционных системах может отличаться, например path.basename может привести к разным результатам в windows и posix






//!================================================================================================================================================
//? Events
//? Библиотека ноды предоставляющая eventEmitter и вообще сущности для работы с ивентами
//? с помощью нее можно подписываться, отправлять события, и т.д.



//? EventEmitter
//? Класс, отвечающий за обработку событий, в браузере аналогия - EventTarget

//? on, addListener, off, removeListener, removeAllListeners, once, prependListener, prependListenerOnce
//? методы добавления - удаления ивентов
//?     removeAllListeners может принимать ивент, который нужно удалить
//?     once - один раз прослушать и удалить подписку
//?     prependListenerOnce/prependListener - в начало добавить обработчк, потому что они вызываются в порядке добавления

//?     listenerCount - сколько зарегестрировано обработчиков на данный ивент


//? Чтобы отловить ошибку, нужно подписаться на событие error, связанное с этим ивент эмиттером










//!================================================================================================================================================
//? /perfomance/
//? глобальный обьект, который содержит данные о работе приложения. Время начала работы и т.д.










//!================================================================================================================================================
//? /WorkerThread/worker_threads
//? Воркер, в который можно вынести логику ресурсоемкую, которая будет высчитываться в паралелльном потоке

//? Для работы нужно создать файл воркера, который будет запущен, когда нам нужно будет просчитывать что то, создается через класс Worker из библиотеки, куда прокинуть значения можно и повесить прослушку событий, когда воркер отработал успешно










