//? RxJs
//? По своей сути поток синхронный, если подписываемся на состояние - сразу будет уведомление о состоянии
//!=============================================================================
//? Store
//? Хранилище данных
/*
**
***
****
*****/
//!=============================================================================
//? /Actions/
//? Создаются через createAction - и возвращают функцию, которую потом нужно вызывать и которая вернет action для reducer'a
//!=============================================================================
/*
**
***
****
*****/
//? /Reducer/
// https://ngrx.io/guide/store/reducers
//? Чистая функция, которая обновляет стэйт. На вход принимает стэйт и возвращает новое состояние, необходимо "развернуть" каждый уровень вложенности обьекта состояния. Ни в коем случае нельзя мутировать состояние, всегда нужно создавать новый обьект/новый стэйт
//? Все стэйты которые отдельно провайдятся в приложение - из изменения не зависят друг от друга, то есть при изменении одного, другой не будет вызван, но вот actions будут обрабатываться одним и тем же store'ом, поэтому тут нужно давать уникальные имена событиям
//!=============================================================================
//? /Metareducer/
//? Reducer - которые запускаются перед обычными редюсерами, то есть это middleware, в котором можно как то обработать данные, принимает state/action, какие то преобразования и тд можно сделать
/*
**
***
****
*****/
//!=============================================================================
//? /Selectors/
// https://ngrx.io/guide/store/selectors
//? функции, которые "достают" значение из стейта, вызывается данная фукнция, когда изменяется стейт от которого она зависит. Также могут быть другие селекторы от которых будет зависеть данная функция, при изменении которых - селектор будет заново вызываться и доставать данные. Если значение после выполнения не поменялось - то подписчики уведомлены не будут, а так же не будут вызваны другие селекторы которые зависят от нашего
/*
**
***
****
*****/
//!=============================================================================
//? /API/
//? provideStore() - store для приложения
//? provideState() - state для приложения
//? StoreModule.forRoot({ game: scoreboardReducer }) - store и state для приложения
//? createFeatureSelector - вытащить по имени из глобального обьекта featureReducer
//? createAction/createActionGroup - создать экшн или группу экшнов - props/emptyProps пропсы для экшна
//? createFeature - создать feature-редюсер
//? StoreModule.forFeature - можно использовать для глобальной регистрации(можно использовать state'ы созданные через createFeature), а также регистрировать можно lazyLoad части stor'a, будут добавлены через store.addReducer
//!=============================================================================
//? /Checks/
// https://ngrx.io/guide/store/configuration/runtime-checks
/*
**
***
****
*****/
//!=============================================================================
//? /Effects/
// https://ngrx.io/guide/effects
//? Эффекты отделяют логику запросов, обработку и лишние действия от компонентов в сервисы (эффекты), а компонент лишь берет то, что нужно и использует, а также диспатчит экшены, то есть просто указания делает
//? эффекты фильтруют из всех действие свое - и обрабатывают его

//? EffectsModule.forRoot/forFeature/provideEffects/USER_PROVIDED_EFFECTS - корневая и регистрация для лэзи модулей
//? createEffect - создает эффект - его нужно объявить в модуле effectModule - на этот эффект нельзя подписываться - должен это делать только store - тк лишние вызовы будут обработки этого эффекта, сколько подписок - столько и обработок


//? Все экшены проходят через store и распределяются по эффектам, то есть это все так же централизованное


//? ofType - отфильтровать экшены из потока actions$
//? concatLatestFrom - если нужно использовать последнее состояние store и можем вытащить оттуда данные - объеденить последние значения


//? EffectConfig
//? при создании эфекта можно указать, будет ли отправлен экшн в store/можно ли создать эффект вне класса, как обычную фукнцию/переподписаться ли на ивент, если упадет он с ошибкой