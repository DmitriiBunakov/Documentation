//!=============================================================================
//? /O/Log/
//? BigO показывает верхнюю границу динамики изменения вычислительной сложности алгоритма в зависимости от размера входных данных
//? то есть сколько операций будет выполнено для алгоритма, а не, например, фактическая скорость в мс, тк компы разные и скорость будет отличаться



//?=============================================================================
//? Метрики по скорости
//? O(1)
//? константое время выполнения, неважно, сколько команд будет выполнено - важно что данная операция всегда занимает константное время
//? O(1+1+1) = O(3) = O(1)


//? O(log)
//? логарифмические оценки применимы например в бинарном поиске отсортированного массива, когда поиск происходит за log n
//? например массив из 8 элементов, то есть фактических операций будет 3, log 8 будет иметь основание 3


//? O(n)
//? линейная сложность
//? n - количество элементов, и чем больше n, тем больше времени протребуется для операции
//? то есть циклов для массива - будет n, и если там простые действия, например сложение и тд, сложность цикла не возрастает - всегда линейна, а вот если цикл внутри цикла...


//? O(n+m+...)
//? например когда перебираются подряд 2 и более разных списков один за другим


//? O(n*m)
//? цикл в цикле, 2 разных списка, и на каждое действие в родительском цикле - вызывается цикл для всего списка m
//? то есть сложность получается n*m


//? O(n2)
//? цикл в цикле, когда перебирается один и тот же список на каждую итерацию


//? O(n!)
//? факториальная сложность, когда нам нужно перебрать все возможные комбинации решения задачи, например мазайка - в ней есть 4 пазла - значит количество решений будет 4! = 24 цикла в худшем случае
//? на практике если решение такое, то лучше отбросить точность и сделать решение максимально приближенное к правде


//? Неважные оценки
//? например у нас цикл в цикле, и после этого еще один цикл, мы можем расписать это как O(n*n + n), но +n тут опускается, тк оно становится как бы неважным для оценки общей сложности алгоритма, то есть в итоге мы получаем O(n2)
//? неважными слагаемыми считают те, которые выполняются как минимум в 2 раза быстрей других слагаемых
//? n -> Infinity, то n2 > n явно больше и тогда просто n просто меркнет по сложности в сравнении с n2



//?=============================================================================
//? LogA B
//? логарифм B по основанию A
//? Во сколько раз(A) нужно возвести какое то число, чтобы получить число B
/*
**
***
****
*****/
//!=============================================================================
//? /Структура данных/
//? Структура данных — это способ организации информации для более эффективного использования. В программировании структурой обычно называют набор данных, связанных определённым образом. Например, массив — это структура.

//? Главное свойство структруры - что у каждого элемента есть свое четкое место, по которому можно найти этот элемент

//? Для каждой свои алогитмы работы, в массив добавляются по своему, в связанный список по своему
/*
**
***
****
*****/
//!=============================================================================
//? /Array/
// https://medium.com/@rodriguezlf4/static-vs-dynamic-arrays-javascript-beauty-f226e153cbc9
//? Похоже на таблицу, где у каждого элемента есть индекс и элемент хранящийся по данному индексу, то есть доступ к элементу является константой, и не меняется от количества элементов в нем



//? Бывают одномерные и двумерные и тд



//?=============================================================================
//? У массива есть currentLength - текущая длина, и maxCapacity - максимальный размер
//? Массив по своей сути в js - это обьект и у него есть просто свойство length, которое равно индексу посленего элемента + 1
/**
let arr = [];
arr[999] = 'test';
arr.length === 1000;
то есть в массиве будет 999 пустых элементов перед 'test';
*/



//?=============================================================================
//? Основное применение:
//? упорядоченное хранение элементов
//? хранение неопределенного количества элементов
//? быстро применять однотипные действия к каждому элементу
//? быстрый доступ к элементу



//?=============================================================================
//? Недостатки
//? Увелечение массива в 2 раза при его заполнении и копирование всех данных в новый массив



//?=============================================================================
// https://medium.com/@satorusasozaki/amortized-time-in-the-time-complexity-of-an-algorithm-6dd9a5d38045
//? Массивы бывают статическими и динамическими
//? /Статический vs динамический/Amortized/Аммортизация/

//? массив - это непрерывная область памяти, это значит не может быть в индексе 0 элемента и сразу в 1000 индексе тоже, между ними так же будет выделена память под элементы



//?=============================================================================
//? Операции


//? Добавление
//? добавление элемента в статический массив быстрее, чем в динамический, тк размер известен заранее
//? Сложность O(1) - тк добавляем всего 1 элемент в конец

//? добавлении в динамический массив при его заполнении происходит выделение памяти в 2 раза больше чем он сейчас уже заполнен, а также при этом происходит копирование всех значений в новый массив.
//? Почему удваивается массив, а не добавляется всего 1 значение - потому что вероятно если ты добавил 1 - возможно добавишь и второе третье и тд
//? Сложность O(n) - n - количество элементов. Тк нужно заново создать будет массив при преувелечении текущего максимального размера

//? почему желательно работать с элементами в конце
//? потому что при добавлении элемента не в конец - нужно будет сдвинуть ВСЕ элементы справа от вставки на 1
//? Сложность O(n)



//? Удаление
//? В конце - просто удаляем элемент и length уменьшаем
//? В середине - удаляем и все элементы влево сдвигаем
/*
**
***
****
*****/
//!=============================================================================
//? /LinkedList/Связанный список/
//? Структрура в которой каждый элемент ссылается на следующий(One-way), а иногда и на предыдущий элемент(Two-way)
//? Всегда в списке есть ссылки на head - первый элемент и tail - последний
//? Есть элементы и у них есть: next/previous - ссылки на элементы смежные, data - значение элемента



//?=============================================================================
//? Операции
//? Добавление
//? в конец мы просто создаем новый элемент списка, ему в next добавляем ссылку на tail, в tail присваиваем новый элемент
//? O(1)

//? в начало все то же самое, только работа с head
//? O(1)

//? В середину - находим элемент слева и справа, затем создаем новый, слева.next = новый, новый.next = правый
//? O(n) - худший случай. O(1) - если у нас уже есть ссылка на какой то элемент после которого нам нужно добавить



//? Чтение
//? O(n) - тк нам нужно в худшем случае пройти от начала до конца через все элементы



//? Удаление
//? В начале - просто указатель head меняем на head.next и node(сам элемент) = null
//? O(1)

//? В середине, если уже есть ссылка на элемент, после которого будет удаление - то просто left.next = removed.next, node = null
//? O(1)
//? Если нет ссылки то O(n) - тк пройти нужно будет весь список

//? В конце - O(n) - тк нужно пройти весь список



//?=============================================================================
//? Применение
//? Последовательные связанные данные, например: DOM, file system.
//? когда больше добавления/удаления, чем чтения, тк добавление быстро



//? LinkedList vs Array
//? более быстрая вставка в начало/середину в linkedList
//? более медленный доступ к рандомному элементу в linkedList
//? поиск одинаков O(n)
//? память больше кушает, тк хранит еще и указатели на next/previous элементы, в массиве же просто обьекты хранятся
/*
**
***
****
*****/
//!=============================================================================
//? /Queue/Очередь/
//? Структура данных работает по принципу FIFO - First in first out - или LIFO - last in first out
//? Реализованы с помощью Two-way-LinkedList или Array в основном, тк очень быстро с их помощью можно манипулировать данными в начале и в конце, тк у нас есть ссылки на них



//?=============================================================================
//? Операции
//? Тк это связанный список по своей сути, то

//? Добавление слева и справа - O(1)
//? в середину - O(n)


//? Удаление слева и справа - O(1)
//? в середине - O(n)


//? Чтение можно, тк это тот же список связанный



//?=============================================================================
//? Применение
//? Очередь колбэков в eventloop - FIFO
//? Stack - LIFO - стэк вызовов
/*
**
***
****
*****/
//!=============================================================================
//? /Stack/Стэк/Стек/
//? Структура(очередь по своей сути) работающая по принципу LIFO - last in first out



//?=============================================================================
//? Операции ТОЛЬКО для элемента сверху, по сути та же очередь, но функционал сильно ограничен
//? Удаление
//? Добавление
//? Чтение
//? Узнать размер



//?=============================================================================
//? Применение

//? История браузера

//? Реализация рекурсии - каждый новый вызов помещается сверху, чтобы программа знала, в каком порядке завершать функции потом

//? Анализ данных с помощью стека
//? например, 78 * (23 - 7 * (1 - 4)) + (95 / 5) и требуется выделить все фрагменты в скобках
//? идем и в стек заносим открывающиеся скобки, как только встречаем закрывающую - достаем из стэка последний элемент и читаем данные между индексом последнего элемента и последнего из стэка - это и будет (данные)
/*
**
***
****
*****/
//!=============================================================================
//? /Binary tree/Бинарное дерево/
//? Используются везде, где есть древовидная связь в виде родитель - потомки


//? Бывают сбалансированными и нет
//? Сбалансированные деревья - это когда слева и справа ветви от вершины отличаются не более, чем на 1 уровень и тогда работа с этим деревом будет со скоростью O(lon n)

//? не сбалансированные, когда в одной ветви сильно больше вложенность, тогда вычистительная скорость O(n) - тк это уже больше похоже на связанный список



//?=============================================================================
//? Структура
//? data
//? left - потомок слева
//? right - потомок справа
//? parent - иногда ссылку на родителя добавляют



//?=============================================================================
//? Использование
//? Везде, где есть связь родитель - дочерние элементы

//? более быстрый поиск при заранее правильной составленной структуре(бинарный)
//? например из задачи ниже, нам нужно найти например число 2, значит при поиске мы проверим, число 2 меньше 10, значит правую часть отсекаем сразу и идем дальше сравнивать, то есть мы сокращаем в 2 раза поиск
//? O(log2 n) - потому что поиск сокращается в квадратный корень от числа N элементов(но это только для сбалансированного дерева)



//?=============================================================================
//? Операции



//?=============================================================================
//? пример задачи, где меньшие числа - влево, большие - вправо
//? 10 - корень
//? 5 меньше 10 ? значит влево
//? 7 меньше 10 ? влево
//? 7 больше 5 ? значит вправо и тд
/*
class TreeNode {
    data
    left
    right
}

const tree = new TreeNode();
const arr = [10, 5, 7, 16, 13, 2, 20];

arr.forEach(item => addToTree(tree, item));

function addToTree(treeNode, number) {
    if (treeNode.data == null) {
        treeNode.data = number;
        return
    }

    addToRightOrLeft(treeNode, number);
}

function addToRightOrLeft(treeNode, number) {
    if (number < treeNode.data) {
        treeNode.left ??= new TreeNode();
        addToTree(treeNode.left, number);
        return;
    }

    treeNode.right ??= new TreeNode();
    addToTree(treeNode.right, number);
}

console.log(tree);
*/


//?=============================================================================
//? Обход в ширину, значит мы идем сначала по узлам на одном уровне сверху вниз
/*
тут нужно использовать tree из кода выше

function goWidth(treeNode) {
    let roots = [treeNode];

    while (roots.length) {
        const arr = [];

        for (const node of roots) {
            console.log(node);

            if (node.left) {
                arr.push(node.left);
            }

            if (node.right) {
                arr.push(node.right);
            }
        }

        roots = arr;
    }
}

function goWidth(treeNode) {
    for (let arr = [treeNode]; arr.length;) {
        const newArr = [];

        for (const node of arr) {
            console.log(node);
            if (node.left) {
                newArr.push(node.left);
            }

            if (node.right) {
                newArr.push(node.right);
            }
        }

        arr = newArr;
    }
}
*/


//?=============================================================================
//? Обход в глубину
//? выбираем сначала левую или правую ветвь будем проходить, и затем рекурсивно вызываем функцию
/*
function goDepth(treeNode) {
    if(!treeNode) {
        return
    }

    if(treeNode.left) {
        goDepth(treeNode.left);
    }

    console.log(treeNode);

    if(treeNode.right) {
        goDepth(treeNode.right);
    }
}
*/
/*
**
***
****
*****/
//!=============================================================================
//? /PrefixTree/Trie/
//? префиксное дерево хранит себе префикс во главе ветви


//?=============================================================================
//? Использование
//? для хранения данных при автозаполнении, тот де T9
//? список IP адресов
/*
**
***
****
*****/
//!=============================================================================
//? /Set/Множества/
//? Хранят уникальный набор данных
//? основаны на бинарном дереве
/*
**
***
****
*****/
//!=============================================================================
//? /Map/Карта/Ассоциативный массив/Хэш таблица/
//? Ключи уникальны и по ключам хранятся данные



//? под капотом тот же массив
//? приходит ключ -> хэшируется -> устанавливается в массив
//? если массив почти заполнен увеличиваем в 2 раза и все ключи существующие прогоняем заново через хэш фукнцию
//? сравнение скорости и доказательство, что обьект медленнее массива
/*
const count = 1_000_000_0;

const staticArray = new Array(count);
console.time(1)
for (let index = 0; index < count; index++) {
    staticArray[index] = index;
}
console.timeEnd(1)

console.time(2)
const dynamicArray = [];
for (let index = 0; index < count; index++) {
    dynamicArray[index] = index;
}
console.timeEnd(2)

const object = {};
console.time(3)
for (let index = 0; index < count; index++) {
    object[index] = index;
}
console.timeEnd(3)

const map = new Map();
console.time(4)
for (let index = 0; index < count; index++) {
    map.set(index, index);
}
console.timeEnd(4)
*/



//?=============================================================================
//? нужны, когда есть ключи(не индексы как в массиве), а именно ключи



//?=============================================================================
//? Хэш-фукнция
//? берет ключ и хэширует его и по данному получившемуся ключу хранится значение



//?=============================================================================
//? Коллизия
//? когда для разных ключей - получается один и тот же индекс после хэширование
/*
**
***
****
*****/
//!=============================================================================
//? /Graph/Граф/
//? Граф - это структура
/*
**
***
****
*****/
//!=============================================================================
//? Fibonachi
/*
function fibonachi(number) {
    let previous = 0;
    let current = 1;

    for (let index = 3; index <= number; index++) {
        const next = previous + current;
        previous = current;
        current = next;
    }

    return current;
}
*/
/*
**
***
****
*****/
//!=============================================================================
//? /Sorting/



//?=============================================================================
//? Buble/пузырьком
//? проходим каждый элемент и сравниваем с предыдущим и меняем местами
//? O(n2)



//?=============================================================================
//? Выбором
//? ищем наименьший элемент и помещаем на первое место, затем следующий наименьший на второе и тд
//? O(n2) - но быстрее пузырьковой, тк меньше перестановок
/*
const selectionSort = (items) => {
  for (let i = 0; i < items.length - 1; i += 1) {
    let indexMin = i;
    for (let j = i + 1; j < items.length; j += 1) {
      if (items[j] < items[indexMin]) {
        indexMin = j;
      }
    }

    const temporary = items[i];
    items[i] = items[indexMin];
    items[indexMin] = temporary;
  }
};
*/



//?=============================================================================
//? Сортировка подсчетом
//? нужно узнать сколько раз встречается то или иное число, записываем эти данные куда то, обьект или массив и затем заполнить новый массив этими данными, то есть если число 1 встретилось 4 раза - то вначале нового массива будет 4 единицы
/*
let arr = [10,10,]
*/



//?=============================================================================
//? Слиянием
//? разбиваем массив на пополам, пока в каждом массиве не будет по 2 элемента, затем сортируем каждый полученный массив и затем соединяем их вместе
//? O(n log n)
/*
// слияние массивов с одновременной сортировкой
// на вход подаются уже отсортированные левая и правая части 
function merge(left, right) {
    // сюда будем складывать результат
    let arr = []
    // пока в каждой части есть хотя бы один элемент — выполняем цикл
    while (left.length && right.length) {
        // смотрим на наименьший элемент из тех, что стоят в начале обоих массивов
        if (left[0] < right[0]) {
            // если слева был элемент меньше —
            // забираем его оттуда и отправляем в массив с результатом
            arr.push(left.shift())  
        } else {
            // в противном случае забираем элемент из правой части
            arr.push(right.shift()) 
        }
    }
    // выводим результат слияния отсортированных массивов
    console.log('Результат: ' + arr);

    // возвращаем отсортированный массив и добавляем к нему в конец отсортированный остаток от какой-либо части, если её так и не обработали в цикле
    return [ ...arr, ...left, ...right ]
}

// делим массивы пополам до тех пор, пока в них не останется элементов
function mergeSort(array) {
  // находим середину 
  const half = array.length / 2
  
  // если в нашем массиве и так меньше двух элементов — возвращаем его
  if(array.length < 2){
    return array 
  }
  
  // делим массив на две части и левую отправляем в новый массив
  const left = array.splice(0, half)
  // выводим промежуточный результат
  console.log('Слева:' + left);
  console.log('Справа:' + array);
  // запускаем рекурсию и отдаём ей правую и левую части массива
  return merge(mergeSort(left),mergeSort(array))
}

// исходный массив
array = [3, 5, 1, 6, 9, 8, 2];
console.log(mergeSort(array));
*/