//!================================================================================================================================================
//? /CLI/
//? nest new <name>
//? nest g [controller | module | class] <name>










//!================================================================================================================================================
//? Все приложение создается через функцию, где мы создаем приложение, указываем порт
/*
async function bootstrap() {
    const app = await NestFactory.create(AppModule);
    app.setGlobalPrefix('api');
    await app.listen(8000);
}
bootstrap();
*/

//? setGlobalPrefix
//? указывает префикс глобальный, который будет добавлен ко всему пути









//!================================================================================================================================================
//? /Modules/
//? Также как и в angular все приложение делится на модули, объявляются через Module, где также можно прописать импорты, объявления, провайдеры и экспорты

//? Очень похожи на angular модули, также нужно импортировать другие модули, чтобы получить функционал, по дефолту все модули инкапсулированы в этом модуле без экспорта их


//? ModuleRef
//? в сущности можно инжектировать ссылку на модуль, откуда доставать можно значения


//? /@Global/
//? делает всех провайдеров модуля глобальными





//?================================================================================================================================================
//? /ConfigModule/
// npm i @nestjs/config
//? модуль для работы с файлами .env в nest










//!================================================================================================================================================
//? /Controllers/
//? Входная точка в приложение, они обрабатывают запросы входящие, отправляет ответы обратно на клиент

//? по сути это класс, декорированный Controller, куда указываем путь по которому будет вызван наш контроллер





//? методы внутри него декорируются соответствующим именем запроса, get декоратором @Get и т.д., т.е. каждый метод будет вызван при соответствующем запросе
//? nest сам создаст обработчик по данному пути для запроса
//? по дефоту всегда возвращается 200 ответ, на пост вернется 201
//? из функций можно возвращать промисы, observable, nest сам за нас дождется их выполнения


//? /@Get/


//? /@Post/


//? /@HttpCode/
//? Изменяет статус ответа


//? /@Redirect/
//? редирект на другой эндпойнт





//? В каждую функцию можно внедрить через декораторы аргументы, ответ, запрос, тело запроса и т.д, nest все сделает за нас. Это нужно, чтобы как-то модифицировать запросы


//? /@Res/
//? внедрит ответ, все его параметры и т.д
//? по дефолту, из за того, что мы используем express, тип ответ будет тоже Response из Express
//? тут мы может сами устанавливать статус ответа, заголовки и т.д. НО!, если мы как-то модифицируем ответ, то нам нужно прописать обьект настроек для ответа, чтобы он корректно работал, иначе nest будет думать, что мы сами будет все обрабатывать
/*
@Get()
    @HttpCode(200)
    public async login(
        @Res() response: Response,      //если ничего не передать, ответ будет падать
    ): Promise<unknown> {
        response.setHeader('test', 'test');
        response.statusCode = 201;
        response.send('hi');
        response.end();
    }
*/


//? /@Req/
//? запрос, и все его данные, параметры и т.д.


//? /@Param/
//? парамерты запроса


//? /@Body/
//? если мы хотим получить тело запроса, нужно создать DTO(Data Transfer Object), по сути это будет типизация запроса, но рекомендуют использовать класс из за Pipes


//? /@Query/
//? query параметры


//? /@Headers/
//? заголовки запроса










//!================================================================================================================================================
//? /Providers/Провайдеры/
// https://docs.nestjs.com/fundamentals/custom-providers
// https://docs.nestjs.com/fundamentals/circular-dependency
//? Сервис, который делает какую то логику, обращается к базе данных, и т.д.

//? сервисы нужно объявлять в модуле в providers
//? все сервисы очень похожи на братьев в Anguler


//? Injectable
//? по дефолту сервис является singleton, либо можно указать конкретно скоуп
/*
scope: Scope.Default
*/

//? на каждый входящий запрос новый экземпляр
/*
Scope.Request
*/

//? каждый кто инжектит сервис, будет иметь новый экземпляр
/*
Scope.Transient
*/



//? Можно делать асинхронные провайдеры, приложение не будет запущено, пока не отработают асинхронные провайдеры
/*
 provide: 'test',
useFactory: async () => {
    await new Promise(resolve => {
        setTimeout(() => {
            console.log(1);
            resolve(true);
        }, 5000);
    });
},
*/



//? Чтобы разрешить круговую зависимость, можно использовать forwardRef, либо ссылку на модуль ModuleRef










//!================================================================================================================================================
//? /MiddleWare/
// https://docs.nestjs.com/middleware
//? Классы, который являются промежуточными обработчиками между клиентом и контролером

//? реализует интерфейс NestMiddleware, и вызывается функция next, если все хорошо, и обработка перейдет к следующему промежуточному обработчику
//? можно использовать асинхрощину, за нас все сделает nest


//? они объявляются в модуле, он должен реализовать интерфейс NestModule, куда передаются обработчики, а затем указываются пути, к которым будут применены они, либо же наоборот - исключены










//!================================================================================================================================================
//? /Filters exception/Фильтры исключений/
// https://docs.nestjs.com/exception-filters
//? Все исключения обрабатываются на глобальном уровне, все, что не отработало, будет поймано тут и будет выброшен ответ ошибки на неверное действие

//? Данная сущность перехватывает ошибки и как то можно обработать их самих, изменить логику и т.д.


//? Ниже мы ловим любую ошибку и отвечаем 200 ответом
//? useGlobalFilters
//? UseFilters
/*
@Catch()
export class Filter implements ExceptionFilter {
    public async catch(exception: any, host: ArgumentsHost) {
        return host.switchToHttp()
            .getResponse<Response>()
            .status(200)
            .send({
                statusCode: 200,
                message: ['TEST'],
            })
            .end();
    }
}

@UseFilters(Filter)
<CONTROLLER>
*/










//!================================================================================================================================================
//? /Pipes/
// https://docs.nestjs.com/pipes
//? Сущности, которые преобразуют данные, принимает значение и метаданные


//? Можно применить через UsePipes
//? передать в Query, Param декораторы
//? useGlobalPipes
/*
@Injectable()
export class Pipe implements PipeTransform {
    public transform(value: any, metadata: ArgumentMetadata) {
        console.log('value', value);
        console.log('metadata', metadata.data);
        console.log('metadata', metadata.metatype);
        console.log('metadata', metadata.type);
    }
}

@UsePipes(Pipe)
<CONTROLLER>
*/


//? Можно предоставить дефолтные значения в пайп, вызвав перед ним дефолтный пайп, который принимает значение и возвращает его










//!================================================================================================================================================
//? /Guards/
// https://docs.nestjs.com/guards#authorization-guard
//? Они определяют, будет ли данный запрос обрабатываться обработчиком маршрута или нет, в зависимости от определенных условий (таких как разрешения, роли, ACL и т. д.), присутствующих во время выполнения.


//? useGlobalGuards
//? UseGuards
/*
@Injectable()
export class AuthGuard implements CanActivate {
    public canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
        console.log(context);
        console.log(context.getHandler()());
        return true;
    }
}

@UseGuards()
<CONTROLLER>
*/










//!================================================================================================================================================
//? /Interceptors/
// https://docs.nestjs.com/interceptors
//? Перехватчики вызываются до и после обработки контроллера

//? UseInterceptor
/*
@Injectable()
export class Interceptor implements NestInterceptor {
    public intercept(context: ExecutionContext, next: CallHandler<any>): Observable<any> | Promise<Observable<any>> {
        console.log('intercept');

        return next
            .handle()
            .pipe(
                tap(data => {
                    console.log(data);
                    console.log('after');
                }),
            );
    }
}

@UseInterceptor
<METHOD>
*/


https://docs.nestjs.com/fundamentals/module-ref