//!================================================================================================================================================
//? /CLI/
//? nest new <name>
//? nest g [controller | module | class] <name>










//!================================================================================================================================================
//? Все приложение создается через функцию, где мы создаем приложение, указываем порт
/*
async function bootstrap() {
    const app = await NestFactory.create(AppModule);
    app.setGlobalPrefix('api');
    await app.listen(8000);
}
bootstrap();
*/

//? setGlobalPrefix
//? указывает префикс глобальный, который будет добавлен ко всему пути









//!================================================================================================================================================
//? /Modules/
//? Также как и в angular все приложение делится на модули, объявляются через Module, где также можно прописать импорты, объявления, провайдеры и экспорты

//? Очень похожи на angular модули, также нужно импортировать другие модули, чтобы получить функционал, по дефолту все модули инкапсулированы в этом модуле без экспорта их


//? /@Global/
//? делает всех провайдеров модуля глобальными





//?================================================================================================================================================
//? /ConfigModule/
// npm i @nestjs/config
//? модуль для работы с файлами .env в nest










//!================================================================================================================================================
//? /Controllers/
//? Входная точка в приложение, они обрабатывают запросы входящие, отправляет ответы обратно на клиент

//? по сути это класс, декорированный Controller, куда указываем путь по которому будет вызван наш контроллер





//? методы внутри него декорируются соответствующим именем запроса, get декоратором @Get и т.д., т.е. каждый метод будет вызван при соответствующем запросе
//? nest сам создаст обработчик по данному пути для запроса
//? по дефоту всегда возвращается 200 ответ, на пост вернется 201
//? из функций можно возвращать промисы, observable, nest сам за нас дождется их выполнения


//? /@Get/


//? /@Post/


//? /@HttpCode/
//? Изменяет статус ответа


//? /@Redirect/
//? редирект на другой эндпойнт





//? В каждую функцию можно внедрить через декораторы аргументы, ответ, запрос, тело запроса и т.д, nest все сделает за нас. Это нужно, чтобы как-то модифицировать запросы


//? /@Res/
//? внедрит ответ, все его параметры и т.д
//? по дефолту, из за того, что мы используем express, тип ответ будет тоже Response из Express
//? тут мы может сами устанавливать статус ответа, заголовки и т.д. НО!, если мы как-то модифицируем ответ, то нам нужно прописать обьект настроек для ответа, чтобы он корректно работал, иначе nest будет думать, что мы сами будет все обрабатывать
/*
@Get()
    @HttpCode(200)
    public async login(
        @Res() response: Response,      //если ничего не передать, ответ будет падать
    ): Promise<unknown> {
        response.setHeader('test', 'test');
        response.statusCode = 201;
        response.send('hi');
        response.end();
    }
*/


//? /@Req/
//? запрос, и все его данные, параметры и т.д.


//? /@Param/
//? парамерты запроса


//? /@Body/
//? если мы хотим получить тело запроса, нужно создать DTO(Data Transfer Object), по сути это будет типизация запроса, но рекомендуют использовать класс из за Pipes


//? /@Query/
//? query параметры


//? /@Headers/
//? заголовки запроса










//!================================================================================================================================================
//? /Providers/Провайдеры/
//? Сервис, который делает какую то логику, обращается к базе данных, и т.д.

//? сервисы нужно объявлять в модуле в providers


//? Injectable
//? по дефолту сервис является singleton, либо можно указать конкретно скоуп
/*
scope: Scope.Default
*/

//? на каждый входящий запрос новый экземпляр
/*
Scope.Request
*/

//? каждый кто инжектит сервис, будет иметь новый экземпляр
/*
Scope.Transient
*/