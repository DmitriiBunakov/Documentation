//!================================================================================================================================================
//? Суть реактивного программирования - множественные подписки на конкретное изменение и управление данным состоянием из разных мест










//!================================================================================================================================================
//? /Observable/

//? Обьект, который принимает функцию, в которую как аргумент передается подписчик, где можно отправлять значения, ошибки, завершать все подписки и т.д.
//? Колбэк вызывается только при подписке на observable
//? Может иметь только одного подписчика, этим отличается от subject


//? При подписке передается колбэк, где можно предоставить 3 обработчки разных
//?     next - при отправке значения
//?     complete - при завершении
//?     error - при ошибке


//? методы некоторые Observable
//?     forEach - для каждого значения, полученного всеми подписчиками сделать что-то
//?     toPromise - создать промис для значения









//!================================================================================================================================================
//? /Subject/
//? Особый тип Observable, который может иметь множество подписчиков, а также может управляться из любого места

//? Создается обьект, на который можно подписаться много раз, а также с помощью api можно отправлять значения из любого места, будут уведомляться все подписчики

//?     next - отправить значение
//?     complete - закрыть все подписки и удалить обьект
//?     error - вызвать ошибку
//?     unsubscribe - запретить эмитить события
//?     observers - все подписчики





//?================================================================================================================================================
//? /BehaviorSubject/
//? Подтип, который хранит последнее значение, это значит, что при подписке будет сразу вызван подписчик со значением, которое хранит обьект

//?     getValue - получить хранящееся значения





//?================================================================================================================================================
//? /ReplaySubject/
//? Подтип, который может хранить указанное количество значений. Т.е. при подписке на него, он сразу выдаст указанное количество уже хранящихся значений, также можно указать какое время будут храниться данные
//? например тут будут храниться данные в течении 500 миллисекунд
/*
const subject = new ReplaySubject(500, 1000);
*/





//?================================================================================================================================================
//? /AsyncSubject/
//? Уведомляет подписчиков только в том случае, если он был завершен, и поставляет только последнее значение
//? Не хранит значение, если подписаться после закрытия, новые подписчики уведомлены не будут










//!================================================================================================================================================
//? /Operators/Операторы/
// https://rxjs.dev/guide/operators

//? of
//? создает observable из переданных значений и сразу эмитит их все



//? from
//? observable из итерируемого значения



//? fromEvent
//? observable из события на элемент



//? interval/timer
//? observable из времени



//? defer
//? отложенное создание, т.е. observable создается только при подписке, вызывается колбэк функция создания



//? range
//? эмитит значения с начального значения - по заданное



//? iif
//? в зависимости от колбэк функции возвращает один из двух observable
/*
const boolean = true;
const firstOrSecond = iif(
    () => boolean,
    of('first'),
    of('second'),
);
firstOrSecond.subscribe(value => console.log(value));
*/



//? combineLatest
//? при каждой отправке из зарегестрированных наблюдаемых, объединяет последние значения в массив



//? concat
//? принимает наблюдаемых, и подписывается на первый из них, как только первый закончится методом complete, будут вызваны все значения второго наблюдаемого
/*
const observable1 = new Observable(subscriber => {
    subscriber.next(1);
    subscriber.next(2);
    subscriber.next(3);
    subscriber.complete();
});

const observable2 = new Observable(subscriber => {
    subscriber.next('first');
    subscriber.next('second');
    subscriber.next('third');
    subscriber.complete();
});

const concatedValue = concat(observable1, observable2);

concatedValue.subscribe(data => {
    console.log(data);
});
concatedValue.subscribe(data => {
    console.log(data);
});

1   2   3   first     second   third      1     2    3   first      second  third
*/



//? forkJoin
//? при завершении всех наблюдаемых переданных, объединяет последние значения в массив



//? merge
//? объединяет наблюдаемых в один поток и уведомляет в порядке приходящих значений



//? partition
//? принимает наблюдаемого, и функцию колбэк, которая обрабатывает значения, возвращает массив из двух наблюдаемых, в первом будут содержаться значения удовлетворишие условию в колбэк функции, во втором - нет, что то похожее на filter
/*
const [correctValues, incorrectValues] = partition(
    subject1,
    (value: any, index: number) => {
        return value.age >= 10;
    },
);

correctValues.subscribe(data => {
    console.log(data);
});

incorrectValues.subscribe(data => {
    console.log(data);
});

subject1.next({age: 10});
subject1.next({age: 15});
subject1.next({age: 8});
*/



//? race
//? подписывается на все наблюдаемые, и как только первое из них поставляет значение, подписка переходит на него, и отписываемся от всех остальных, и слушаем только данное наблюдаемое



//? zip
//? когда каждое из наблюдаемых отправит по значению, эти значения будут собраны в массив, затем когда во второй раз каждый снова отправит по значению, эти значения снова будут собраны в массив и т.д.
/*
const subject1 = new Subject();
const subject2 = new Subject();

zip(subject1, subject2)
    .subscribe(x => console.log(x));

subject1.next('subject1 - 1');
subject2.next('subject2 - 1');

subject1.next('subject1 - 2');
subject2.next('subject2 - 2');
*/



//? switchMap
//? оператор применяется в pipe, возвращает новый наблюдаемый, на который потом и будет подписка происходить. Т.е. при получении значения первого наблюдаемого, будет подписка на наблюдаемое в switchMap, и слушать мы будет именно значения из switchMap. Если главный родительский наблюдаемый обьект снова отправит значение, то будет вызван заново switchMap, сработает новая подписка, а старая автоматически удалится, т.е. от switchMap наблюдаемого не надо отписываться
/*
fromEvent(document, 'click')
    .pipe(
        tap(() => {
            console.log('click');
        }),
        switchMap(() => {
            return interval(1000);
        }),
    )
    .subscribe(data => {
        console.log(data);
    });

click   1   2   3   click   1   2   3
*/
