//!====================================================================================================
//? Переменные
// https://learn.javascript.ru/variables
//?   можно использовать $ _ цифры, нельзя использовать тире и начинать переменную с цифры, а также зарезервированные имена(https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0)
//?   отличаются let и var областью видимости, const нельзя переопределить напрямую, но можно переопределить свойство константного обьекта. Также в строгом режиме нельзя просто так определить переменную без ее объявления.









//!====================================================================================================
//? Var
// https://learn.javascript.ru/var
//? Для «var» не существует блочной области видимости, она будет изолирована только в функции или скриптом, все, в остальных случаях она вылазит из блока кода
/*
if (true) {
  var test = true; // используем var вместо let
}
alert(test);
*/

//? также объявление в глобальной области видимости через var записывает эту переменную в window обьект, а чтобы записать обычную переменную в глобальный обьект, необходимо напрямую обратиться к window и записать в него нужное значение
/*
var a = 1;
console.log(window.a);
*/








//!====================================================================================================
//? Strict mode
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode

//? 1) Невозможно создать переменную без ее объявления.
/*
'use strict';
myAge = 18;   //приведет к ошибке в строгом режиме(variable is not defined), без него можно объявить переменную таким образом и никто не будет ругаться
*/

//? 2) Выдает TypeError на присваивания, которые нельзя делать, например запрет на присваивание глобальным переменным языка, присваивание значения свойству защищенного от записи обьекта
/*
'use strict';
var undefined = 5;   //выдаст TypeError
var Infinity = 5;   //выдаст TypeError

var obj1 = {};
Object.defineProperty(obj1, "x", { value: 42, writable: false });
obj1.x = 9;   //выдаст TypeError
*/

//? 3) В строгом режиме попытки удалить неудаляемые свойства будут вызывать исключения (в то время как прежде такая попытка просто не имела бы эффекта)
/*
'use strict'
delete Object.prototype;   //выдаст TypeError
*/

//? 4) Нельзя в функции определять аргументы имеющие одно и то же имя
/*
'use strict';
function name(a, a, b) {   //Duplicate parameter name not allowed in this context
    console.log(a, a, b);
}
name(1, 2, 3);
*/

//? 5) запрещает синтаксис восьмеричной системы счисления. Восьмеричный синтаксис не является частью ECMAScript, но поддерживается во всех браузерах с помощью дописывания нуля спереди к восьмеричному числу: 0644 === 420 и "\045" === "%". В ECMAScript 2015 восьмеричное число поддерживается также с помощью дописывания перед числом "0o"(ниже пример)
/*
'use strict';
console.log("\045");   //Octal escape sequences are not allowed in strict mode.

это можно использовать в строгом режиме
var a = 0o10;
*/

//? 6) запрещает устанавливать свойства примитивным значениям
/*
'use strict';
false.true = '';   //TypeError
14.sailing = 'home';  //TypeError
*/

//? 7) запрещает работать с with

//? 8) eval в строгом режиме не добавляет в окружающий контекст переменные, то есть они видны только внутри eval
// https://learn.javascript.ru/eval
/*
'use strict';
eval("let x = 5");
console.log(x);   //undefined, нет такой переменной
*/

//? 9) нельзя удалять примитивные переменные через delete
/*
'use strict';
let a = 'Dima';
delete a;  //Delete of an unqualified identifier in strict mode.
*/

//? 10) в строгом режиме происходит копирование всех аргументов переданных в функцию, то есть, при изменении аргумента массив arguments не изменяется, и также при изменении arguments по индексу не будет изменяться и переданный аргумент. В обычном же режиме происходило обновление и того и другого.
/*
'use strict';
function name(a) {
    a = 12;
    console.log(arguments);
    console.log(a);
}
name(1);
*/

//? 11) запрещает доступ в функции к arguments.calee
/*
'use strict';
let f = function() { return arguments.callee };
f();   //выдаст TypeError
*/

//? 12) скрывает в блоке изолированном функцию объявленную в нем
/*
{
    function f() {
        console.log(1);
    }
}
f();   //ошибка, нет такой функции
*/



//!====================================================================================================
//? Типы данных
// https://learn.javascript.ru/types
//? есть 8 типов данных

//? 1) Number
//? к нему относятся Infinity, -Infinity и NaN

//? 2) BigInt
//? js не может содержать числа больше (2**53-1) или же (9007199254740991) или -(2**53-1)
/*
let bigInt = 1234567890123456789012345678901234567890n;
*/
//? 3) String

//? 4) Boolean

//? 5) null
//? означает, что мы ссылаемся на что то несуществующее вообще, то есть этого просто нет
/*
console.log(a);   //ошибка, т.к а просто не существует
*/

//? 6) undefined
//? это значит, что у переменной нет какого то значения, ей не присвоено никакого значения, мы объявили переменную, но значения ее нет.
//? обычно null используется для присвоения переменной пустого или неизвестного значения, а undefined – для проверок, была ли переменная назначена.
/*
let age;
alert(age);   //выведет "undefined"
*/

//? 7) Object

//? 8) Symbol


//? Оператор typeof
//? Возвращает тип переданного аргумента в виде строки
//? есть пара нюансов при работе с этим оператором, на null он вернет тип обьект(это признанная ошибка языка), а для функции он вернет тип функция, хотя по факту функция в языке является обьектом, но это может быть достаточно удобно при работе

//? Array.isArray()
//? проверяет это массив или нет, потому что typeof вернет обьект






//!====================================================================================================
//? Преобразование типов
// https://learn.javascript.ru/type-conversions


//? К числу
/*
+undefined   //NaN
+null   //0
+true   //1
+false   //0
+string   //сначала по краям пробелы обрезаются, 0 - пустая строка, NaN - не число, number - если есть число в строке
*/


//? К логическому
/*
0, null, undefined, '', NaN [].length   //false
{}, []   //true
*/



//? Преобразование обьектов
// https://learn.javascript.ru/object-toprimitive
//? по дефолту обьект преобразуется в [object Object] если со строкой складывают, в NaN если с числом и он всегда равен true

//? все методы по преобразования должны возвращать примитивное значение и только!

//? Алгоритм преобразований к примитивам следующий:
//? Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует.
//? Иначе, если хинт равен "string" происходит попытка вызвать obj.toString(), затем obj.valueOf(), смотря что есть.
//? Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf(), затем obj.toString(), смотря что есть.

//? Symbol.toPrimitive
//? метод, если есть, определяет все преобразования обьекта, можно самому решать, во что он будет преобразовываться
//? обьект преобразуется в число, например если он приводится явно к числу, в этом методе будет hint number
//? к строке, если например будет alert, т.к. там только строковый тип данных используется, hint будет string
//? default, если будет конкатенация
/*
let a = {
    name: 'dima',
    age: 22,
    [Symbol.toPrimitive](hint) {
        console.log(hint);
        if (hint === 'string') {
            return this.name;
        }
        if (hint === 'default') {
            return this.name;
        }
        if (hint === 'number') {
            return this.age;
        }
    }
}
alert(a);   //dima
console.log(a + '');   //dima
console.log(+a);   //22
*/

//? toString/valueOf
//? если нет метода toPrimitive, то код сначала попробует вызывать toString для хинта string, valueOf для иных хинтов
/*
let a = {
    name: 'dima',
    age: 22,
    toString() {
        return this.name;
    },
    valueOf() {
        return this.age;
    }
}
alert(a);   //dima
console.log(a + '');   //'22'
console.log(+a);   //22
*/

//? в отсутствие Symbol.toPrimitive и valueOf, toString обработает все случаи преобразований к примитивам


//? преобразование в json toJSON
//? можно реализовать метод в обьекте, который будет вызывать при преобразовании обьекта в json, это тоже самое что и valueOf и toString
/*
let room = {
    number: 23,
    toJSON() {
        return this.number;
    }
};
console.log(JSON.stringify(room));
*/




//!====================================================================================================
//? Операторы
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators#%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence   приоритеты
// https://learn.javascript.ru/operators
//? Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».
//? Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный.
//? Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме.
// https://learn.javascript.ru/operators

//? Декремент и инкремент
//? постфиксная форма сначала вернет старое значение, а затем увеличит переменную, префиксная форма сначала увеличит значение а затем вернет результат.
/*
let a = 0;
let b = a++;   //постфиксная
console.log(a);   //1
console.log(b);   //0

let a = 0;
let b = ++a;   //префиксная
console.log(a);   //1
console.log(b);   //1
*/



//? Сравнение
// https://learn.javascript.ru/comparison
//? Строки
//? строки сравниваются в "алфавитном"(используется кодировка Unicode, а не настоящий алфавит) порядке посимвольно, а также маленькие буквы считаются больше, чем большие
/*
'a' < 'b'   //true
'a' > 'A'   //true
*/


//? Разные типы
//? приводятся к числу
/*
интересный факт, значения ниже равны, потому что привели к числу, и оба false, значит они равны, но если отдельно привести каждое к логическому, то 0 будет false, а '0' будет true и сравнение будет другое.
let a = 0;
let b = '0';
a == b   //true
*/


//? Строгое сравнение
//? оператор строгого сравнения не приводит типы к единому, если один из них не подходит будет сразу возврат false
/*
1 === 1   //true
1 === '1'   //false
*/


//? Object.is
//? существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях: работает с NaN, значения 0 и -0 разные
/*
Object.is(NaN, NaN) === true, здесь он хорош
Object.is(0, -0) === false, это редко используется, но технически эти значения разные
*/



//? Сравнение null undefined
/*
null === undefined   //false, эти значения различны, так как различны их типы
null == undefined   //true, эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка
*/


//? Условное ветвление, тернарный оператор, условия
// https://learn.javascript.ru/ifelse
/*
false ? 'это правда' : false ? 'это тоже правда' : 'а это ложь'   //а это ложь
*/


//? Логические операторы
// https://learn.javascript.ru/logical-operators
//? && || ! приводят значения к логическому типу

//? || запинается на правде, или возвращает последний ложный вариант.
//? Он работает так: Вычисляет операнды слева направо. Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда. Если все операнды являются ложными (false), возвращает последний из них.

//? && запинается на лжи или возвращает последний правдивый вариант, если они все правдивы.
//? Вычисляет операнды слева направо. Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда. Если все операнды были истинными, возвращается последний.
//? Приоритет И больше чем у ИЛИ

//? ! Приводит к логическому типу и возвращает противоположное
/*
let a = null;
console.log(!a);   //true
*/
//? !! Возвращает логический тип аргумента(приводит к логическому)


//? Оператор объединения с null
// https://learn.javascript.ru/nullish-coalescing-operator
//? ?? вернет первый аргумент, если он не null/undefined, иначе второй.
//? можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined.
//? различие между || и ?? в том, что || возвращает первой ИСТИННОЕ значение, а ?? первое определенное(не null/undefined).
/*
let user;
let userCash = a ?? 'anonim';   //присвоится аноним

let a;
let b;
let c = 1;
let d = a ?? b ?? c;   //d == 1
*/

//? Опциональная цепочка ?.
// https://learn.javascript.ru/optional-chaining
//? мы можем сначала проверить, если ли свойство у обьекта, и затем продолжить работу, также применимо и к методам
//? если цепочка прервется, то вернется undefined
/*
let a = {};
a.f?.();
a?.['name'];
*/

//? нельзя использовать для присваивания(если есть, то присвоить то то то то, так делать нельзя)

//? можно удалять свойства, если они есть
/*
let a = {};
delete a?.name;
*/








//!====================================================================================================
// https://learn.javascript.ru/while-for
//? Циклы
//? break используется, чтобы выйти из цикла
//? continue используется, чтобы перейти к следующей итерации
//? mark(label) можно повесить на цикл, чтобы обратиться к конкретному циклу и выйти из него
/*
mark: for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5; j++) {
        if (j === 2) {
            break mark;
        }
        console.log(j);
    }
}
*/


//? for
//? в цикле for можно убрать части цикла(начало, условие, шаг)
/*
let i = 0;
for ( ; i < 5; ) {
    i++;
}
*/








//!====================================================================================================
//? Switch
// https://learn.javascript.ru/switch
//? выполняет строгое сравнение
//? если по ходу выполнения был заход в case(то есть выполнение условия), то будут все последующие case, если в них не прописан break
/*
let a = 2;
switch (a) {
    case 1:
        console.log(1);
    case 2:
        console.log(2);   //выполнится без break
    case 10:
        console.log(3);   //выполнится без break
}

switch (a) {
    case 1:
    case 2:
        console.log(1);   //группировка case
}
*/












//!====================================================================================================
//? Functions Функции
// https://learn.javascript.ru/arrow-functions
// https://learn.javascript.ru/function-basics
// https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8#.D0.9B.D0.B5.D0.BA.D1.81.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_vs._.D0.B4.D0.B8.D0.BD.D0.B0.D0.BC.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D0.BE.D0.B1.D0.BB.D0.B0.D1.81.D1.82.D0.B8_.D0.B2.D0.B8.D0.B4.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D0.B8
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/function
// https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0
//? функция это обьект первого класса(может быть возвращена и передана как параметр...)
//? функция имеет полный доступ к внешним переменным, но сначала ищет их внутри себя

//? аргументам функции можно присвоить значения по умолчанию(если их не передать будет undefined у аргумента)
/* function f() return; let a = f();   //undefined*/

//? Function Declaration включает хостинг(всплытие функций) в глобальном пространсве(аналогия с var)
/* function sayHi() { alert( "Привет" ) } */
//? Function Expression объявляет функцию по ходу выполнения кода
/* let sayHi = function() { alert( "Привет" ) } */
//? arguments не связан в строгом режиме с каждым аргументом, если изменить один, другой не изменится
/*
function f(a, b) {
    arguments[0] = 1;
    console.log(arguments);   //1
    console.log(a);   //0
}
f(0);
*/


//? стрелочные функции
//? если один аргумент, можно опустить скобки, и не писать return если выражение помещается в одну строку
/* let f = a => a*2; */

//? они не имею обьект arguments

//? стрелочной функции нельзя задать контекст через привязку, она будет всегда иметь тот контекст, в котором была создана






//?====================================================================================================
//? Рекурсия
// https://learn.javascript.ru/recursion

//? Когда функция производит вложенный вызов, происходит следующее:
//? Выполнение текущей функции приостанавливается.
//? Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
//? Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
//? После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.

//? рекурсия хранит в памяти n различных контекстов, что следовательно влияет на производительность






//?====================================================================================================
//? LexicalEnvironemt   Лексическое окружение   Замыкания
// https://learn.javascript.ru/closure

//? LexicalEnvironemt
//? В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment


//? Объект лексического окружения состоит из двух частей:
//? Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).  "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта»
//? Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок)


//? Лексическое окружение – это специальный внутренний объект
//? «Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение объекта должно оставаться таким, как было описано.


//? Один вызов – одно лексическое окружение. Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.
/*
function makeCounter() {
    let count = 0;

    return function incr() {
        return ++count;
    }
}
let counter1 = makeCounter();   //вызвали makeCounter и создали одно лексическое окружение для функции counter1, теперь когда она будет вызываться постоянно будет ссылка на это окружение
console.log(counter1());   //будет увеличиваться потому что внутри нет такой переменной и она будет браться из лексического окружения родительской функции
console.log(counter1());
console.log(counter1());
*/
//? Также тут внутренняя функция имеет доступ к переменным наружней, потому что они есть в памяти, лексическое окружение будет до тех пор, пока будет ссылка на него, в данном примере внутрненняя функция имеет доступ к переменным наружней и они используются и следовательно лексическое окружение наружней будет доступно


//? Сборка мусора в функциях
//? Обычно лексическое окружение очищается и удаляется после того, как функция выполнилась
/*
function f() {
  let value1 = 123;
  let value2 = 456;
}
f();   //Здесь два значения, которые технически являются свойствами лексического окружения. Но после того, как f() завершится, это лексическое окружение станет недоступно, поэтому оно удалится из памяти.
*/
//? Но, если есть вложенная функция, которая всё ещё доступна после выполнения f, то у неё есть свойство [[Environment]], которое ссылается на внешнее лексическое окружение, тем самым оставляя его достижимым, «живым». Если функцию ниже вызвать несколько раз то будет создано несколько лексических окружений, которые будут держаться в памяти до тех пор, пока будет доступна ссылка на функцию возвращенную из f();
/*
function f() {
  let value = 123;
  function g() { alert(value); }
  return g;
}
let g = f();   //пока что есть ссылка на окружение родительской функции
g = null;   //а сейчас мы удалили ссылку на функцию, которая имела ссылку на окружение родительской функции
*/


//? Важный пример:
/*
function makeArmy() {
    let shooters = [];
    let i = 0;
    while (i < 10) {
        let shooter = function() {
            alert( i );
        };
        shooters.push(shooter);
        i++;
    }

    return shooters;
}
let army = makeArmy();
army[0](); // у 0-го стрелка будет номер 10
army[5](); // и у 5- номер 10
*/
//? это происходит потому что переменная i объявлена в лексическом окружении makeArmy, и когда цикл отработает функция shooter будет ссылаться на значение 10. Это потому, что i была определена не в теле цикла, а снаружи него. Чтобы избежать этих проблем можно переписать на цикл for или использовать внутри другую переменную
/*
function makeArmy() {
    let shooters = [];
    let i = 0;
    while (i < 10) {
        let j = i;
        let shooter = function () { // функция shooter
            alert(j); // должна выводить порядковый номер
        };
        shooters.push(shooter);
        i++;
    }
    return shooters;
}
let army = makeArmy();
army[0](); // 0
army[5](); // 5
*/


//? Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы. Если функция была создана в глобальном окружении, то там будет ссылка на него
//? Не имеет значения, какой способ объявления функции используется: Function Declaration или Function Expression. Все функции получают свойство [[Environment]], которое ссылается на лексическое окружение, в котором они были созданы



//? Замыкание
//? Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").
//? То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным.
//? Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, как работает лексическое окружение.



//? LexicalEnvironemt
//? LexicalEnvironemt существует для всех блоков кода {}, то есть оно создается в условиях, циклах, функциях



//? IIFE
// https://learn.javascript.ru/closure#iife
//? Раньше в JS не было лексического окружения на уровне блоков кода, поэтому использовались самовызывающиеся функции

//? IIFE - immediately-invoked function expressions
//? функция, которая объявляются и сразу же сама себя вызывает
/*
(() => {
    console.log(1);
})()
*/



//?====================================================================================================
//? Объект функции, NFE
// https://learn.javascript.ru/function-object
//? Функция это обьект, а значит у нее есть свои методы и свойства

//? length - показывает сколько параметров принимает функция
/*
function f2(a, b) {};
alert(f2.length);   //2
*/

//? name - имя функции

//? можно также определить пользовательские свойства функции, например счетчик, чтобы узнать сколько раз она вызывалась
/*
function say() {
    say.counter++;
}
say.counter = 0;   //начальное значение
say();
say();
say();
say();
console.log(say.counter);   //4
*/
//? свойство - это не переменная, оно не имеет своего лексического окружения, то есть оно всегда относится к этой функции


//? при function expression можно задать сразу имя переменной и самой функции, в этом есть плюс, когда мы внутри функции хотим отбратиться к ней же. А вот если мы из переменной sayHi удалим значение функции, то внутри, при обращении к sayHi мы получим ошибку, т.к. такая переменная не будет содержать функции(надо обращаться к func внтури функции)
/*
let sayHi = function func(who) {
    if (who) {
        alert(`Hello, ${who}`);
    } else {
        sayHi("Guest"); // Ошибка: sayHi не является функцией
    }
};
let welcome = sayHi;
sayHi = null;
welcome(); // Ошибка, вложенный вызов sayHi больше не работает!
*/



//?====================================================================================================
//? New Function
// https://learn.javascript.ru/new-function

//? Функцию можно объявлять через оператор new, куда первым аргументом приходят аргументы в виде строки, вторым - тело функции в виде строки
/*
let sum = new Function('a', 'b', 'return a + b');
alert(sum(1, 2)); // 3
*/

//? У такой объявленной функции [environment] ссылка будет ссылать на глобальный обьект
/*
function f() {
    let value = 18;
    return new Function('return value');   //это работать не будет, т.к. ссылка есть только на глобальную область видимости
}
console.log(f()());
*/



//?====================================================================================================
//? setTimeout и setInterval
// https://learn.javascript.ru/settimeout-setinterval
//? Эти функции поставляются окружением в котором воспроизводится JS

//? Принимают в виде параметров функцию, задержку и аргументы, которые надо передать в функцию
//? эти функции возвращают идентификатор таймера, чтобы можно было его обнулить
/*
function f(...args) {
    console.log(...args);
}
let id = setTimeout(f, 2000, 1, 2, 2, 3, 4, 5);
clearTimeout(id);
*/


//? Преимущества рекурсивного setTimeout перед setInterval:
//? Рекурсивный метод ждет сначала выполнения кода внутри функции, а только затем запускает таймер еще раз, т.е. если код ресурсоемкий setTimeout будет более точен во времени, а setInterval будет запускаться независимо от того, был ли выполнен код внутри функии или нет


//? Интервалы лучше всего ВСЕГДА отменять, когда они больше не нужны, потому что внешние переменные, к которым они обращаются, будут в памяти до тех пор, пока работают интервалы!!!. Для производительности лучше всего всегде очищать таймеры


//? setTimeout с нулевой задержкой
//? Браузер сам подставит задержку 10мс - это первый кейс
//? а второй - это то, что сначала таймер попадет в событийный цикл, а только потом в стек выполнения функций, поэтому он запустится не прям сразу
/*
setTimeout(() => {
    console.log('timer');
}, 0);
console.log(1);
*/



//? Decorators Декораторы
// https://learn.javascript.ru/call-apply-decorators
//? Принимают в себя функцию и как то модифицируют ее
/*
function delay(f, time) {
    return (...args) => {
        setTimeout(() => {
            f(...args);
        }, time);
    }
}
function f(arg) {
    console.log(arg);
}
let d1000 = delay(f, 1000);
d1000('test');
*/



//? Привязка контекста
// https://learn.javascript.ru/bind

//? В примере ниже мы привязываем контекст конкретно к обьекту и передаваемому аргументу
/*
function askPassword(ok, fail) {
    let password = prompt("Password?", '');
    if (password == "rockstar") ok();
    else fail();
}
let user = {
    name: 'John',

    login(result) {
        alert(this.name + (result ? ' logged in' : ' failed to log in'));
    }
};

askPassword(user.login.bind(user, true), user.login.bind(user, false));
*/













//!====================================================================================================
//? Сборщик мусора
// https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0
// https://learn.javascript.ru/garbage-collection
//? сборщик удаляет обьеты те, на которые больше нет ссылок, даже если удаляемый обьект имеет ссылки на другие, он будет удален, потому что важны только ссылающиеся на него связи
/*
let user = {name: 'dima'};
user = null;   //сборщик видит, что мы не ссылаемся на обьект и удаляет его


let user = {name: 'dima'};
let admin = user;
user = null;   //пока что еще обьект есть, так как на него ссылается admin
admin = null;   //сборщик удаляет обьект
*/












//!====================================================================================================
//? Objects обьекты
// https://learn.javascript.ru/object
//? пустой обьект является true


//? объявляется
/* let a = new Object(); let b = {}; */


//? обращение со свойствами
/*
delete object.name;   //удалить
delete object['long name of key']   //удалить
*/


//? динамическое создание ключей с помощью квадратных скобок
/*
let a = 'name';
let obj = {
    [a]: 'dima',   //создаст свойство с ключом 'name'
}
*/


//? in оператор для проверки свойства в обьекте, передается в строке, потому что если передать переменную в виде ключа, то значит название свойства обьекта находится в этой переменной.
//? В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, когда оно не подходит, и нужно использовать "in". это когда свойство существует, но содержит значение undefined:
/*
let a = {name: 'Alex'};
console.log('name' in a);   //true
*/


//? перебор обьектов через for in.  key - ключи, a[key] - значения
/*
let a = {name: 'dima', age: 22};
for (let key in a) {}
*/


//? свойства в обьекте сортируются в след. порядке: сначала идут целочисленные(это те, которые можно из строки перевести в число и обратно не потеряв смысла), а затем все остальные в порядке добавления
/*
let a = {
    '49',
    '1',
    dima: 'dima',
}
consolt.log(a)   //1, 49, dima
*/


//? сравнение обьектов: 2 обьекта равны только тогда, когда это один и тот же обьект




//?====================================================================================================
//? обьекты копируются по ссылке, то есть если переменной присвоить другой обьект, то обе переменные будут ссылать и изменять один и тот же обьект


//? поверхностное копирование, копирует только верхние значения(если свойство будет обьектом, то оно скопируется по ссылке)
//? Object.assign
/*
let o1 = {
    a: 1,
}
let o2 = {
    d: 4,
}
let obj = Object.assign({}, o1, o2);
obj.a = 10;
*/



//? глубокое копирование
//? for in, логика такая, что мы перебираем обьект и присваиваем новое значение в другой обьект
/*
function cloneDeep(newObject, objectToBeCloned) {
    for (let key in objectToBeCloned) {
        if (typeof objectToBeCloned[key] !== 'object') {
            newObject[key] = objectToBeCloned[key];
        } else {
            newObject[key] = {};
            cloneDeep(newObject[key], objectToBeCloned[key]);
        }
    }
}
*/

//? JSON.parse
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
let newObj = JSON.parse(JSON.stringify(obj));
obj.secondObj.one = 'изменил';
console.log(obj);
console.log(newObj);
*/



//?====================================================================================================
//? Преобразование обьектов
// https://learn.javascript.ru/object-toprimitive
//? по дефолту обьект преобразуется в [object Object] если со строкой складывают, в NaN если с числом и он всегда равен true

//? все методы по преобразования должны возвращать примитивное значение и только!

//? Алгоритм преобразований к примитивам следующий:
//? Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует.
//? Иначе, если хинт равен "string" происходит попытка вызвать obj.toString(), затем obj.valueOf(), смотря что есть.
//? Иначе, если хинт равен "number" или "default" происходит попытка вызвать obj.valueOf(), затем obj.toString(), смотря что есть.

//? Symbol.toPrimitive
//? метод, если есть, определяет все преобразования обьекта, можно самому решать, во что он будет преобразовываться
//? обьект преобразуется в число, например если он приводится явно к числу, в этом методе будет hint number
//? к строке, если например будет alert, т.к. там только строковый тип данных используется, hint будет string
//? default, если будет конкатенация
/*
let a = {
    name: 'dima',
    age: 22,
    [Symbol.toPrimitive](hint) {
        console.log(hint);
        if (hint === 'string') {
            return this.name;
        }
        if (hint === 'default') {
            return this.name;
        }
        if (hint === 'number') {
            return this.age;
        }
    }
}
alert(a);   //dima
console.log(a + '');   //dima
console.log(+a);   //22
*/

//? toString/valueOf
//? если нет метода toPrimitive, то код сначала попробует вызывать toString для хинта string, valueOf для иных хинтов
/*
let a = {
    name: 'dima',
    age: 22,
    toString() {
        return this.name;
    },
    valueOf() {
        return this.age;
    }
}
alert(a);   //dima
console.log(a + '');   //'22'
console.log(+a);   //22
*/

//? в отсутствие Symbol.toPrimitive и valueOf, toString обработает все случаи преобразований к примитивам




//?====================================================================================================
//? Флаги и дескрипторы свойств обьекта
// https://learn.javascript.ru/property-descriptors

//? У свойств обьекта есть 3 флага:
//? writable – если true, свойство можно изменить, иначе оно только для чтения(ошибки при присвоении этому свойству нового значения будут выброшены только в use strict, иначе проигнорируются)
//? enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют
//? configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя


//? Object.defineProperty(obj, propertyName, descriptor)
//? По умолчанию при обычном создании обьекта через {}, все флаги установлены true, но мы также можем изменить их потом, как нам нужно
/*
Object.defineProperty(obj, 'name', {
    writable: false,
    configurable: false,
    enumerable: false,
});
*/

//? Object.defineProperties(object, descriptors)
//? метод для определения сразу нескольких дескрипторов свойств
/*
let obj = {};
Object.defineProperties(obj, {
    name: {value: 'dima', writable: false, configurable: false, enumerable: false},
});
*/

//? Object.getOwnPropertyDescriptors
//? получить все дескрипторы свойств обьекта, вместе с Object.defineProperties можно клонировать свойства сразу с его флагами
/*
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
*/










//!====================================================================================================
//? Prototype Прототип
// https://learn.javascript.ru/prototype-inheritance
//? прототип - то, от чего наследуемся


//? __proto__
//? это геттер и сеттер того обьекта от которого наследуется наш обьект(то есть это обьект, который используется в цепочке прототипов для расширения методов и т.д. нашего обьекта)

//? __proto__ есть у всех обьектов и является это свойство ссылкой на prototype родителя

//? чтобы понять, чему равен __proto__ к конкретном обьекте(классе), надо точно понять с помощью какого конструкторы он был создан. Например {} был создан через new Object, значит его прото будет равно Object.prototype, class One например является функцией и был создан через new Function, а значит Function.prototype будет результатом ссылки из прото
//? __proto__ ссылается всегда на prototype класса с помощью которого он был создан(в этом prototype как раз есть конструктор, с помощью которого и был создан обьект)
//? у классов также есть __proto__ и ссылается он на Function.prototype, т.к. класс это функция и создан класс был через new Function
//? Function.__proto__ === Function.prototype    , т.к. Function класс был создан из Function.prototype.constructor
//? One.__proto__.constructor === Function.prototype.constructor    , потому что One.proto это Function.prototype
//? Object.__proto__ === Function.prototype    , т.к. класс Object был создан с помощью Function
//? Object.prototype   это уже конечная в цепочке прототипов, дальше только null
//? Object.prototype.__proto__     тут уже будет null, т.к. у прототипа обьекта __proto__ ссылается на null
//? Object.__proto__.__proto__ === Object.prototype    ,т.к. прото обьекта это Function.prototype, Function.prototype.__proto__ это прототип обьекта
//? String.prototype.__proto__ === Object.prototype    ,т.к. String.prototype это и есть прототип класса String, а он в свою очередь был создан с помощью Object, а значит String.prototype.__proto__ ссылается на Object.prototype
//? String.__proto__ === Function.prototype   ,т.к. String это класс, а он создан был через new Function, а значит прототипом является Function.prototype
//? ChildClass.__proto__ === ParentClass   ,т.к. был создан с помощью родительского конструктора
//? first.__proto__ === Two.prototype   ,т.к. прото обьекта является прототипом класса, с помощью которого он был создан
/*
class One {
    constructor() {
        this.age = 22;
    }
}
class Two extends One {
    constructor() {
        super();
        this.name = 'Alex';
    }

    sayHi() {
        console.log('Hi');
    }
}
let first = new Two();
console.dir(Two.__proto__ === One);
*/
/*
class One {
    constructor() {
        this.age = 22;
    }
}
let first = new One();
console.log(first.__proto__ === One.prototype)   //true   __proto__ обьектов ссылается на либо на обьект-родитель, либо на prototype класса, с помощью которого он был создан
*/
//? prototype не равен никаким другим прототипам, он единственный в своем роде!!! То есть он равен только __proto__ которое на него ссылается и все
//? prototype есть только у классов и функций(объявленных через function)
//? One.__proto__.__proto__ === Object.prototype    , потому что прото класса это прототип функции, а прото прототипа функции прототип обьекта
//? One.prototype.__proto__ === Object.prototype    , потому что прототип это обьект, а прото всех обьектов это Object.prototype



//? Object.create(null);
//? создание обьекта без протипа вообще, но и естественно не будет методов обьекта


//? Обьект может иметь только один прототип, но большую цепочку


//? При обращении к свойству обьекта, обьект сначала ищет его внутри себя, а затем в своих прототипах


//? Если мы наследуемся от обьекта, и у родительского обьекта мы поменяем значение свойства, то оно изменится и в дочернем обьекте



//? Способы установки прототипов:
//? __proto__
//? Это геттер сеттер для установки прототипа обьекту
/*
let animal = {
    legs: 4,
}
let dog = {
    name: 'Alex',
    age: 5,
}
dog.__proto__ = animal;
console.log(dog);
console.log(dog.__proto__);   //animal   -   тоже самое что и [[Prototype]]
*/

//? setPrototypeOf
//? Устанавливает на обьект прототип



//? При использовании геттера и сеттера и методов родительского обьекта, где используется this, this будет равен обьекту, на котором используется метод
//? Это на самом деле очень важная деталь, потому что у нас может быть большой объект со множеством методов, от которого можно наследовать. Затем наследующие объекты могут вызывать его методы, но они будут изменять своё состояние, а не состояние объекта-родителя.
/*
let animal = {
    legs: 4,
    value: 100,
    get info() {
        return this.legs + ' ' + this.value;
    },
}
let dog = {
    name: 'Alex',
    age: 5,
    dog.__proto__ = animal,
}
dog.value = 300;
console.log(dog.info);
*/


//? for..in проходится не только по свойствам обьекта но и еще по свойствам прототипа








//?====================================================================================================
//? F.prototype
// https://learn.javascript.ru/function-prototype

//? Для функции конструктора можно указать перед ее созданием прототип, от которого она будет наследоваться, указать можно напрямую через prototype. Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
/*
function One() {
    this.name = 'Alex';
}
One.prototype = { age: 22 };
let person = new One();
console.log(person);
*/






//?====================================================================================================
//? Встроенные прототипы
// https://learn.javascript.ru/native-prototypes













//!====================================================================================================
//? This контекст
// https://learn.javascript.ru/object-methods
// https://tproger.ru/translations/javascript-this-keyword/

//? контекст у вызова функции обычной - undefined(strict mode), window(обычный код)
/*
function f() {
    console.log(this);   //undefined
}
*/

//? контекст вызова стрелочной функции - контекст родителя, если она вызвана в глобальной области - window
/*
let f = () => {
    console.log(this);   //window
}
*/

//? методы обьекта ссылаются на сам обьект, который его вызвал, то есть метод имеет контекст вызвавшего обьекта. То есть если один обьект имеет метод, и другой наследуется от первого, то второй будет вызывать метод родителя, и следовательно контекст будет второго обьекта, т.к. он вызывает метод.
/*
let obj = {
    a: 'dima',
    f() {
        console.log(this);   //метод ссылает на обьект, который его вызвал
        let s = () => {
            console.log(this);   //стрелочная функция ссылается на контекст родителя
        }
        s();
    }
}
obj.f();


let obj = {
    name: 'dima',
    f() {
        console.log(this);
    },
}
let obj2 = {
    age: 22,
};
Object.setPrototypeOf(obj2, obj);
obj2.f();   //obj2 покажет, т.к он и вызывал метод
*/

//? стрелочный метод обьекта не имеет контекста обьекта, в отличии от класса(но привязать их нельзя ни тот ни тот)
/*
let obj = {
    f: () => {
        console.log(this);
    }
}
obj.f();   //window  у обьектов у стрелочных методов нет контекста обьекта

class User {
    constructor(age) {
        this.age = age;
    }
    f = () => {
        console.log(this);
    }
}
let user = new User(22);
user.f();   //user  у экземпляров класса есть контекст экземпляра

*/

//? методы отделенные от обьекта в переменную не будут иметь собственного контекста, this всегда зависит от того, КТО вызывает метод
//? тоже самое происходит, когда мы передаем функцию, как колбэк
// https://learn.javascript.ru/object-methods#vnutrennyaya-realizatsiya-ssylochnyy-tip
/*
let obj = {
    name: 'dima',
    f() {
        console.log(this);
    },
}
let obj2 = {
    age: 22,
    f2: obj.f,
};
obj2.f2();   //obj2  мы отделили метод от obj, но вызывает его второй обьект, поэтому obj2


let obj = {
    name: 'dima',
    f() {
        console.log(this);
    },
}
let f = obj.f;
f();   //undefined  мы отделили метод, и вызываем глобально, поэтому контекста нет, это теперь просто функция

setTimeout(obj.f, 1000);   //undefined  т.к. мы отделили метод, надо привязать, чтобы избежать этого
*/

//? this в конструкторе это новосозданный экземпляр обьекта
/*
function User(name, age) {
    this.name = name;
    this.age = age;
    this.f = () => {
        console.log(this);
    }
}
let obj = new User('dima', 22);
obj.f();   //obj

class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    f = () => {
        console.log(this);
    }
}
let user = new User('dima', 22);
user.f();   //user
*/
//? new вызов в конструкторах обязателен!! из за него может теряться контекст!!(проблема для режима не строгого)
/*
new User();
*/

//? bind call apply
//? методы не работают со стрелочной функцией, стрелочной функции нельзя задать контекст через привязку, она будет всегда иметь тот контекст, в котором была создана
/*
class User {
    constructor(age) {
        this.age = age;
    }
    f() {
        console.log(this);
    }
    f2 = () => {
        console.log(this);
    }
}
let a = new User(22);
let b = {
    name: 'dima',
}
a.f.bind(b)();   //b, обычную функцию привязали
a.f2.bind(b)();   //a, потому что стрелочная
a.f();   //a
*/

//? bind жестко связывает функцию с переданным контекстом, создает функцию новую, которую затем надо вызвать
/*
function f(a) {
    console.log(this * a);
}
f.bind(3)(6);
*/









//!====================================================================================================
//? Функции конструкторы
// https://learn.javascript.ru/constructor-new

//? new.target
//? в теле конструктора можно вызвать new.target, с помощью которого можно проверить была функция вызвана через new или нет
/*
function User(age) {
    if (!new.target) throw TypeError('забыл New оператор при создании!')
    this.age = age;
}
*/

//? возврат значения из конструктора
//? если возвращаем обьект, то вернем его, если примитив, то вернем новосозданный экземпляр обьекта

//? если конструктор ничего не принимает, можно опустить скобки вызова(для класса и функций)










//!====================================================================================================
//? Classes Классы
// https://learn.javascript.ru/class
//? Класс - это синтаксический сахар над функцией конструктором
//? Синтаксис класса делает следующее:
//? Создается функция конструктор с именем класса, а ее вызов будет содержать тело constructor
//? Все методы класса записываются в прототип этого класса
//? Все геттеры сеттеры также записываются в прототип этого класса
//? Свойства класса создаются при вызове оператора new, то есть они находятся именно в самом экземпляре класса

//? В итоге в прототипе класса A.prototype будет содержаться функция конструктор(constructor) и все методы объявленные в этом классе
/*
class A {
    constructor(age) {
        this.age = age;
    }
    sayAge() {
        return this.age;
    }
}
let agedPerson = new A(22);
*/




//?====================================================================================================
//? Наследование классов
// https://learn.javascript.ru/class-inheritance
//? Вот пример того, что методы записываются в прототип класса, а свойства в экземпляры
/*
class A {
    constructor(age) {
        this.age = age;
    }

    sayAge() {
        return this.age;
    }
}

let a = new A(22);
let a2 = new A(100);

a2.age = 123213213;
console.log(a.sayAge());   //22
console.log(a2.sayAge());   //123213213

a2.__proto__.sayAge = function () {   // тут я переопределил метод именно в прототипе класса A, а значит он поменялся у обоих созданных обьектов
    return 'а вот хер там, верну строку';
}

console.log(a.sayAge());   //'а вот хер там, верну строку';
console.log(a2.sayAge());   //'а вот хер там, верну строку';
*/
//? Тут я перезаписываю метод в прототип наследуемого класса
/*
class A {
    constructor(age) {
        this.age = age;
    }

    sayAge() {
        return this.age;
    }
}
class B extends A {
    constructor(age, name) {
        super(age);
        this.name = name;
    }
    sayAge() {
        return `${this.age} перезаписал, он теперь в прототипе класса B`;
    }
}
let b = new B(22, 'Alex');
console.log(b);
console.log(b.sayAge());   //`${this.age} перезаписал, он теперь в прототипе класса B`; потому что метод записался в прототип класса B и перезаписал предыдущий, до предыдущего нет доступа
*/


//? После extends разрешены любые выражения
//? Синтаксис создания класса допускает указывать после extends не только класс, но любое выражение. Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от многих условий и затем наследовать их.
/*
function f(phrase) {
    return class {
        sayHi() { alert(phrase) }
    }
}
class User extends f("Привет") {}
new User().sayHi(); // Привет
*/


//? Если мы хотим достучаться до родительского класса и вызвать у него свойство или метод, нам нужно обратиться через super к свойству или методу
//? Также в конструкторе вызов super() вызывает из прототипа конструктор родительского класса
//? То есть грубо говоря вызовом super мы обращаемся к родительскому классу



//? У стрелочных функций нет super
//? т.к. у обычных функций контекст undefined, то и super не отработает
/*
class A {
    constructor(age) {
        this.age = age;
    }
}
class B extends A {
    constructor(age, name) {
        super(age);
        this.name = name;
    }
    sayAge() {
        setTimeout(function () { console.log(super.age()) }, 1000);   //такое не запустится
    }
}
*/







//?====================================================================================================
//? Статический свойства и методы
// https://learn.javascript.ru/static-properties-methods













//!====================================================================================================
//? Symbol символы
// https://learn.javascript.ru/symbol

//? символы никогда не равны друг другу, даже если задать одинаковое описание
//? символы одинаковы, если они заданы глобально через Symbol.for и имею одно и то же описание, в других случая всегда разные
/*
let id1 = Symbol("id");
let id2 = Symbol("id");
alert(id1 == id2); // false
*/

//? символы не преобразуются в стороки сами по себе, если мы хотим их вывести, нам надо явно самим преобразовать их toString

//? можно получить описание символа через description
/*
let a = Symbol('id');
console.log(a.description);
*/


//? скрынтность свойства
//? обратиться к свойству в обьекте, которое записано через символ можно через []
/*
let a = Symbol('id');
let obj = {
    [a]: '1',
}
console.log(obj[a]);
*/


//? for in не перебирает свойства - символы
//? Object.keys(obj) не видит их также
//? Object.assign() копирует абсолютно все свойства
//? Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами
//? Reflect.ownKeys(obj) который возвращает все ключи объекта, включая символьные


//? Symbol.for  глобальные символы
//? если мы хотим использовать глобально символы, мы можем определить их и обращаться через описание символа, и нам гарантированного вернется один и тот же
//? если его не было, мы записали в переменную а символ с описанием, и если он уже создан, мы берем символ из глобального пространства и записываем в b, а значит они равны
/*
let a = Symbol.for('id');
let b = Symbol.for('id');
console.log(b == a);
*/
//? но так мы можем получить только глобальные символы, ниже код уже не сработает
/*
let a = Symbol.for('id');
let b = Symbol('id');
console.log(b === a);   //false
*/


//? Symbol.keyFor
//? получить описание символа по символу, работает только для глобальных символов
/*
let a = Symbol.for('id');
let b = Symbol('id');
let c = Symbol.for('id');
console.log(Symbol.keyFor(a) === Symbol.keyFor(c));   //true, 2 глобальных символа имеют одно и то же описание
console.log(Symbol.keyFor(b));   //undefined, не глобальный символ
*/









//!====================================================================================================
//? Работа с примитивами. Почему у примитивов есть методы?
// https://learn.javascript.ru/primitives-methods

//? при вызове "." у примитива js создает обьект, у которого есть все методы, которые мы можем использовать(например toFixed), как только мы вызываем метод этот, js удаляет обьект и возвращает примитив

//? также можно создавать примитив через new, но это крайне не желательно, т.к. при таком создании мы создаем обьект, а не примитив, а следовательно это может привести к ошибкам
/*
let a = new String('');
if (a) {
    console.log(a);
}
*/



//? null/undefined не имеют методов, попытка вызвать свойство приведет к ошибке











//!====================================================================================================
//? Числа
// https://learn.javascript.ru/number

//? большие числа можно записать через "e"
/*
let a = 1000;
let b = 1e3;
a === b;    //true


let c = 1e-4;   //0.0001
*/

//? неточности вычислений
//? в формате IEEE 754 всегда такая ошибка, поэтому надежный способ, округлять числа до нужного количества знаков после запятой
/*
alert( 0.1 + 0.2 == 0.3 );   //false
alert( 0.1 + 0.2 );   //0.30000000000000004
*/

//? isNaN вернет true, если это не число, почему нельзя использовать сравнение с NaN?, потому что NaN не равен ничему другому, даже себе NaN===NaN   //false
/* isNaN(NaN);   //true */

//? isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным
/*
console.log(isFinite(12));   //true
console.log(isFinite('23'));   //true
console.log(isFinite('23fsd'));   //false
*/


//? Второй аргумент parseInt(str, radix), мы можем задать, в какой системе счисления мы ищем числа в строке









//!====================================================================================================
//? String строки
// https://learn.javascript.ru/string

//? можно использовать спецсимволы, например перевод строки "\n"

//? строки можно перебирать через for of

//? обращаться к определенном символу можно через [] или через str.charAt(), если не будет значения в первом случае вернется undefined, во втором пустая строка









//!====================================================================================================
//? Array массивы

//? это обьект по сути, поэтому также копируется по ссылке

//? перебор массива    https://learn.javascript.ru/array#perebor-elementov
//? for..of работает только с теми типами данных, для которых задан Symbol.iterator!!!
//? for..of рекомендуется или for обычный

//? for in тоже можно, но если наш массив является каким то массивом с допольнительными свойствами и методами, они также будут включены в перебор, в отличии от for of

//? массивы преобразуются к строке по своему
//? пустой массив будет ''
//? если он не пуст, то значения его преобразуются в строку, а затем сконатенируются в одну строку

//? Array.isArray()
//? проверяет это массив или нет, потому что typeof вернет обьект


// https://learn.javascript.ru/array-methods#bolshinstvo-metodov-podderzhivayut-thisarg
//? в функции перебора массива(filter, и т.д) можно передать последний аргумент thisArg, который установит this в функции на переданный











//!====================================================================================================
//? Итерируемые перебираемые обьекты     Symbol.iterator
// https://learn.javascript.ru/iterable
// https://www.youtube.com/watch?v=7wtbNNiOh30&ab_channel=%D0%92%D0%BB%D0%B0%D0%B4%D0%B8%D0%BB%D0%B5%D0%BD%D0%9C%D0%B8%D0%BD%D0%B8%D0%BD

//? Symbol.iterator
//? метод с помощью которого есть возможность перебирать массивы, map, set, строки, а также все те обьекты, где используем этот метод, через for..of, Array.from, spread.


//? Важная оговорка!
//? Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
//? Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.

//? Symbol.iterator - функция, которая возвращает обьект с методом next, который возвращает обьект с полями done, value. Каждый раз итератор увеличивается на один и возвращает следующее нужное нам значение, пока верно условие

//? если мы создали класс с методом итерации и потом наследуемся от него, то метод итерации пожно перезаписать









//!====================================================================================================
//? Map Set
// https://learn.javascript.ru/map-set

//?====================================================================================================
//? MAP
//? Map может содержать в виде ключей все, что угодно и обьекты и т.д; в отличии от обьекта хранит ключи в том порядке, в каком они были записаны

//? в Map можно задавать только итерируемые значение, который содержат ключ-значения
/*
new Map([
    [1,1],
    [true, false],
    [name, 'dima'],
]);
*/

//? Map from object
//? сначала нужно перевести обьект в массив массивов Object.entries, и затем создать Map
/*
let obj = {
    name: 'bla',
    age: 22,
    gdsf: 'sdfsdf',
    '1': '1',
};
let map = new Map(Object.entries(obj));
*/

//? Object from entries
//? можно вызвать на Map entries метод и затем результат запихнуть в Object.fromEntries
/* Object.fromEntries(map.entries()) */


//? Методы
//? map.set(key, value) – записывает по ключу key значение value
//? map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует
//? map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false
//? map.delete(key) – удаляет элемент по ключу key
//? map.clear() – очищает коллекцию от всех элементов
//? map.size – возвращает текущее количество элементов

//? map.keys() – возвращает итерируемый объект по ключам
//? map.values() – возвращает итерируемый объект по значениям
//? map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of
/*
for (const iterator of map.keys()) {
    console.log(map.get(iterator));
}
*/


//? Map from array
//? сначала массив надо перевести в entries, и затем создать map
/*
let arr = ['Dima', 22, true, 'not married'];
let map2 = new Map([...arr.entries()]);
console.log(map2);
*/

//? Array from Map
//? вроде как нет методов нормальных, только через перебор и пуш в массив
/*
let arr = ['Dima', 22, true, 'not married'];
let map2 = new Map([...arr.entries()]);   ||   let map2 = new Map(Object.entries(arr));

let arrFromMap = [];
for (const iterator of map2) {
    arrFromMap.push(iterator[1]);
}
console.log(arrFromMap);
*/



//?====================================================================================================
//? SET
//? set хранит только уникальные значения


//? Методы
//? set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set
//? set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false
//? set.has(value) – возвращает true, если значение присутствует в множестве, иначе false
//? set.clear() – удаляет все имеющиеся значения
//? set.size – возвращает количество элементов в множестве

//? методы перебора те же, что и у map


//? Set from Object и обратно
/*
let obj = {
    name: 'bla',
    age: 22,
    gdsf: 'sdfsdf',
    '1': '1',
    'name': '123123',
    'age': 100
}
let set = new Set(Object.entries(obj));   //создал set
console.log(Object.fromEntries(set));   //снова в обьект
*/

//? Set from array
//? в отличии от Map, Set можно создать из простого массива, и сразу удалить все повторявшиеся значения
/*
let arr = [1, 3, 4, 4, 4, 4, 4, 4, 'dima', 22];
let set = new Set(arr);
console.log(set);
*/










//!====================================================================================================
//? WeakMap WeakSet
// https://learn.javascript.ru/weakmap-weakset

//? WeakMap - не предотвращает удаление свойства, если ключом выступал обьект, который был удален из кода. Т.е. если мы удалим обьект, то он пропадет и их weakmap
/*
let obj = { name: 'dima' };
let wMap = new WeakMap().set(obj, 'обьект');
obj = null;
console.log(wMap.get(obj));   //undefined
console.log(wMap.has(obj));   //false
*/

//? У него есть только след. методы:
//? weakMap.get(key)
//? weakMap.set(key, value)
//? weakMap.delete(key)
//? weakMap.has(key)

//? потому что чистщик мусора может удалить сразу обнуленный обьект, а может потом удалить разом сразу несколько обьектов для оптимизации, поэтому в разное время могут быть разные значения в этой структуре данных




//? WeakSet
//? может содерждать в себе только обьекты
//? имеет то же самое поведение, что и WeakMap











//!====================================================================================================
//? Деструктуризирующее присваивание
// https://learn.javascript.ru/destructuring-assignment

//? можно вытащить по отдельному индексу значение и сразу присвоить в переменную, можно также пропустить ненужные значения
/*
let arr = [1, 2, 3, 'alex', 4];
let [one, two, , name] = arr;
console.log(one, two, name);
console.log(arr);
*/

//? Деструктурирующее присваивание не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные

//? можно сразу присваивать в обьект
/*
let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');
alert(user.name); // Ilya
*/

//? можно также установить значения по умолчанию
/*
let [one = 1, two = 2] = [];
*/




//? Деструктуризация с обьектами
//? если мы из обьекта вытаскиваем другой обьект, из которого нам также надо вытащить свойство, то обьект будет недоступен, т.к. мы деструктуризируем его значение
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};

let { name = 'Alex', age, secondObj: { one, two } } = obj;   //secondObj не будет доступен
console.log(name, age, one, two);
console.log(obj);
*/

//? также можно менять на ходу название переменной
/*
let obj = {age: 22};
let {age: NewAge} = obj;
*/

//? важный момент, заранее если объявить переменные, нужно будет при деструктуризации блок кода обернуть в ()
/*
let obj = {
    name: 'Dima',
    age: 22,
};
let name, age;
({ name, age } = obj);   //без скобок будет ошибка, т.к. компилятор посчитает, что это отдельный блок кода
console.log(name, age);
*/











//!====================================================================================================
//? Date Дата
// https://learn.javascript.ru/date
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date










//!====================================================================================================
//? JSON
// https://learn.javascript.ru/json
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON

//? JSON поддерживает следующие типы данных:
//? Объекты { ... }, Массивы [ ... ]
//? Примитивы: строки, числа, логические значения true/false, null

//? Важное ограничение: не должно быть циклических ссылок.


//? есть всего 2 метода
//? stringify - парсит в json формат
//? принимает еще 2 параметра(Массив свойств для кодирования или функция соответствия function(key, value)) и (Дополнительное пространство (отступы), используемое для форматирования.)
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
console.log(JSON.stringify(obj));
*/

//? parse - достает обьект из json
//? функция может принимать 2 параметр, функцию по преобразованию значений
/**
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
console.log(JSON.parse(JSON.stringify(obj)));
*/


//? также можно использовать комбинацию методов для глубокого копирования
/*
let obj = {
    name: 'Dima',
    age: 22,
    secondObj: {
        one: 1,
        two: 2,
    },
};
let newObj = JSON.parse(JSON.stringify(obj));
obj.secondObj.one = 'изменил';
console.log(obj);
console.log(newObj);
*/

//? toJSON
//? можно реализовать метод в обьекте, который будет вызывать при преобразовании обьекта в json, это тоже самое что и valueOf и toString
/*
let room = {
    number: 23,
    toJSON() {
        return this.number;
    }
};
console.log(JSON.stringify(room));
*/