/*РЕМАРКА*/
/*
В имени пользователя Windows не должно быть русских букв и пробелов, только дефис , нижнее подчеркивание и english
*/





/*ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ */
/*
Если к файлу html подключить несколько файлов js, то переменная, объявленная в файле, который подлючен первее, эта
переменная будет доступна в файлах, которые подключены позднее, чем первый.
То есть переменная первого файла доступна в следующих, а переменные последующих файлов не доступны в предыдущем.
*/

/*IMPORT EXPORT */
/*
IMPORT и EXPORT же берут именно те переменные и данные, которые нужны, которые запрашиваются.
Путь к файлу прописывается относительно файла в котором мы пишем код!


Export default имеет одну особенность, если импортировать функцию имеющую название например Header, а мы ее
импортируем с именем другим, например Abrakadabra, то все равно мы получим функию Header, только переименованную,
такая особенность default export. Мы как бы переименовываем экспортируемый данные. То есть в переменную Abrakadabra
запишется что то, что экспортируется по умолчанию из Header.
Поэтому надо следить за этим внимательно, может немного сбить с толку это.
*/






/*КОНСОЛЬ */
/*
сменить диск:  просто поставить в консоли имя диска и двоеточие.  c: или d:
сменить папку:  cd и путь до папки или файла. cd это change directory. Directory - это каталог.
подняться на уровень выше: cd ..
*/





/*CSS  SASS SCSS*/
/*
Схлопывание отступов при margin. Отступы схлопываются, берется значение большего отступа у соседей. Если у
одного оступ 40px а у другого 20px в этом же направлении, то берется отступ бОльшего.
*/






/*NodeJS */
/*
NodeJS - платформа, для воспроизведения JavaScript, также , как и Browser, а также других разных модулей, таких как
превращение sass в css, перезагрузка сайта при сохранении файла и т.д. Все эти программы работаю в среде Node,
поэтому он должен быть установлен на ПК.

NodeJS может работать с файлами, базами данных, памятью, либо поставить его в микроконтроллер и написать программу,
которая будет обслуживать холодильник(сигналить, когда дверь открыта, температуру поддерживать и т.д

Почему его называют серверным JS, потому что одна из программ, которые можно написать на JS и запустить в Node -
это программа, которая будет принимать запросы HTTP от Browser, формировать ответы и возвращать его.
Handle HTTP requestes, короче говоря, можем написать програмный сервер, который написан на JS и работает в Node.

NodeJs Packages Manager - каталог программ, которые работают в среде Node(преобразование sass в css, перезагрузка
сайта при сохранении файла и т.д.). NPM устанавливает сразу вместе с NodeJS
Эти пакеты облегчают жизнь разработчикам

NPX это тоже самое, только с помощью этого запускаются некоторые программы, а не просто устанавливаются


УСТАНОВКА
https://nodejs.org/en/
Качаем и устанавливаем
*/





/*REACT */
/*
УСТАНОВКА
npx create-react-app my-app
cd my-app
npm start

Наша папка проекта my-app является пакетом NodeJS после создания, следовательно именно поэтому мы можем и запускаем
наш проект с помощью команды npm start.
Файл package.json говорит нам о том, что папка является пакетом, модулем NodeJS.
Npm start запускает модуль, который работает в NodeJs, и запускает сервер для разработки development server.

Внутри create-react-app уже есть babel и webpack
Папка node_modules это все нужные нам для работы модули NodeJs, зависимости и т.д.
*/




/*LOCAL STATE SETSTATE */
/*
setState функция ассинхронная:
let calc=()=>{
    console.log(this.state.some);
    this.setState({some: !this.state.some});
    console.log(this.state.some);
}
Консоль лог выведет один и тот же результат, то есть сначала выполнится функция calc, а затем только поменяется
state, из за ее асинхронности.

setState может принимать callback с предыдущим значением.
 let incr = async () => {
        setState(prevstate => prevstate + 1);
        setState(prevstate => prevstate + 1);
        setState(prevstate => prevstate + 1);
        setState(prevstate => prevstate + 1);
}
btn.onCLick(incr);
При клике на кнопку без предыдущего состояния setstate отработал бы всего лишь один раз, в этом же вызове он отра-
батывает все 4 раза;
*/




/*Метод жизненного цикла компонента */
/*
ComponentDidUpdate(prevProps, prevState){}
Вызывается при получении новых props или state. Есть один подводный камень: если в этом методе идет обновление
state, то мы можем получить бесконечное обновление state. Для предотвращения пишутся условия, что новые props или
state не равны прерыдущим.
*/






/*
Single Page Application SPA
Это маленькая полупустая страница, в которой с помощью JS динамически создается контент.
Например при переходе на новую как бы страницу(фактически URL меняется, но не переходит на другую страницу, как на
обычном сайте) на SPA JS делает запрос на сервер, получает ответ, и на основе ответа создает контент
динамически, т.е. без перезагрузки всей страницы.
Т.е. при переходе с одной страницы на другую, старый контент HTML стирается, а новый рисуется на основе
ответа с сервера.

То есть с сервера в SPA приходит мало HTML контента, но приходит много JS кода, который уже динамически меняет
контент на странице, при получении новых данных, переходах на разные URL.

100 пользователей тут делают запрос на сервер и получают пустой HTML и JS код, в котором уже идет запрос на сервер
и делается запрос для получения данных, на основании которых строится DOM, т.е. сам сайт. Да, нужно еще сделать 100
запросов на сервер для данных, но они приходят в формате JSON и очень мало весят, это намного снижает нагрузку на
сервер. И затем уже JS просто перерисовывает страницу без перезагрузки! ФАНТАСТИКА!

В обычном же сайте приходит много HTML, и мало JS кода. То есть весь контент страницы уже создан и не меняется
динамически, как его создали, так и все, он уже не меняется по сути. Если перейти на другую страницу, мы делаем
запрос на сервер и получаем новый HTML файл и переходим на другой URL.
100 пользователей тут делают запрос на сервер и сервер всем создаем HTML файл, кладет в него информацию и данные,
подключает JS и отдает этим 100 пользователям эти данные. Нагрузка на сервер большая.
*/







/*
JSX
Это язык программирования, который позволяет писать HTML внутри JS.
При сохранении файла компилятор переводит этот язык в чистый JS.
*/






/*
COMPONENT КОМПОНЕНТ - это функция, которая возвращает разметку JSX, внутри может быть какая то логика, но по итогу
она возвращает разметку JSX.

Классовая или функциональная?
Если компонент служит только для отрисовки, то функциональная, т.к она потребляет меньше ресурсов.
*/






/*CLASSNAMES LIBRARY */






/*
SCSS, CSS MODULE модуль
import './style.css';
Пример: у нас 2 компонента, в которых используется один и тот же класс "item". При собирании проекта, в каждый
компонент приходит свой css файл, в котором используется класс "item", то по итогу, этот класс "item" будет
глобальным и они будут конфликтовать между собой. Нет никакой инкапсуляции.

Чтобы была инкапсуляция и этот класс "item" не конфликтовал между другими классами, мы должны прописать в
названии css файла следующим образом и ипортировать его
"style.module.css";
import classes from './style.module.scss';
мы импортируем обьект classes в котором ключ будет наш класс "item", а значением будет уже скомпилированный
переименованный класс, который сделал react.
Например: classes == {
    item: 'item_react_updated-class',
    названиеИзCssФайла: 'updated_name_by_react',
}
то есть при подлючении стилей к элементу, нужно будет:
<div className={classes.item}></div>
либо деструктурировать ключи из обьекта, чтобы не писать постоянно classes, и просто прописать ключи
let {item} = classes;
<div className={item}></div>
*/






/*
REACT ROUTER DOM
npm i react-router-dom --save

import {BrowserRouter, Route, Redirect, withRouter,Switch} from 'react-router-dom';
import {Link, NavLink} from 'react-router-dom';

<BrowserRouter/>
<Route exact path='/someUrl/:someparametr' component={someComponent}/>
Нужен этот модуль для того, чтобы можно было перелинковываться, переключаться между компонентами с
изменениями URL, но без перезагрузки страницы
для этого нужно обернуть приложение в <BrowserRouter/>, а сам компоненты, которые мы хотим отрисовать
нужно поместить в <Route path='/someUrl' component={someComponent} render={()=><someComponent {...props}/>/>
можно заменить аргумент component на функцию render, где в callback отрисовать компонент
Exact пишется, если мы хотим, чтобы компонент рисовался только ПРИ ТОЧНОМ совпадении url, если будет отклонение
то компонент не отрисуется
Route следит за совпадением URL, если совпадение есть - рисует компонент. Если адрес изменился, то Route стирает
компонент, и ждет следующего совпадения.
Например тут, если в <Link to='/someUrl/1'/> уже не отрисуется, так как в Route есть
exact и путь to уже отличается от path.

:someparametr можно указать, чтобы в оббьекте match params достать можно было это значение, когда совпадет url,
то есть мы можем запушить где то в url url адрес новый, указав путь к route, и через слэш будет записан параметр
в params, который мы записали в route.
Но для этого нужно обернуть компонент в withRouter, там, где мы хотим использовать match.


<Link to='/someUrl/'/>
<NavLink exact to='/someUrl/' activeClassName={someClass}/>
Чтобы получить доступ к компоненту в Route, нужно использовать компонент Link или NavLink.
У компонента NavLink есть одно преимущество перед Link, это то, что можно указать активный класс при
клике на него. NavLink сравнивает url с атрибутом to и если есть совпадени добавляет нужный нам класс.
ВАЖНО!!! По умолчанию добавляется класс 'active'! То есть если мы используем css.module, все наши
классы переименовываются в более усложненные, чтобы не было конфликтов между разными css.module
файлами. Получается класс, который добавляет NavLink по умолчанию мы сможем использовать только в
обычном css файле без module, если мы его пропишем в module.css, то он просто переименуется и все.
Поэтому в activeClassName можно прописать нужный нам собственный класс импортированный из module.css,
да и по большому счету вообще любой, просто помните про добавление класса по умолчанию.

Помимо этого можно указать также и обычный класс через className.

exact будет отображать активный класс только если совпадение URL идентичное.



Redirect
<Redirect to='/someUrl/'/>
Редирект насильно перекидывает на адрес определенной страницы. Это можно использовать, например, когда пользователь
не авторизован, постоянно его перекидывать на страницу логинизации.



withRouter
withRouter это HOC, который принимает компонент, в который мы хотим передать location, history, match, без него
компонент не имеет доступа к ним.



ФИШКА ИНТЕРЕСНЫЙ ФАКТ ОСОБЕННОСТЬ:
Когда мы кликаем на один и тот же Link, и компонент, на который этот линк ведет подключен через withRouter,
будет постоянно срабатывать метод рендер и didUpdate и следовательно shouldUpdate.


Switch проходится по url и выбрасывает первое совпадение.
Максимально точные url ставятся сверху, максимально общие ставятся в самом низу.
 <Switch>
    <Route path='/users/followed' render={Component} />
    <Route path='/users/' render={Component} />} />
</Switch>
*/






/*ОШИБКИ ERRORS */
/*
Async await errors ошибки обрабатываются с помощью try catch.
*/







/*ОПТИМИЗАЦИЯ ОБНОВЛЕНИЯ SHOULDCOMPONENTuPDATE */
/*
Оптимизировать нужно, тк. перерисовка трудоемкое занятие. Например: есть конетейнерная компонента
let Container=(props)=>{
    return(
        <Users {...props.users}/>
        <Posts/>
    )
}
let mapStateToprops=(state)=>{
    return{
        users: state.users,
    }
}
и она отрисовывает 2 компоненты, но пропсы прокидывает только в одну из них users. То есть Container перерисовывается
каждый раз при изменении users в state. НО! следовательно будут перерисовываться и дети, НО! Posts не зависит от этих
данных, и зачем надо тогда его перерисовывать? Для этого и нужна оптимизация, мы сами решаем в каком случае перерисовывать
компонент.


shouldComponentUpdate хук, принимающий nextProps nextState nextContext и возвращает boolean value. Мы сами определя
ем когда компоненты стоит обновляться. Для оптимизации он существует.
Банальный пример: когда мы кликаем на один и тот же Link, и компонент, на который этот линк ведет подключен через withRouter,
будет постоянно срабатывать метод рендер и didUpdate и следовательно shouldUpdate. В таком случае, если мы пропишем
хук, то рендер не будет происходить лишний раз.
Но если написать this.props === nextProps, это не сработает, т.к. это 2 РАЗНЫХ обьекта в памяти. То есть нам нужно
кокретно достучаться до отдельных свойств пропсов и их сравнивать.
Важный пример:
state={
    profilePage: {
        users:{[],[],[]},
        status: 'привет, мир',
    }
}
<Component {...state}/>
this.props === nextProps вернут false т.к. это 2 разных обьекта, но внутри profilePage ссылается на один и тот же
обьект, если он не был изменен. Вот его можно сравнить, если он как то мутируется. Или можно сравнить users,если
они должны мутироваться, но если обьект не изменяется, то и сранвить нет смысла, т.к это один и тот же обьект.

Если нам лень писать хук, можно сделать наследование класса от React.PureComponent, но тут важный момент, этот
компонент, будет проверять только ПОВЕРХНОСТНО обьекты. Т.е. в примере выше, мы передали как пропс весь state,
значит он будет сравнивать только profilePage, а мы его если не мутировали, а изменяли только status или users,
то он не заметит этих изменений, т.к. profilePage остался тем же, поменялись внутренности.
Копирование по ссылке, эта тема оттуда.
Значит чтобы правильно отрабатывал этот компонент, нужно, чтобы сравниваемые свойства, лежали сверху и были
доступны сразу компоненту для сравнения.Если мы изменяем users или status, и хотим их проверять на новизну, то
нам нужно именно их и передать в компонент, а не весь profilePage передавать.
<Component {...state.profilePage}/>
И тогда компонент поверхносто сравнит пропсы, в них будут users и status и именно их мы будем изменять по событиям
и pureComponent сравнивать.

Если компонент функциональный, то используется React.memo(someComponent);
let View=React.memo((props)=>return(component));
Тут логика такая же, как и в PureComponent, сравнение идет поверхностное, сравниваются только вернхний свойства и
все, в глуббь не идет сравнение. Т.е. если мутируемый обькт в глубине, а в пропсах сидит его родитель, то сравнение
будет неверным т.к. родитель остался тот же, а именно он и сравнивается, а ребенок в сравнение не попадает.
Вторым аргументом может принимать функцию сравнения и тут логика обратная shouldComponentUpdate, те. возвращаем true,
когда не нужно обновляться компоненту.
let compareProps = (prevProps, nextProps) => {
    if (prevProps.aboutMe === nextProps.aboutMe) {
        return true
    } else {
        return false
    }
}
*/









/*
React.Ref Ref CreateRef Ссылка на элемент
Можно создать ссылку на элемент, чтобы не получать через QuerySelector, так как в react запрещены прямые взаимодей
ствия с DOM.
Нужно минимизировать работу с ними, можно считывать значения, но ИЗМЕНЯТЬ НЕЛЬЗЯ НАПРЯМУЮ. Это убивает принцип
работы reacta.

Например: нам нужно по клике на кнопку получить значение input, и передать их в функцию.
1)Создаем ссылку:
let elementRef = React.createRef();
2)В HTML элемента указываем ссылку на него:
<input ref={elementRef}/>
3) По клику мы обращаемся к ссылке на элемент и берем значение current, а уже в нем находим нужное свойство
элемента, как в обычном js.
<button onClick=()=>{console.log(elementRef.current.value)}/>
*/






/*
КОНТЕЙНЕРНАЯ КОМПОНЕНТА
Служит для обертки обычной компоненты, и обеспечивает обычную презентационную компоненту логикой, данными и т.д.
То есть в контейнерной компоненте содержится логика и затем просто возвращает презентационную компоненту, которая
получает все данные в виде props'ов. Делается это для того, чтобы не загрязнять презентационную компоненту, чтобы
можно было, например, ее переиспользовать где то еще раз.
Она должна быть чистой! То есть в нее приходят пропсы и все, внутри нет никакого взаимодействия с сервером,
redux'ом и т.д. Внутри могут быть методы только по визуализации и т.д.
Все логика по redux и серверу выносится в контейнерную компоненту.
*/







/*
REACT CONTEXT
let state = {};
Создаем контекст. Обертываем приложение в контекст и пишем Provider, куда в атрибут value указываем то, что хотим
передать во все приложение. Обязательно value!!! Если назвать по другому - работать не будет.
let MyContext = React.createContext(null);
<MyContext.Provider value={state}>
    <App/>
</MyContext.Provider>

Там, где нужно воспользоваться контекстом, мы оборачиваем компоненту, в которую мы хотим поместить контекст, мы
оборачиваем ее в Consumer и внутри него вызываю функцию, которая возвращает компоненту, которой
необходим контекст.
Если то место, где мы вызываем Context функциональный компонент, то синтаксис такой:
Передали в виде props'а context value, value и есть наш контекст.
<MyContext.Consumer>
    {(value)=>{
        return <SomeComponent context={value}/>
    }}
</MyContext.Consumer>

Если же компонент классовый, то привязываем контекст с помощью static contextType и вызываем его просто
обратившись через this.context.
class SomeComponent{
    static contextType = RestoServiceContext;

    render(){
        return(
            <View context={this.context}/>
        )
    }
}
либо
SomeComponent.contextType = RestoServiceContext;


let withContextHOC=(Component)=>(props)=>{
    <MyContext.Consumer>
        {(value)=>{
            return <Component context={value} {...props}/>
        }}
    </MyContext.Consumer>
}
*/




/*HOC НОС Компоненты высшего порядка */
/*
Компоненты высшего порядка нужны для того, чтобы вынести определенную логику, которая будет повторяться во многих
компонентах в отдельную контейнерную компоненту. Т.е. HOC это функция, которая принимает целевой компонент в роли
аргумента и возвращает Контейнерую компоненту.

let withSomething=(Component)=>(props)=>{
    return <Component {...props}/>
}
let withSomething=(Component)=>{
    return class extends React.Component{
        render(){
            return <Component {...this.props}/>
        }
    }
}
export default withSomething(COMPONENT);

Если мы, например, хотим внутрь прокинуть еще state, т.к. на state завязана логика определенная, то с помощью
connect, нам нужно контейнерную компоненту обернуть в connect connect(mapStateToProps)(withSomething(COMPONENT)),
НО!, если таких будет много компонентов, это неудобно в каждом файле писать такую конструкцию, поэтому этот
функционал можно занести внутрь HOC'a и получившуюся контейнерную компоненту при вызове HOC, обрунть в connect :
let withSomething=(Component)=>{
    let containerComponent=(props)=>{
        return <Component {...props}/>
    }
    return connect(mapStateToProps)(containerComponent);
}
export default withSomething(COMPONENT);
То есть мы инкапсулировали логику по прокидыванию state внутрь HOC'a, а также обернули целевую компоненту
контейнерной, в которой можем использовать одинаковую логику для всех целевых компонент.



Если в одном файле мы подключаем слишком много HOC'ов, то это становится очень неудобно читать код, что во что мы
оборачиваем.
пример:
let Component =(props)=>{};
export default connect(mapStateToProps)(withRouter(withSomething(Component)));

Для этого можно использовать функцию compose из redux.
export default compose(
    connect(mapStateToProps),
    withRouter,
    withSomething,
)(Component);
Эта функция принимает в первом вызове HOC'и, а во втором целевой компонент.
HOC'и передаются снизу вверх, то есть, если мы хотим сначала вызвать первым withSomething, то он в самом низу,
затем вызовем withRouter, и только потом connect.

*/







/*КЛАССОВЫЕ КОМПОНЕНТЫ */
/*
Нужны для создания однотипных обьектов на базе этих классов. И в дальнейшем для реализации ООП подходов.
Инкапсуляция, полиморфизм, наследование.

extends Component пишется для того, чтобы мы могли отрисовать классовый компонент, без наследования обычный класс
не умеет ничего рендерить и взаимодействовать с react'ом.(например методы жизненного цикла, state, и т.д).
*/







/*VIRTUAL DOM */
/*
DOM это HTML, который преобразуется браузером и создается DOM(объектная модель документа), браузер создает обьекты
на основе HTML. JS же работает уже внутри DOM и взамодействует не с HTML, а с DOM.
Объектная модель документа это множество обьектов, который создал браузер.
Т.е. когда мы,например,пишем команду document.getElementById(), мы взаимодействует не c HTML,а с DOM обьектом,
мы находим обьект в DOM дереве.
Каждый тэг это обьект и на базе этого обьекта браузер создает визуализацию, то, что мы видим.
HTML же это просто гипертекстовая разметка, язык разметки.


React. Он превращает JSX в JS, а затем превращает в VIRTUAL DOM. Это тоже набор обьектов, немного упрощенная версия
обычного DOM.
Работа реакта. Создается VDOM и на основе его создается DOM. Тут ничего не обычного, магии нет. Затем, при второй
отрисовке, например пользователь что то нажал, создается вторая версия VDOM, и сравнивается уже REACTOM старый
и новый VDOM. И заменяет обьект старый новым, если есть изменение. И на базе этих изменений идет в DOM и меняет
именно этот элемент, точечно меняет, не перерисовывая весь DOM.

*/







/*
FLUX архитектура FLOW
Это круговорот данных в приложении.
Сначала данные(state) приходят в UI, затем в UI происходит действие, данные перезаписываются в state, затем снова
идут в UI, и на основе измененных данных при действии в UI изменяют UI. Круг замкнулся.
Однопоточная система передачи данных.
НАПРИМЕР: (пример реальный но тупой))
В input я написал значение, но не отправил его в state, так делать нельзя, потому что UI зависит только от state
и нельзя его менять напрямую без изменения state.
*/



/*
ACTION CREATOR это функция, которая возвращает обьект ACTION, который отправляется в store.
ACTION это обьект у которого есть свойство TYPE, как минимум. И он dispatch'ится в store, где уже
вызывается нужный метод изменения state.


SUBSCRIBE концепция
В первом файле у нас state. После изменения state нужно отрисовать DOM заново, но у нас нет этой функции, она в
файле index.js, в самом главном файле. Нам надо пробросить функцию render в state, чтобы вызвать ее там, но
напрямую мы не можем сделать этого, потому что в главный файл приходит state, получится циклическая зависимость, а
это не хорошо. То есть при обновлении state нужно вызвать как то render.
Выход следующий:
Объявляем функцию updateDom в файле state, она же будет вызываться при необходимости обновления DOM после изменения
state.
В файле, где лежит state  мы обьявляем функцию subscribe, которая принимает в роли callbacka другую функцию,
назовем ее observer и при ее вызове updateDom присваиваем значение observer.
Subscribe экспортируем в главный файл и там вызываем ее и прокидываем в роли callbacka функцию render. При вызове
subscribe с функцией render в файле state функция обновления DOMa(updateDom), которую мы вызываем после изменения
state, она примет значение rendera из главного файла. То есть мы пробросили функцию render в другой файл вызвав
subcribe.
Логика такая же, как передача функций в роли props'ов в React.
При вызове subscribe изменить значение функции обновления DOM в state и все, при изменении state, будет вызываеться
уже функция пришедшая как callback(observer) в subscribe функцию.

То есть при вызове subscribe, в файле где она объявлена она будет искать переменную в которую надо присвоить
значение пришедшее при вызове, будет искать внутри себя, затем выйдет на уровень выше и найдет его, и изменит
значение на пришедшее в observer. А затем уже измененное значение переменной можно будет использовать в файле, где
оъявлена функция subscribe.


REDUX REDUCER
Это функция, которая принимает state и action, а после возвращает новый state, если action.type подошел, либо старый -
если action.type не подошел.


REDUX STORE my vesrion logic
Мы вызываем из UI actionCreator при нужне(клик, и т.д), этот actionCreator возвращает обьект action, который мы
dispatch'им в store. В dispatch же, вызывается reducer, reducer'ов может быть много, каждый отвечает за определенную
часть state'a, и изменяет его, в reducer приходит action и state, и если action.type подошел, в reducer мы изменяем
пришедший state в роли аргумента, и возвращаем уже новый state, если type не подошел, то вернем старый state.
Т.е. после вызова в dispatch reducer'a, мы заменяем определенную часть state'a новой частью после отработки
reducer'a, и вызываем метод обновления DOM (subscriber).
Мы в index.js подписываемся на изменение state через функцию subscribe. В моем примере redux мы специально
создавали функцию отрисовки DOMa и назвали ее RENDERDOM, в ней содержалась вся структура приложения. Т.е. получить
#root и ReactDOM.render(весь контент). Это и есть RENDERDOM. И мы вызывали ее для инициализации, а затем ее
передавали как аргумент подписываясь на изменения в state.

ВАЖНО!ПОДВОНЫЙ КАМЕНЬ!
Если у нас в разных файлах ТИП ACTION будет одинковый, вызовет ошибку, по этому к типу добавляют путь до этого
reducer'a , куда он должен дойти.
*/




/*
REDUX
УСТАНОВКА
npm install redux react-redux --save
npm i redux-thunk --save


import reduxThunkMiddleware from 'redux-thunk';

import { createStore, combineReducers, bindActionCreators, compose} from 'redux';

Создаем store с помощью createStore, в которую передаем reducer или их множество.
Если много reducer'ов, то объединяем их с помощюю combineReducers в которую передается обьект из этих reducer'ов.
По выходу state получаем через store.getState() и если при вызове combineReducers не указывать нужные нам ключи,
получится обьект с ключами, совпадающими именами reducer'ов, если же нужны свои какие то ключи, то просто указываем
свой ключ со значением reducer нужного нам.
Например:
let reducer1=(state, action)=>{};
let reducer2=(state, action)=>{};\
В state будем иметь доступ через ключи keyOne, keyTwo, если не указать их, а просто передать reducer'ы, то будем
иметь доступ через имена reducer'ов.
let reducers = combineReducers({
    keyOne: reducer1,
    keyTwo: reducer2,
});
let store = createStore(reducers, applyMiddleware(reduxThunkMiddleware));
*/







/*REDUX-THUNK */
/*
УСТАНОВКА
npm i redux-thunk --save
import reduxThunkMiddleware from 'redux-thunk';


Компонента не должна делать запросы к серверу, она должна быть чистой в идеале. Зависит только от BLL, она только
передает намерения пользователя в BLL и все, может передавать text, который ввел пользователь, но никакие
сторонние запросы на сервер делать она не должна в идеале. Она должна передать BLL, что пользователь хочет ,например,
загрузить пользователей, а BLL уже сам будет думать, как это сделать.
Для этого есть Thunk'и.

Thunk - это функция, которая внутри себя dispatch'ит action'ы в store, может делаеть запросы к серверу, и в
зависимости от результата выполнения dispatch'ит определенные action'ы в store.
То есть мы должны задиспатчить thunk функцию store, но store изначально не умеет вызывать функции, он только умеет
раскидывать по reducer'ам action'с. Для этого нужна прослойка middleware. И при создании store через createStore,
вторым аргументом вызывается функция applyMiddleware(reduxThunkMiddleware), которая и создает прослойку для
обработки санок.

Логика работы такая: из UI мы диспатчим санку в reduxThunkMiddleware, если эта функция видит, что это action
задиспатчен, а не санка, то она reduxThunkMiddleware диспатчит ее в store и этот action отрабатывает, как обычно;
если же reduxThunkMiddleware видит, что это санка, т.е. это пришла функция, то reduxThunkMiddleware вызывает ее,
и внутри санки уже прописана логика определенная, но главное, затем снова в санке идет диспатч уже action'ов, они
снова попадают в reduxThunkMiddleware и оттуда уже reduxThunkMiddleware диспатчит их в reducer'ы. Может быть также,
что внутри санки лежит другая санка, и этот круговорот будет продолжаться, пока все action'ы внутри не отработают.
Если внутри есть асинхронные операции, то они выполняются в middleware а затем снова происходит dispatch.

Санку мы диспатчим в store, так же через connect функцию, но мы ее не вызываем, как action, это тоже самое,
мы вызываем санку, если это thunkCreator, функция, которая возвращает санку, и эту вернутую санку мы уже
диспатчим.
Санка не может принимать никакие дополнительные параметры, санка принимает только диспатч, и он вызывается, когда
мы прокидываем функцию через connect.Чтобы санка могла получить доп. параметры, мы ее оборачиваем в thunkCreator,
это функция, которая принимает параметры и возвращает thunkCreator, который уже имеет доступ к этим параметрам из за
замыкания функций.

Если мы в connect прокидываем санку через bindActionsCreator, она не сработает, потому что bindActionsCreator
при работе с actionCreator'ами делает следующее:
он возвращает функцию, при вызове которой происходит dispatch actionCreator'а , getUser: (a,b)=>dispatch(AC(a,b)),
вот что вернется после работы bindActionsCreator;       А при работе с санкой она вернет: функцию, при вызове
которой просиходит:  getUser: ()=>dispatch(thunk()), а нужно, чтобы была следующая
структура: getUser: ()=>dispatch(thunk), то есть thunk мы не должны вызывать, это должен сделать сам thunkMiddleWare
, а делает bindActionsCreator, из за этого косяк. Поэтому если используем bindActionsCreator, то санки нужно
обернуть в thunkCreator, чтобы getUser: ()=>dispatch(thunk()) вернула санку, которая уже и диспатчится в
middleWare. Thunk тут это creator и вызов вернут обычную санку, которая диспатчится в middleWare.

Thunka по дефолту возвращает undefined. Можно вернуть любое нужное нам значение включая промис.
*/





/*
REACT-REDUX
import {Provider, connect} from 'react-redux';

<Provider store={store}>
    <App/>
</Provider>
В Provieder оборачивается все приложение и передается атрибут store в который помещается store.
Чтобы в каком то компоненте получить store из provider, нам нужно этот компонент вызвать с помощью функции connect.

import {someActionCreator} from './actioncs';

let Component =(props)=>{
    let {name, surname, addAge} = props;

    return{
        <div onClick={()=>{addAge(22)}}>{name, surname}</div>
    }
};

let mapStateToProps=(state)=>{
    return{
        name: state.name,
        surname: state.surname,
    }
}
let mapDispatchToProps=(dispatch)=>{
    return{
        addAge: (value)=>{
            dispatch(someActionCreator(value));
        }
    }

    return bindActionCreators(actions,dispatch);
}
export default connect(mapStateToProps, mapDispatchToProps)(Component);

mapStateToProps - функция, которая берет state из store, САМА берет его, когда мы передаем эту функцию в connect,
connect сама передает state в функцию, она умная. И mapStateToProps возвращает обьект с данными, которые идут
в компонент в роли props'ов. Имена из обьекта должны совпадать с теми, что используются в компоненте.
В этом примере mapStateToProps есть подвох: если мы в компонент передали бы ВЕСЬ state без дробления на name и
surname, то при любом изменении state(будь то мы поменяли просто name), в reducer мы вернули бы весь state и
connect увидел бы, что это абсолютно новый state и отрисовал бы компонент полностью, что сказывается на производи-
тельности. Поэтому дробление немного лучше, т.к connect сравнивал бы именно эти параметры по отдельности и
перерисовывал бы компонент только если какой то параметр отличается.
mapStateToProps сравнивает именно те значения, которые мы достали из него, в данном случае name и surname.Именно
их и сравнивает mapstatetopros каждый раз.
Connect функция каждый раз подписывается на изменения в state, и она каждый раз перерисовывает все дочерние
компоненты, она зависит от изменений данных, которые сидят в mapStateToProps.


mapDispatchToProps - функция, в которой мы берем actionCreator и оборачиваем его в dispatch, то есть возвращаем
обьект с функциями уже обернутыми в dispatch. Имена из обьекта должны совпадать с теми, что используются
в компоненте.
Вместо функции можно передать либо один actionCreator, либо обьект actionCreator'ов в connect, a connect сам
обернет их в dispatch.
Эти 2 ф-ции можно назвать как угодно, connect сам определит, что с ними делать при передачи их в connect.


В connect можно также не передавать ничего, он сам засунет туда dispatch(из props'ов можно достать потом)
автоматически, а самим уже в самой компоненте обернуть actionCreator в dispatch.

connect отрисует презентационную компоненту, обернутую в конейнерную.


ОБНОВЛЕНИЕ КОМПОНЕНТЫ CONNECT
Subscribe подписка просиходит автоматически при изменении state.
Этим занимается Provider и connect.
При каждом вызове connect происходит подписка этого компонента , где он вызван на изменения, и каждый раз
вызывается функци mstprops и сравнивает предыдущие значения и новые, и если изменились - перерисовывает.
При каждом изменении state ф-ция connect запускает mapStateToProps и сравниваем предыдущие значения state с
нынешними, и если есть изменения, то перерисовываем компонент.
MapStateToProps запускается при абсолютно любом изменении в state, даже если это изменение никак не связано с этой
функцией и измененнные данные в этом mapStateToProps не используются, все равно она запускается.

Например, если есть в state какой то массив, и нам нужно в него поместить еще одно значение, нам нужно помимо копии
state, скопировать этот массив, чтобы убрать ссылку на него, и только тогда connect будет
считать, что это разные массивы, потому что до этой копии было бы сравнение по ссылке.

То есть, нам нужно копировать ТОЛЬКО ТЕ значения, которые мы поменяли в UI и хотим увидеть эти изменения.
Например: в reducer есть массив с постами и текстовым значением. В UI мы изменили текстовое значение, значит в
reducer мы ДОЛЖНЫ изменить ТОЛЬКО текстовое значение, посты можно оставить теми же, то есть оставляем ссылку на них.
Connect видит те же самые посты, потому что осталась та же ссылка и перересовывает только текстовое значение, т.к.
только оно и изменилось.
Если же ситуация обратная, нужно изменить посты: то нам нужно скопировать посты, connect видит, что посты
это уже новый массив, т.к. ссылка изменилась, и connect перерисовывает ТОЛЬКО посты, не затрагивая другие места
компоненты.

Но в любом случае, сначала нужно скопировать сам STATE поверхностно, потому что connect сравнит предыдущий state
и нынешний и увидит, что это ОДИН И ТОТ ЖЕ ОБЬЕКТ и не отрисует ничего нового.
Поэтому копируем сам state тоже  return {...state}
Например:
state ={
    posts: [1,2,3,4],
    text: 'привет',
}
например нужно изменить только посты!
reducer(state, action)=>{
    switch(action.type){
        case: 'SOME':
        let newPost = 5;
            return{
                ...state,
                posts: [...state.posts, newPost],
            }
        default:
            return state;
    }
}
То есть мы копируем все остальное как есть, без изменений, а изменяем только посты. И connect видит новую ссылку на
массив и перерисовывает его.
*/




/*REACTSUSPENSE LAZYLOADING */
/*
const ProfileContainer = React.lazy(() => import('./components/profile/profileContainer'));
Затем оборачиваем эту компоненту в Suspense и в fallback передает компонент, который мы хотим показать пока
главный компонент загружается.
<React.Suspense fallback={<Spinner/>}>
    <ProfileContainer/>
</React.Suspense>
Делается эта ленивая загрузка, чтобы минифицировать начальное запрашивание файлов с сервера. Т.е. с ленивой
загрузкой мы будем подргужать компоненты по надобности и все.


Делается это для того, чтобы подгружать js по мере надобности и не грузить сразу ВЕСЬ бандл файлов. Потому что мб
пользователь и не пойдет дальше первой страницы. А мы его томим длительным ожиданием.
*/






/*PROPS CHILDREN ДЕТИ */
/*
Children это все, что мы пишем между открывающим и закрывающим тегом. Это може быть текст, функции, массивы и т.д.

*/








/*REDUX FORM */
/*
Установка
npm install redux-form --save

import { reducer as formReducer } from 'redux-form';
let reducers = combineReducers({
    some: someReducer,
    form: formReducer,
});
Этот импорт помещается в combineReducers и обязательно должен иметь имя form.

import { reduxForm, Field } from 'redux-form';
reduxForm это HOC, вызывается 2 раза.
export default reduxForm({ form: 'login' })(someFormComponent);
в первую функцию передается имя этой конкретной формы, во втором вызове сама компонента, сама форма передается.


Для отслеживания submit на форме, есть обработчик внутри props, прокидываемый HOC'ом, называется handleSubmit,
мы вешаем onSubmit={props.handleSubmit} на форму, а затем СНАРУЖИ на сам компонент вешаем такой же обработчки
onSubmit, но в который мы уже передаем весь нужный нам функционал, handleSubmit вернет обьект с данными из формы.
А мы уже снаружи будем их обрабатывать.
<form onSubmit={props.handleSubmit}></form>
Снаружи же <Form onSubmit={myFunction}></Form>
в myFunction придет обьект formdata по именам из формы. handleSubmit прокидывает его в функцию onSubmit пришедшую
сверху.


<Field component='input' type="text" placeholder={'Login'} name='email' validate={[required, maxLength15]}/>
Field это замены всех инпутов, selectod, кроме кнопок; обязательно имя и компонент, который мы хотим отрисовать.
В него вместо component='input' мождно передать рендер функцию, которая примет все проспсы из Fielda и которая
вернут нужный нам HTML, а не просто какой то элемент.
Например:
renderInput = (props) => {
    let { input, meta, placeholder, className,} = props;
    let { error, active, visited } = meta;
    let hasVisitedAndErrod = (error && visited) || props.errorSubmit;
    let classInput = (hasVisitedAndErrod && !active) || props.errorSubmit ? errorClass : null;
    return (
        <input type={type}
            {...input}
            placeholder={placeholder} />
    )
}



ИЗМЕНЕНИЕ ЗНАЧЕНИЯ ФОРМЫ ПРИ ВВОДЕ
На форму вешается обработчик onChange={}, в который из пропсов приходит функция change, в которой можно изменить
значение формы по имени поля.
props.change('name', value => {
    if (value.length >= 300) {
        return value.slice(0, 300);
    }
    return value;
});
вариант при вводе с проверкой на длину.
props.change('name', 'somevalue');
Это должно передаваться как колбэк функция, то есть вызывется именно ПОСЛЕ ИЗМЕНЕНИЙ.


ВАЛИДАЦИЯ VALIDATE INPUT ИНПУТЫ
В Field передается атрибут validate={[validator, validator2]} в который передается массив из валидаторов, и эти
валидаторы вернут undefined если все хорошо, либо вернут ошибку, при несоотвествии с заданными параметрами в этой
функции.
Валидаторы мы создаем сами.
НАПРИМЕР
export const required = (value) => {
    if (value) return undefined;
    return 'Field is required';
}
export const maxLengthCreator = (length) => (value) => {
    if (value && value.length > length) {
        return `Max length is ${length}`;
    }
    return undefined;
}
let maxLength15 = maxLengthCreator(15);
И все, при ошибках в каждом отдельном Field будет свой state со своими свойстави, ошибками, был ли элемент посещен
или нет и т.д.



АСИНХРОННАЯ ВАЛИДАЦИЯ ПРИ ВВОДЕ
На компонент вешается asyncValidate={myValidateFunction}. myValidateFunction возвращает промис, в котором если что
то не так выкидывается ошибка throw {'имя поля': 'значение ошибки'}, если все ок, то ничего не возвращает.
в myValidateFunction приходит 3 аргумента: name, value, trigger, где name обьект со всеми именами инпутов формы.
По другому эту функцию можно передать в reduxForm({asyncValidate: myValidateFunction});



STOPSUBMIT
Обработка ошибки после запроса на сервер:
import {stopSubmit} from 'redux-form';
В экшн креатор первым аргументом передается название нашей формы, имя, под которым мы экспортировали форму с помощью
reduxForm, а вторым аргументом передается обьект с ошибками. То есть в него мы передаем название элементов, имена,
под которыми они записаны, сами Field'ы, и ключи это имена, значения это описание ошибки, и по итогу форма подсветит
ошибочные инпуты.
Если мы хотим ВСЮ форму сделать ошибкой, то нужно передать обьект со свойством _error, и это значение придет в форму
как пропс. props.error. а после уже его можно использовать в самой форме и прокидывать вниз, в сами Fields. Fields
же при этом не будут иметь собственную ошибку, она будет undefined.

dispatch(stopSubmit('login', { _error: "Проверьте email и логин еще раз, вы допустили ошибку", }));

*/





/*RESELECT СЕЛЕКТОРЫ SELECTORS*/
/*
УСТАНОВКА
npm i reselect --save
import { createSelector } from 'reselect';

SELECTOR это функция, котора принимает state и возвращает определенную нужную нам часть этого state. Вызывается в
методе mapStaetToProps.
Примеры:
let state = {
    users: [{ id: 1, online: true }, { id: 2, online: false }, { id: 3, online: false }, { id: 4, online: true },
    { id: 5, online: true }, { id: 6, online: true }, { id: 7, online: true }, { id: 8, online: false },],
}
let getUsers = state => state.users;

Эти функции нужны для облегечения, т.к. когда много файлов и везде получаем один и тот же параметр из state не
удобно прописывать код по вытаскиванию свойств из state, поэтому мы пишем просто функцию selector, которая делает
это внутри себя и вызываем ее в разных файлах.
MapStateToProps при любом изменении state будет вызывать эту функцию и получать один и тот же результат и сравнивать
это значение с предыдущим, и потом решать, надо отрисовать или нет, если значение изменилось.

Теперь рассмотрим сложный вариант:
селектор, который делает определенную логику, считает что-то, фильтрует, мапит, и т.д.
let getOnlineUsers = (state) => {
    return getUsers(state).filter(item => item.online === false);
}
Эта функция будет возвращать постоянно новый массив при вызове mapStaetToProps, хотя может быть, что mapStaetToProps
был вызван соовсем другими изменениями в state. Получается, что мы зря создали новый массив, а следовательно
напрасно была перерисовка UI, т.к. входные данные в этот селектор не изменились, а выходные создали новый массив
и UI перерисовался.

Чтобы решить эту проблему, нужно создать селектор с помощью библиотеки.
export const getUsersFiltred = createSelector(getUsers, (users) => {
    return users.filter((user) => user);
});
getUsersFiltred(state);
Эта же функция создает селектор, который принимает все тот же state, НО!, теперь она зависима от простого селектора,
который мы передали, как первый аргумент, и на основе его выполнения библиотека сравнивает старое значение и новое
и если они равны, то возвращает все тоже старое значение и не производит, например, именно тут фильтрацию.
Если же в зависимости от просто селектора возвращается новое значение, то выполняется callback функция, которая
делает определенную логику и возвращает новое значение, и следственно перерисовывается UI.
CreateSelector нужен только для сложных селекторов, в которых происходит логика определенная.
Селекторы, от которых зависит сложный селектор могут передаваться в массиве, а в колбэк передаются результаты
выполнения в той последовательности, в которой они были записаны в массив.


Логика работы reselect. При первом срабатывании записывается в кэш данные, которые к нам пришли, от которых зависит
селектор, и при последующих пришедшие данные просто сравниваются, если они - исходные данные не поменялись, то
селектор вернет кэшированные данные. Если же исходники изменились то идет пересчет , работа селектора и возвращается
новое значение которое снова записывается в кэш и затем уже вернется оно, если исходники придут снова те же ,что и
в предыдущий раз.


Проблемы селекторов: при каждом изменении state мы вызываем селекторы и достаем какие то данные из state. Проблема
пока что в том, что дебажить неудобно т.к. мы каждый раз попадаем в функцию селектор, если в нем происходят
лишние вычислиния засоряем память, пускай немного, но все равно изменения нас не коснулись а мы все равно считаем
заново.
И самый главный минус, это если селектор возвращает НОВЫЙ массив или обьект, например после фильтрации, даже если
изменение не касается нашего компонента, а был где то в другом месте все равно mapdispatchtoprops запустит
селектор и он вернет ДРУГОЙ МАССИВ ОТФИЛЬТРОВАННЫЙ НО! нам не нужно было его фильтровать, т.к мы зависим от
конкретного изменения, а функция запускается каждый раз и каждый раз возращает новые данные и происходит перерисовка.

*/






/*ИНИЦИАЛИЗАЦИЯ ПРИЛОЖЕНИЯ INITIALIZE */
/*
При инициализации мы делаем определенные запросы на сервер и т.д. всякие ассинхронные операции, и мы можем обернуть
их все в promise и после всех промисов проинициализировать приложение.
*/




/*
СТРУКТУРА ПРИЛОЖЕНИЯ
ReactDOM.render(
    <Provider store={store}>
        <ErrorBoundry>
            <Context.Provider value={restoService}>
                <BrowserRouter>
                    <App />
                </BrowserRouter>
            </Context.Provider>
        </ErrorBoundry>
    </Provider>
    , document.getElementById('root'));
*/






/*КОПИРОВАНИЕ ОБЬЕКТОВ */
/*
Обьекты создаются в памяти и в переменных хранятся ССЫЛКИ на обьекты.
let a ={
    name: 'Dima',
    obj: {
        age: 22
    }
}
Здесь в памяти создается 2 обьекта. Ссылка на а обьект хранится в переменной а, на obj хранится в переменной a.obj.
И когда мы присвоим переменной значение обьекта, мы не скопируем обьект, а лишь передадим ссылку на него в памяти.
То есть при изменении значения в одном обьекте, мы изменим его и в другом, а по факту мы изменим один и тот же
обьект.


Обьекты не могут быть равны друг другу, если это не один и тот же обьект(то есть если они скопированы по ссылке,
то они равны).
let a = {
    name: 'Dima'
}
let b = a;
console.log(a === b); //true

*/





/*API */
/*
API это интерфейс взаимодействия с программой. Методы, обьекты, то, с чем мы взаимодествуем. Методы обьекта ,
интерфейс программного приложения.
*/
/*SERVER REST API */
/*
GET - POST - PUT - DELETE (CRUD - create, read, update, delete).
Есть разные endpoint'ы(ресурсы) с которыми мы взаимодействуем http-запросами. Сервер там сам определяет, что мы
хотим сделать. Т.е. мы шлем на один и тот же адрес разные методы, а сервер сам определяет и делает то, что мы хотим.
То есть сейчас есть адрес один './google.com/users/' на который мы делаем запросы.

Раньше же существовало несколько endpoint'ов './google.com/users/get', если получить, './google.com/users/post',
если создать и т.д. Что дико не удобно.
Endpoint это URL на которые мы можем слать запросы.


GET запрос
В запросе например мы хотим указать количество возвращаемых данных в ответе или номер страницы возвращаемой:
https://social-network.samuraijs.com/api/1.0?page=2&size=5
page=2&size=5, вот это идет после вопросительного знака в запросе, и означает это get query параметры. Все эти данные
мы берем с бэкенда, т.е. page на бэкенде может быть записано по другому и нужно узнавать у бэкэндщиков правильное
написание запроса.

API сервера это интерфейс с которым можно взаимодействовать.
Url куда шлем запросы
Методы взаимодействия с ним
Request payload То что мы должны слать на сервер
Response data То что мы должны получить с сервера
HTTP коды, ответы сервера
*/







/*СТИЛЕЗАЦИЯ БЛОКОВ ОТДЕЛЬНЫХ IBG*/
/*
Вариант стилезации background изображения через аттрибут style. Если нет главной картинки, загружаем картинку
по дефолту, а background изображение можно настроить в css очень легко и отзывчиво с помощью paddinga задать размер
картинки.
<div style={{ backgroundImage: `url(${large || emptyBigPhoto})` }} className={content_img}></div>
*/







/*CORS COOCKIE ПЕЧЕНЬКА */
/*
COOCKIE файл, который цепляется для передачи на сервер при любом запросе.
Например логинизация. Мы отправляем запрос на сервер с паролем и логином, и нам возвращается coockie в которую
сервер записал наш ID в закодированном виде, если мы переходим например во вкладку сообщения, то мы отправляем с
запросом coockie в котором уже есть ID наш и сервер говорит, да, это ты, ты залогинен, и отдает сообщения, которые
нам принадлежат.
Запомнить меня это время жизни coockie условно говоря. Т.е. без нее живет пол часа после завершения сессии, с ней
допустим месяц.


Браузер не отправляет coockie если идет кросс доменный запрос.
Нужно указывать дополнительные параметры, чтобы разрешить передавать cockie.
В axios нужно установить в axios вторым аргументом обьект с настройками, в котором withCredentials = true, также там
можно установить headers: {}.
*/





/*PURE FUNCTION (ЧИСТАЯ ФУНКЦИЯ) */
/*
Иммутабильность. Чистая функция не мутирует пришедшие в нее данные напрямую, только через return чего то.
Нет sideeffect. Не меняет снаружи ничего и не использует глобальные переменные, ассинхоронщины нет.
Идемпотентность. Если приходят одни и те же данные - всегда вернет один и тот же ответ.
Вернуть обязательно результат.
*/








/*ИНТЕРЕСНОСТИ БАГИ FAILS */
/*
ФУНКЦИЯ ПО УВЕЛЕЧЕНИЮ COUNTER при скролле страницы срабатывает только один раз. Имеем функцию, которая при условии
увеличивает counter на один.
let incr=()=>{setCounter(state+1)};
document.addEventListener('scroll', incr);
И она срабатывает только ОДИН РАЗ, ХОТЯ ВСЕ ОСТАЛЬНОЕ РАБОТАЕТ. Дело в том, что при назначении функцию на обработку
браузер запомнил именно первый вариант state. Т.е. когда мы прибавляем во второй раз 1, и думаем , что оно
увеличется, нет!) Там в этой функции все также сидит изначальный варинт. для решения нужно удалить старый обработчик
и добавить после изменения state новый, перезаписать его
*/











/*TYPESCRIPT REACT*/
/*
УСТАНОВКА НОВОГО ПРИЛОЖЕНИЯ
npx create-react-app my-app --template typescript


УСТАНОВКА В СУЩЕСТВУЮЩИЙ ПРОЕКТ
npm install --save typescript @types/node @types/react @types/react-dom @types/jest
Могут быть ошибки, что не распознает импорты react router doma и т.д, для этого и нужно устанавливать дополнительно
@types/react-router-dom и другие расширения.
*/


