//!================================================================================================================================================
//? /Components/Компоненты/
// https://angular.io/guide/lifecycle-hooks

// https://habr.com/ru/company/infopulse/blog/358860/       обнаружений изменений
// https://habr.com/ru/post/327004/

//? @Component декоратор используется для пометки компонентов, наследуется от декоратора директивы
//? Все компоненты, которые мы хотим использовать в модуле, должны быть объявлены в модуле

//? Принимает обьект настроек:
//? 1) changeDetection
//? 2) encapsulation
//? 3) selector
//? 4) styles - стили в строку компонента
//? 5) stylesUrls - ссылки на стили         Стили также можно подключать через link, в шаблоне компонента
//? 6) template - верстка в строку
//? 7) templateUrl - ссылка на верстку
//? 8) providers массив сервисов доступных для инжектирования вниз по дереву





//?================================================================================================================================================
//? /ChangeDetection//стратегии обнаружения изменений/

//? 1) Default - компонент реагирует на все изменения внутри себя(любые абсолютно, промисы, таймеры и т.д.) и в родительских компонентах. Также реагирует на изменения пропсов, даже если это обьект а ссылка остается той же. Т.е. если мы изменяем свойство обьекта в родительском, то в дочернем будет отрисовано изменение
//? Такой цикл называется грязной проверкой. Суть проверки заключается в том, что Angular сравнивает новые значения со старыми и обновляет представление если они не равны

//? 2) OnPush - компонент реагирует на изменения локальных переменных, если это обьект, то все равно будет сравнивать значения свойств(даже если обьекты вложенны глубоко)
//? Перестает реагировать на изменения свойств обьекта входящего через пропсы. Сравнивается ссылка. Если же в родителе изменить свойство обьекта, которое используется в шаблоне дочернего, то изменение будет отрисовано только после запуска цикла обнаружения изменений
//? Изменение локальных переменных в таймерах и вообще в любой асинхронщине также не запускают обнаружений изменений. По факту переменная в классе изменится, но отрисовки не будет. Поэтому если у нас в таймере был counter = 10, он не отрисуется, но зато после цикла обнаружения изменений значение будет рассчитываться от данного, которое не отобразилось
//? цикл из дочернего комонента может запусить обработчик события

//? Чтобы отслеживать асинхронные изменения, нужно инжектировать ChangeDetectorRef и вызывать методы соответствующие.
//? 1) markForCheck - помечает явно, как измененный компонент, чтобы его проверить снова
//? 2) detach - отсоединяет компонент от проверок. Он ничего не будет отрисовывать, пока его снова не подключить или вызвать метод detectChanges(при отключенной проверки, хук onChanges все равно будет запускаться в компоненте)
//? 3) detectChanges - обнаружить изменения локально. Обнаруживает даже если осоединено от обнаружения изменений, а также, если на входящий обьект не изменена ссылка
//? 4) reattach - заново включает в циклы обнаружения изменений
// TODO 5) checkNoChange -


//? Геттеры в шаблоне вызываются при каждом цикле обнаружения изменений, чтобы они не вызывались, нужно компонент отсоединить от проверок





//?================================================================================================================================================
//? /LifecycleHooks/Хуки жизненного цикла/
// https://angular.io/guide/lifecycle-hooks

//? У каждого компонента есть хуки жизненного цикла:
//? 1) ngOnChanges вызывается, когда есть Input в компоненте, именно, когда мы в шаблоне прокидываем параметр из родителя без него не будет вызываться. Вызывается каждый раз при изменении входных данных, если входной параметр это обьект, то хук сработает только при изменении ссылки на входной обьект

//? 2) ngOnInit вызывается при создании компонента. Именно тут должна быть сложная логика инициализации компонента, в конструктор ее помещать не нужно, т.к. компонент должен быть очень простым в создании, а тут уже можно запихнуть логику. Максимум, что может быть в конструкторе это присвоение локальных переменных

//? 3) ngDoCheck вызывается при любом цикле обнаружения изменений во всем приложении. Использовать его не желательно

//? 4) ngAfterContentInit вызывается и в родительском компоненте, который прокидывает слоты в дочерний, и в дочернем, который проецирует слоты. Вызывается после вставки содержимого. Также работает в директиве

//? 5) ngAfterContentChecked вызывается постоянно после ngDoCheck в компонентах, где есть проецирование слотов. Также работает в директиве

//? 6) ngAfterViewInit вызывается разово, после отрисовки компонента или директивы

//? 7) ngAfterViewChecked вызывается после ngAfterViewInit и каждый раз после ngAfterContentChecked, а также после любых изменений в компоненте. Работает и в компоненте и директиве

//? 8) ngOnDestroy вызывается перед тем, как фреймворк удалит компонент. Тут помещается логика по отпискам от таймеров, подписок, и т.д, чтобы память не засорять колбэками





//?================================================================================================================================================
//? /Content projection/Проекция контента/ng-content
// https://angular.io/guide/content-projection

//? Если мы хотим спроецировать контент внуть другого компонента, нужно: в дочернем компоненте в нужном месте поместить тэг <ng-content></ng-content>
//? в родительской верстке вызвать дочерний селектор компонента и между тэгов поместить проецируемое значение, оно отобразится на месте ng-content

//? можно в тэге ng-container указать аттрибут [select] в который можно передать значение, по которому будет проецироваться определенный контент
//? например ниже, мы в дочернем устанавливаем 2 контента, с атрибутом и без, и если в родителе мы проецируем контент без аттрибута selected-content, то дефолтный контент отрисуется на месте тэга без аттрибута, а с аттрибутом, на соответствующем месте
/*
дочерний компонент
<ng-content [select]="selected-content"></ng-content>
<ng-content></ng-content>

родительский компонент, в котором мы прокидываем контент в дочерний
<div app-slot-child>
    <div class="default-content">
        Проецируемый контент дефолтный 2: {{value}}
    </div>
    <div class="selected-content" selected-content>
        Проецируемый контент select 2: {{value}}
    </div>
</div>
*/
// TODO





//?================================================================================================================================================
//? /Encapsulation/Инкапсуляция стили/
// https://angular.io/guide/view-encapsulation

//? Каждый компонент, сама оболочка(тэг, либо аттрибут, по которому создается компонент), это называется хост, host.
//? Чтобы применить стили к хост элементу, можно обратиться к нему либо из родителя напрячую по тэгу(аттрибуту специфичному для него), либо в стилях через :host {} селектор, но этот селектор работает, если у нас emulated инкапсуляция


//? Стили, примененные в компоненте в декораторе, при наследовании не наследуются

//? Стили также можно подключать через link, в шаблоне компонента


//? Есть 3 стратегии использования инапсуляции:
//? 1) None - полностью отключена
//? Такие стили будут полностью глобальными. Если в родителе отключена, а в дочернем включена инкапсуляция, то если из родителя обратиться к классу дочернего, можно переопределить стили, т.к. они будут глобальными

//? 2) Emulated(по дефолту) - на каждый компонент добавляется аттрибут уникальный для компонента, именно поэтому аттрибуту в стилях потом добавляется этот аттрибут, и стили становятся скрытыми для каждого компонента(если хост - _host<что то дальше>, если контент внутри хоста - _content<что то дальше>), они генерируются самим фреймворком, и к ним нельзя никогда обращаться в коде
//? При такой стратегии, стили заданные для дочернего хост элемента, можно перебить из родительского, просто обратившись в дочернему хосту, т.к. родительский компонент добавляет на дочерний хост такие же уникальные аттрибуты, что и на свой, именно поэтому можно переопределить только хост дочерний из родительского, внутри вложенные компоненты уже не получится

//? можно использовать host в компоненте(если none, то нельзя), чтобы из родителя достучаться до потомков используется ::ng-deep {} селектор, внутри которого пишутся стили для дочерних

//TODO ? 3) ShadowDom





//? ng-deep может пробить несколько к ряду написанных компонентов(их инкапсуляцию). Он делает этот стиль глобальным для всего проекта. Если мы и используем его, то нужно все таки точечно указывать, в каком селекторе что нам нужно поправить(делать вложенность), и лучше для каждого компонента использовать уникальный класс, также ОБЯЗАТЕЛЬНО использовать его внутри host, т.к. это повышает специфичность

//? host указывает на сам хост элемент, не доступен в none стратегии

//? host-context() - принимает класс из родителя, например .active где то в родительском компоненте, и в дочернем можно использовать его для стилезации





//?================================================================================================================================================
//? /Datapassing/Обмен данными/@Input/@Output/Component interaction/
// https://angular.io/guide/component-interaction
// https://angular.io/guide/inputs-outputs

//? Input декоратор для того, чтобы принимать в себя данные из родительского компонента. Со стратегией обнаружения onPush работает только при изменении ссылки
//? Данный декоратор можно использовать с геттером и сеттером, либо только с сеттером. При изменении входящих параметров, будет отрабатывать сеттер и будет происходить логика нами заложенная. Можно передать как аргумент имя аттрибута по которому компонент будет принимать данные




//? Output декоратор нужен для отправки события в родительский компонент
//? Создается свойство через EventEmitter украшенное декоратором, затем в компоненте есть обработчик события, на который мы эмитим событие
//? В родительском компоненте мы слушаем это созданное событие как обычный обработчик через (), а в саму функцию, которая будет вызвана эмиттером, придет $event значение, которое и содержит переданные данные из дочернего компонента. Можно передать как аргумент имя аттрибута по которому компонент будет отдавать данные




//? ViewChild
// https://angular.io/api/core/ViewChild
//? Принимает класс компонента, который мы отрисовываем внутри родительского. Он будет доступен как обычное свойство класса. Можно вызывать методы, и т.д.
//? Ищет в dom первый доступный компонент или директиву с таким классом, как только дом изменится, значение переменной обновится.
//? Важные моменты: если через цикл создаются компоненты, то получим самый первый компонент. Если мы получаем сервис, который объявлен для конкретного компонента в провайдерах, а этот компонент мы перебираем в цикле, то мы все равно получим сервис первого самого компонента из цикла, для остальных в цикле будут созданы другие сервисы

//? Можно использовать с сеттером или вместе с геттером и сеттером

//? Можно получать: через #reference или просто указть имя класса директивы или компонента
//? сервис, передав его класс
//? любой токен для инжектирования в виде строки
//? TemplateRef




//? providers
//? В метаданных компонента providers можно использовать сервис, который будет доступен во всех дочерних компонентах, за пределами этого дерево сервис будет не доступен. Также, если в дочернем компоненте еще раз определить сервис в providers, то этот компонент и все ниже, будут использовать один экземпляр сервиса, а выше, другой. Получится будет много экземпляров сервисов





//?================================================================================================================================================
//? /Dynamic components/Динамические компоненты/
// https://angular.io/guide/dynamic-component-loader
// https://angular.io/api/core/ViewContainerRef
// TODO

//? ViewContainerRef
//? Динамическое обращение с контентом компонента или директивы

//? createComponent
//? Компоненты создаются динамически с помощью ViewContainerRef.createComponent, данный метод вставляет созданный компонент в хост элемент, к которому применен ViewContainerRef





//?================================================================================================================================================
//? /Templates/Шаблоны/
// https://angular.io/guide/interpolation#preventing-name-collisions
// https://angular.io/guide/template-reference-variables

//? В шаблонах можно вызывать функции, вставлять переменные, выражения, получать значения по условию, но нельзя делать какие то присваивания, некоторые операторы es5, инкремент и декремент, и объединять выражения через , или ;


//? Выражения должны быть очень простыми, т.к. они вызываются после каждого цикла обнаружения изменений, поэтому лучше их логику сократить


//? Можно использовать переменные определенный структурной директивой
/*
<ul>
    <li *ngFor="let customer of customers">{{customer.name}}</li>
</ul>
*/
//? Переменные шаблона, тут мы берем инпут и обращаемся к его значению
/*
<div>
    <input type="text" #input (input)="setValueFromInput(input.value)">
    <p>Значение из инпута: {{valueFromInput}}</p>
</div>
*/


//? В шаблоне могут быть одинаковые переменные, ангуляр будет использовать следующую логику для определения контекста, откуда взять переменную
//? 1) Имя переменной шаблона
//? 2) Имя в контексте директивы
//? 3) Имена членов компонента


//? К переменным определенным по вложенности выше(т.е. они являются в родительской области, скажем так) можно обращаться детям ниже по дереву
//? тут пример на одной вложенности, но не совсем, ngIf оборачивает контент в ng-template, поэтому он находися в дочерней области, поэтому можно получить доступ к переменной шаблона
/*
<input #ref1 type="text" [(ngModel)]="ref1Value">
<p *ngIf="true">Значение инпута: {{ref1.value}}</p>
*/


//? Можно объявить переменные входящие, которые зависят от внешних данных, а также можно ссылаться на ng-template
//? можно сослаться на переменную выше объявленную в цикле и переопределить ее, под каким нибудь другим именем будет доступна
/*
<ng-template #hero let-hero let-i="index" let-odd="isOdd">
    <div [class]="{'odd-row': odd}">{{i}}:{{hero.name}}</div>
</ng-template>


тут я ссылаюсь в ng-template на переменную выше объявленную в цикле, так можно переопределять под каким именем будет доступна переменная
<ng-container *ngFor="let name of names;">
    <ng-template let-item="name" #nameRef>
        <div>{{name.name}}</div>
    </ng-template>

    <ng-container [ngTemplateOutlet]="nameRef"></ng-container>
</ng-container>
*/





//? /Binding/Привязка/[]
// https://angular.io/guide/property-binding
// https://angular.io/guide/attribute-binding

//? Привязка - это привязывание изменения свойства класса, к свойству DOM элемента, либо же привязать к пропсу, который принимает дочерний компонент через Input
//? без скобок данное выражение справа будет расценено как обычная строка
/*
<img [src]="itemImageUrl">
*/


//? Также можно привязывать аттрибуты, для этого есть много разных директив, [attr], [class], [style] и т.д.
/*
<p [attr.attribute-you-are-targeting]="expression"></p>
<li [style.color]="'red'">В виде строки конкретный стиль</li>
<li [class.boolean]="true">Привязать конкретный класс вычесленным значением true</li>
*/




//? /Event/События/
// https://angular.io/guide/event-binding

//? Прослушивать события на элементах можно через (), куда в скобки передаем событие, которое будем слушать, либо же пользовательское событие через @Output EventEmitter
//? чтобы получить обьект события, нужно в метод прокинуть $event переменную, зарезервированную ангуляром





//? /2 way binding/Двухсторонняя привязка/
// https://angular.io/guide/two-way-binding

//? Для сокращения кода, можно писать более лакончиную связку одного и того же свойства в родительском и дочернем компонентах
//? для этого нужно в дочернем сделать инпут и аутпут, а аутпут свойсто нужно назвать также как входящее, но добавить обязательно Change к имени, иначе работать не будет

//? Также можно использовать ngModel на инпуте, чтобы при изменении сразу записывать новое значение
/*
Родитель
public twoWayBindValue: any;
public onInputChange(data: string): void {
    this.twoWayBindValue = data;
}

<p>Значение в родителе 2 сторонняя привязка {{twoWayBindValue}}</p>
<input type="text" #inputRef (input)="onInputChange(inputRef.value)">
<div app-binding-child
    [(text)]="twoWayBindValue"
></div>

<h4>NgModel метод</h4>
<input type="text" [(ngModel)]="twoWayBindValue">


Ребенок
@Input() public text: string;
@Output() public textChange: EventEmitter<string> = new EventEmitter();         событие должно быть названо также как свойство входящее + Change

public onChangeInput(event: Event): void {
    this.text = (event.target as HTMLInputElement).value;
    this.textChange.emit(this.text);
}

<p>Значение привязки в дочернем компоненте {{text}}</p>
<input type="text" (input)="onChangeInput($event)"/>
*/










//!================================================================================================================================================
//? /Directives/Директивы/
// https://angular.io/guide/built-in-directives

// TODO






















//!================================================================================================================================================
//? /Pipes//
// https://angular.io/guide/pipes
// TODO













//!================================================================================================================================================
//? /Modules/Модули/NgModule/

//? В приложении есть всегда один главный модуль. В Модуле определяются компоненты, которые определены в данном модуле, сервисы, также в модуль нужно импортировать другой модуль, функционал которого нам необходим в этом модуле. Также модули экспортируют функциональность, чтобы при импорте этого модуля в  другие, мог передать функционал

//? @NgModule декоратор используют для определения модуля











//!====================================================================================================
//? @Injectable DependencyInjection Внедрение зависимостей
// https://angular.io/api/core/Injectable
// https://angular.io/guide/dependency-injection-providers
// https://www.youtube.com/watch?v=fALKYP8voBQ&ab_channel=JavaScript.ru
// https://www.youtube.com/watch?v=u6gAVCEJjQ4&t=860s&ab_channel=devschacht
/*
? логика работы примерно такая: существует некий контейнер(коробка), где лежат все необходимые нам для внедрения сервисы, переменные и т.д, неважно что, и мы при инжектировании зависимостей достаем уже экземпляр класса, эта коробка сама создает внутри себя этот экземпляр и отдает нам его, также она может отдавать не только именно это экземпляр, но и создать другой экземпляр этого же класса.

? в нативном js это работает так: например мы хотим реализовать класс "C", который включает в себя "B", который в свою очередь включает в себя класс "A". То есть при создании самомого верхнего класса по вложенности, который не наименее мало имеет зависимостей, нам нужно будет создать каждый класс из представленных, чтобы внедрить один в другой
? получится, что для "С" нам нужно создать "B", для которого нам также нужно создать "А", а это не очень удобно делать такое каждый раз.
class A {
    log() {
        console.log('HELLO');
    }
}
class B {
    constructor(a) {
        this.a = a;
    }
    log() {
        this.a.log();
    }
}
class C {
    constructor(b) {
        this.b = b;
    }
    log() {
        this.b.log();
    }
}
let c = new C(new B(new A()));
c.log();


? поэтому была придумана DI методология, то есть мы запрашиваем у контейнера какой класс мы хотим внедрить в себя, а он сам под капотом создает зависимости и отдает нам уже готовый класс со всеми ему нужными зависимостями.


? В Angular @Injectable как раз таки указывается для того, чтобы была возможность инжектировать этот класс в другие, и чтобы в этот класс также можно было бы инжектировать другие зависимости.
? Как определять зависимости в ангуляр? В providers в модулях приложения, мы передаем обьект, который содержит ключ, по которому мы будет стучаться до нашей зависимости и значение, то что будет нам отдаваться
? важный момент, если мы указали только "provide", это не значит, что мы получим экземпляр этого класса, т.к. нет значения, если же и значение и имя совпадают, то можно записать коротко, просто название класса и убрать обьект, тогда просто вместо обьекта передадим SomeService(сахар ангуляра)
? provide это токен, по которому будет доставаться значение из коробки

providers: [
    {
        provide: SomeService,
        useClass: SomeService,
    }
]

? В provider можно передавать и классы и любые другие данные.
? в качестве токена(provide), нам необходимо создавать токен, если это не класс с помощью InjectionToken, и получившееся значение указывть тут
? помимо useClass можно использовать:
?       useValue - это любое значение может быть
?       useFactory - функция, в которой мы можем определить когда именно мы будем возвращать данные, можем определить свой конструктор, то есть мы определяем дополнительную логику для внедрения этой зависимости; помимо этого, если мы используем useFactorey, в провайдер мы можем передать "deps" - свои зависимости, которые будут включены в этот наш сервис
?       useExicting - это мы передаем тот класс, функционал которого мы хотим ограничить до функционала того, что указан в "provide", т.е. у нас уже где то выше определен SomeService, и в useExicting мы указываем класс, который похож на SomeService, но расширенный имеет функционал, и мы этот класс ограничиваем до SomeService


? зависимости можно определять в модулях приложения, это будут одни и те же экземпляры обьектов, также мы можем переопределять зависимости на уровне компонентов, мы перезапишем получается глобально доступный сервис локальным. Синтаксис точно такой же, как и в модуле.


? Под капотом ангуляр автоматически инжектирует зависимости указанные в конструкторе класса, которые были расширены с помощью декораторов, ниже запись немного раскрывает, как работает ангуляр под капотом. Эти две записи идентичны, по токену получаем экземпляр класса.
class a {
    constructor(
        private service: Service,
        @Inject(Service) service: Service,
    ) {}
}


?! одно заблуждение у меня было, внедрить зависимость по ИНТЕРФЕЙСУ невозможно, т.к. это только во время разработки существует вещь, внедрение происходит по токену!!!
*/


//?====================================================================================================
//? Injector
// https://angular.io/api/core/Injector-0
/*
? мы также можем сами создавать вручную зависимости через Injector.create , он принимает обьект, где parent - родительский инжектор, name - имя этого инжектора, providers - массив поставщиков
{
    providers: [
        {
            provide: SomeService,
            useClass: SomeService,
        },
        {
            provide: SomeService,
            useClass: SomeService,
        }
    ],
    parent?: Injector,
    name?: string
}
*/



//!====================================================================================================
//* КОМПОНЕНТЫ COMPONENTS  ng g c <name> --skipTests
//?====================================================================================================
//? @Component
//? обьъявляются в модуле в declarations
/*
*changeDetection - определяет тип изменений на которые нужно реагировать шаблону. ChangeDetectionStrategy.Default - реагирует компонент на все изменения, ChangeDetectionStrategy.OnPush - реагирование происходит только на входные свойства, которые пришли, как @Input.

*selector - селектор, под которым используется шаблон компонента

*encapsulation - инкапсулирование стилей. ViewEncapsulation, принимает разные значение по инкапсулированию

*interpolation - можно указать способ интерполирования, свой стиль

*entryComponents - компоненты, которые используется, но в шаблонах нет ссылок на них

*preserveWhitespaces - удалять ли потенциально лишние пробелы из шаблона или нет

*viewProviders - набор компонентов, сервисов, видимых у потомков

*template - шаблон

*templateUrl - ссылка на  шаблон

*styles - стили(массив строк)

*styleUrls - ссылка на стили

*animations - анимации примененные в шаблоне
*/


//?====================================================================================================
//? @Input 
//? https://angular.io/api/core/Input 

//* получить значение в компонент из родительского шаблона
/*
*прокидываем в компонент из родительского шаблона
<custom-component [someValue]="Привет"></custom-component>

*принимаем значение в ребенке
class {
   @Input() someValue: string;
}
*/


//?====================================================================================================
//? @Output
//? https://angular.io/api/core/Output

//* Прокинуть наверх данные, используется EventEmitter, чтобы прокидывать наверх данные. В шаблоне у родителя принимаем их, как обработчик события в (), который принимает $event - в данном случае значение, которое прокинули.
/*
* ребенок
import {EventEmitter, Outpur} from 'angular/core';
class {
   @Output() onEvent: EventEmitter = new EventEmitter();

   onSomeEvent() {
      this.onEvent.emit(someValueToEmit);
   }
}

* родитель
<child-component (onEvent)="someMethod($event)"></child-component>

*/


//?====================================================================================================
//? Переменная шаблона
//? https://angular.io/guide/template-reference-variables
//* <div #ref></div>


//?====================================================================================================
//? EventEmitter
//? https://angular.io/api/core/EventEmitter

//* Существует для прокидывания наверх данных из детей, родителю.


//?====================================================================================================
//? @ViewChild
//? https://angular.io/api/core/ViewChild

//* Получаем доступ к тэгу в компоненте из шаблона.
//* Static true используется, если мы хотим обратиться к ссылке в методе ngonInit, в остальных случая стоит false.
/*
* шаблон
<div>
   <h1 #refOnH1></h1>
</div>

* компонент
import {ElementRef, ViewChild};
class {
   @ViewChild('refOnH1', {
      static: false
   }) element: ElementRef;

   someMethod() {
      this.element.addEventListener();
   }
}
*/


//?====================================================================================================
//? Передача контента в ребенка от родителя ng-content

//* можно передать контент внутрь детского селектора, между детскими тэгами, и в самом шаблоне ребенка вызвать тэг <ng-content></ng-content>, на месте которого появится html из родителя.
/*
*шаблон родителя
<div>
   <child-component *ngFor="let post of posts">
      <p *ngIf="post.text.length > 150; else otherContent">пост длинный</p>

      <ng-template #otherContent>
         <p>пост короткий</p>
      </ng-template>

   </child-component>
</div>

*шаблон ребенка
<div>
   <div></div>
   <div></div>
   <ng-content></ng-content>
</div>

*/



//?====================================================================================================
//? ContentChild
//? https://angular.io/api/core/ContentChild

//* Если мы хотим получить доступ до html, который передан от родителя и получен через ng-content, нужно в компоненте ребенка получить ссылку на этот html через ContentChild.
/*
*шаблон родителя
<div>
   <child-component *ngFor="let post of posts">
      <div #refoncontentformparent>
         <p *ngIf="post.text.length > 150; else otherContent">пост длинный</p>

         <ng-template #otherContent>
            <p>пост короткий</p>
         </ng-template>
      </div>
   </child-component>
</div>

*шаблон ребенка
<div>
   <div></div>
   <ng-content></ng-content>
</div>

*компонент ребенка
import {ElementRef, ContentChild};
class {
   @ContentChild('refoncontentformparent', {static: false}) element: ElementRef;
}

*/




//?====================================================================================================
//? ngClass
//? https://angular.io/api/common/NgClass

//* Принимает обьект, где ключ - имя класса, значение это условие при котором этот класс должен примениться
/*
this.classesValues = {
   'errorClass': this.error,
   'warnClass': this.warn,
}

<div [ngClass]="classesValues"></div>
*/


//?====================================================================================================
//? ngStyle
//? https://angular.io/api/common/NgStyle

//* Принимает обьект, где ключ - имя свойства, значение это условие
/*
this.currentStyles = {
   'font-style':  this.canSave      ? 'italic' : 'normal',
   'font-weight': !this.isUnchanged ? 'bold'   : 'normal',
   'font-size':   this.isSpecial    ? '24px'   : '12px'
};

<div [ngStyle]="currentStyles"></div>

*либо
<div [style.font-size]="isSpecial ? 'x-large' : 'smaller'"> This div is x-large or smaller. </div>
*/


//?====================================================================================================
//? ngModel
//? https://angular.io/api/forms/NgModel

//*Двухстороння привязка, то есть при изменении в шаблоне, меняется компонент и наоборот, нужен импорт FormsModule
/*
<input [(ngModel)]="someValue"/>
*/


//?====================================================================================================
//? ngIf ngFor ngSwitch
/*
? https://angular.io/api/common/NgIf
*Можно использовать условия, а в else установить ссылку на элемент, который будет отображен при неудаче
<app-item-detail *ngIf="isActive; else otherElement" [item]="item"></app-item-detail>
<div #otherElement></div>


? https://angular.io/api/common/NgForOf
*Можно перебирать массивы и обьекты
* trackBy позволяет не перерисовывать все элементы при изменении, тоже самое, что и key в React.
* keyvalue пайп для перебора обьектов
<div *ngFor="let post of posts; let index = index; trackBy: trackByItems">">Номер: {{index}}  {{post.title}}</div>
class {
   trackByItems(index, item){
      return item.id;
   }
}

? https://angular.io/api/common/NgSwitch
*Можно использовать switch для отображения
<div ngSwitch="someValue">
   <p *ngSwitchCase>lorem="value1"</p>
   <p *ngSwitchCase>lorem="value2"</p>

   <p *ngSwitchDefault>lorem="value3"</p>
</div>
*/


//?====================================================================================================
//? ng-container
//* ангуляр не помещает его на страницу, можно использовать для условий, может пригодиться, как пустой тэг


//?====================================================================================================
//? @HostListener
//? https://angular.io/api/core/HostListener

//* Вешается сразу на весь компонент обработчик события, очень удобно таким образом обрабатывать события в директиве, мы просто в самой директиве создаем HostListener'ы и внутри пишем логику
//* 1ый аргумент - событие, 2ой - аргументы передаваемые в обработчик
/*
class{
   @HostListener('click', ['$event']) onClick(e:Event){
      console.log(e);
   }
}
*/


//?====================================================================================================
//? @HostBinding
//? https://angular.io/api/core/HostBinding

//* привязывает свойство элемента сразу к переменной
/*
class {
   @HostBinding('class.activated') someClass = null;
   @HostListener('click', ['$event']) onClick(e:Event){
      this.someClass = 'activated';
   }
}
*/



//?====================================================================================================
//? Динамический компоненты Dynamic components

//* Компонент динамический необходимо зарегать в entryComponents в модуле, это компоненты, которые мы не используем напрямую в шаблоне.


/*
*ng-template тэг, который не будет появлять в DOM
*Пример шаблона, куда мы хотим поместить контент программно, мы указываем директиву modalRef, которая предоставляет ссылку на данный тэг с помощью ViewContainerRef
<ng-template modalRef></ng-template>
<nav class="navbar">
   <h1>Angular Dynamic Component</h1>
</nav>

*Пример шаблона динамического контента, в комоненте еще и реализован Output onCLose
<div class="modal">
   <h1>{{title}}</h1>
   <button class="btn" (click)="onCLose.emit()">&times;</button>
</div>

*ViewContainerRef
*ViewContainerRef представляет доступ к элементу, на котором была вызвана директива, и разные методы по манипуляциям с данным компонентом предоставляет
*https://angular.io/api/core/ViewContainerRef
*Директива для компонента, в конструкторе инжектируем ViewContainerRef
import { Directive, ViewContainerRef } from "@angular/core";
@Directive({
   selector: '[modalRef]'
})
export class ModalDirective {
   constructor(public containerRef: ViewContainerRef) { }
}


*Компонент, где хотим использовать динамическое добавление
*в resolveComponentFactory передается класс компонента, который мы хотим отобразить(просто передаем ссылку импортированную) ModalComponent тут это как раз тот компонент, который мы хотим отобразить(шаблон+компонент)
*через ViewChild получаем доступ к директиве у которой есть ViewContainerRef, с помощью которого и создаем контент на странице createComponent.
@Component({
   selector: 'app-root',
   templateUrl: './app.component.html',
   styleUrls: ['./app.component.scss']
})
export class AppComponent {
   @ViewChild(ModalDirective, { static: false }) modalRef: ModalDirective;

   constructor(private componentFactoryResolver: ComponentFactoryResolver) { }

   showModal() {
      let modalFactory = this.componentFactoryResolver.resolveComponentFactory(ModalComponent);
      let modalCreated = this.modalRef.containerRef.createComponent(modalFactory);
      modalCreated.instance.title = 'Dynamic title!';
      modalCreated.instance.onCLose.subscribe(() => {
         this.modalRef.containerRef.clear();
      });
   }
}
*/


//?====================================================================================================
//? Создание мета тэгов
/*
? можно устанавливать title сайта динамически через Title, а также добавлять мета тэги
import { Title } from '@angular/platform-browser';
import { Meta } from '@angular/platform-browser';
class Example{
   constructor(
      private title: Title,
      private meta: Meta,
   ) {
      this.title.setTitle('SomePageInApp');
      this.title.getTitle();
      this.meta.addTags([
         { name: 'keywords', content: 'angular, google, appcomponent' },
         { name: 'desciption', content: 'this is angular app' },
      ]);
   }
}
*/


//!====================================================================================================
//? Директива аттрибутная Directives
//? объявляются в модуле в declarations
//? https://angular.io/guide/attribute-directives
// ng g d <name> --skipTests

/*
*в конструктор директивы приходит 2 параметра:
*1ый это сам элемент, на который вешается директива, типа ElementRef
*2ой это renderer, который определяет тип устройства, и на основе этого выдает нам методы, которые мы можем использовать для данного элемента. Аргумент являемя типов Renderer2

*Чтобы слушать события с помощью директивы на элементе требуется @HostListener, в который передается название события, и может принять массив с аргументами и также '$event', а затем определяем сам метод с логикой, в метод сам приходит event нативный

*в директиву можно передавать значение через аттрибуты тэга на котором она применена. В данном примере помимо appStyle директивы, мы также прокидываем fontWeight и dStyles, которые принимаем через @Input в директиве, Но, без главного аттрибута appStyle эти 2 аттрибута будут бесполезны


*@HostBinding привязывает свойство элемента сразу к переменной, тут например color сразу привязали к переменной, и можно переменной присваивать цвет и он будет применяться к тэгу.


*Host свойство позволяет сразу навесить тут события и методы, а методы описать в самом классе, то есть не прописывать HostListener



*Шаблон
<div
   appStyle='red'
   fontWeight='900'
   [dStyles]="{border: '1px solid blue', fontWeight: 900}">
   lorem lorem lorem lorem
</div>

*Директива
@Directive({
   selector: '[appStyle]',
   host: {
      '(click)': 'onClick()',
      '(mouseover)': 'onHover()'
   },
})
export class StyleDirective {
   @Input('appStyle') color: string = ''
   @Input() fontWeight: string = '';
   @Input() dStyles: {border: string, fontWeight: number} = '';

   constructor(
      private el: ElementRef,
      private renderer: Renderer2
      ) {
      this.renderer.setStyle(this.el.nativeElement, 'color', 'red')
   }

   @HostBinding("style.color") elColor: string = '';

   @HostListener('click', ['$event']) onClick(e:Event){
      console.log(e);
   }
   @HostListener('mouseover') onHover() {
      this.el.nativeElement.style.color = this.color;
      this.el.nativeElement.style.fontWeight = this.fontWeight;
   }
};
*/


//?====================================================================================================
//? Renderer2
//* setValue принимает узел, а не элемент, то есть напрямую див поменять нельзя, а только его текстовую нодуF



//?====================================================================================================
//? TemplateRef
//? https://angular.io/api/core/TemplateRef



//?====================================================================================================
//? ViewContainerRef
//? https://angular.io/api/core/ViewContainerRef
// *ViewContainerRef представляет доступ к элементу, на котором была вызвана директива, и разные методы по манипуляциям с данным компонентом предоставляет



//?====================================================================================================
//? ng-template
//? https://angular.io/guide/structural-directives#creating-template-fragments-with-ng-template
/*
? если мы обернули шаблон без директив в ng-template, то контент исчезнет внутри этого тэга

? ng-template тэг, который не будет появлять в DOM
? Пример шаблона, куда мы хотим поместить контент программно, мы указываем директиву modalRef, которая предоставляет ссылку на данный тэг с помощью ViewContainerRef
<ng-template modalRef></ng-template>
<nav class="navbar">
   <h1>Angular Dynamic Component</h1>
</nav>
*/



//?====================================================================================================
//? ngTemplateOutlet
/*
? В директиву можно передавать ссылку на шаблон, который будет отображаться с помощью этой директивы
*/



//?====================================================================================================
//?ngTemplateOutletContext
/*
? возможность задавать контекст для передаваемого шаблона в директиву ngTemplateOutlet, по дефолту, если не использовать эту директиву, то контекст шаблона будет использоваться тот, в котором был определен шаблон
*/



//?====================================================================================================
//? Структурная директива Directive
//? https://angular.io/guide/structural-directives

//* Структурная директива принимает 2 параметра и внутри используется @input set, в котором и происходит логика по действиям с директивой.

/*
@Directive({
   selector: '[someSelector]',
})
export class {
    consctructor(
      private templateRef: TemplateRef<any>,
      private viewContainer: ViewContainerRef,
   ){}

   @Input('someSelector') set ifNot(value){
      if(!value){
         this.viewContainer.createEmbeddedView(this.templateRef);
      } else{
         this.viewContainer.clear();
      }
   }
}
*/



//!====================================================================================================
//? Пайпы Pipes
//? https://angular.io/guide/pipes
//? объявляются в declarations модуля
// ng g p <name> --skipTests 

//* Пайп наследуется от PipeTransform и реализует метод transform, который принимает значение и вторым аргументом необязательные параметры по работе с данными, и затем возвращает значение

//* pure указывает, будет ли пайм отслеживать динамические входные изменения данных или нет
/*
*Pipe
@Pipe({
   name: 'somePipe',
   pure: boolean
})
export class implements PipeTransform{
   transform(value: number, args?: any): string {
      return value.toString().replace(".", ",");
   }
}

*шаблон
<div>{{someValue | somePipe: arg1: arg2}}</div>
*/



//!====================================================================================================
//? Сервисы Services
//? регистрируются в providers в модуле, либо в самом сервисе в Injectable providedIn значении
//? https://angular.io/api/core/Injectable
//? https://angular.io/guide/dependency-injection
// ng g s <name> --skipTests

//* Сервисы это по сути база данных ангуляра, логика какая то общая.

//* Если сервис мы в родителе в модуле определили и тот же сервис используем в дочерних компонентах, то мы ссылаемся на один и тот же сервис и получается изменения будут синхронизированы, чтобы избежать этого нужно локально их регистрировать в компонентах, где хотим использовать. То есть, в компоненте, где хотим локально использовть сервис, мы объявляем его через providers, в других же случая он будет один и тот же для всего приложения.

//* Можно также инжектировать другие сервисы

/*
*Локальное объявление сервиса
@Component({
   providers: [<nameService>],
})

@Injectable({
   providedIn: 'root'
})
export class {
   constructor(
      private someOtherService: SomeOtherService
   ){}
}
*/



//!====================================================================================================
//? Роутинг Route Router

//? https://angular.io/guide/router

//? https://angular.io/api/router/RouterModule

//? https://angular.io/api/router/ExtraOptions

//? https://angular.io/api/router/Router

//? https://angular.io/api/router/Routes

//? https://angular.io/api/router/RouterOutlet


//? затем модуль роутов подключается в imports нужного нам модуля

/*
* Для удобства создается отдельный модуль роутинга, в который импортируем RouterModule, на котором вызывается метод forRoot или forChild(зависит какой это модуль), в этот метод передается массив обьектов, обьекты являются настройками путей и компонентов, которые должны отображаться, и вторым аргументом можно передать настройки этого модуля, например там можно указать тип ленивой загрузки. Если все это в модуле реализовано, то необходимо экспортировать после импорта RouterModule.
* И данный модуль роутинга следует подключить в модуль, которому он приналежит через imports поле в NgModule директиве

* Чтобы роутинг заработал, в шаблоне выбираем место где хотимм отображать страницы и там прописываем тэг <router-outlet></router-outlet>, angular сам будет туда подставлять нужные компоненты в зависимости от url.


* Типичный обьект роутинга содержит:
* path - путь по которому будет доступен на сайте через url, также можно добавить params, которые можно будет потом считать в коде  можно указать '**', что означает, что будет показываться какой то компонент, если адрес не совпал
* component - имя компонента
* canActivate, canActivateChild- массив защитников(guards), в которых прописана логика по защите этой страницы, сможем мы ее при определенных условия открывать или нет
* children - массив таких же обьектов, то есть это внутренняя маршрутизация внутри этого роутинга
* redirectTo - редирект на url определенный
*loadChildren - ленивая загрузка модуля, указывается путь и в промисе достаем имя модуля из data

* для удобства создается переменная routes типа Routes - это массив обьектов который передается в RouterModule.

*Вторым агрументом в forRoot метод передается обьект настроек, где можно изменить стратегию загрузки модулей(PreloadAllModules - загружает все модули, но только после того, как загрузятся самые необходимый для текущей страницы файлы. NoPreloading - по умолчанию)

*модуль роутов
import { NgModule } from "@angular/core";
import { RouterModule, Routes } from "@angular/router";
import { PreloadAllModules } from "@angular/router";
import { <SomeComponent> } from "./about/about.component";
import { <SomeComponent2> } from "./home/home.component";
import { <SomeComponent2Child> } from "./posts/posts.component";

let routes: Routes = [
   { path: '', component: <SomeComponent> },
   {
      path: 'about', component: <SomeComponent2>,
      canActivate: [AuthGuardService],
      loadChildren: ()=>import('./index.ts').then(m => m.ModuleName),
      resolve: {
         post: SomeResolver,
      }
      children: [
         { path: 'extra', component: <SomeComponent2Child>, canActivateChild: [AuthGuardService] },
      ],
   },
   { path: 'posts', component: <SomeComponent>, canActivate: [AuthGuardService], },
   { path: 'posts/:id', component: <SomeComponent> },
]
@NgModule({
   imports: [RouterModule.forRoot(routes, {
      preloadingStratefy: PreloadAllModules,
   })],
   exports: [RouterModule],
})
export class AppRoutingModule {}

*шаблон
<div>
   <router-outlet></router-outlet>
</div>
*/


//?====================================================================================================
//? ROUTERLINK 
//? https://angular.io/api/router/RouterLink

//* в шаблоне на ссылки вместо href вешается директива <a [routerLink]="['/about'] ">About</a>, вторым параметром принимает

//* routerLinkActive='active' вешаем активный класс при совпадении
//* [routerLinkActiveOptions]="{exact:true} также можно передать дополнительную директиву, которая будет настраивать условия срабатывания routerLinkActive, например тут: при точном совпадении url.
//* QUERYPARAMS
//* [queryParams]="{showIdsOfPosts: true} можно дополнительно устанавливать query параметры для ссылки, которые добавятся к url.
//* помимо них можно установить fragment, это hash



//?====================================================================================================
//? ПРОГРАММНОЕ ИЗМЕНЕНИЕ СТРАНИЦЫ МАРШРУТИЗАЦИИ
//* можно также переходить программно на разные страницы, в том компоненете, где мы хотим реализовать програмный прыжок, в шаблоне вешаем обработчки события на метод, а в самом классе мы создаем поле типа Router, и вызываем this.router.navigate(['/someurl']) вторым аргументом может принимать параметры, также можно туда добавить queryParams
/*
import {Router}
class Example{
   constructor(private router: Router)
   goto(){this.router.navigate(['/someurl'])}
}
*/


//?====================================================================================================
//? ЧТЕНИЕ АДРЕСНОЙ СТРОКИ
//? ActivatedRoute
//? https://angular.io/api/router/ActivatedRoute

//? https://angular.io/api/router/ParamMap

//? import { ActivatedRoute, Router, Params } from '@angular/router';

//* чтобы считываеть информацию из адресной строки, в компоненте нужен route типа ActivatedRoute, в котором можно получить доступ к параметрам и многому другому.
//* Params это стрим, на который нужно подписаться, он содержит все параметры адресной строки :
/*
class {
   constructor(route: ActivatedRoute){}
   ngOnInit(){
      this.route.params.subscribe((params: Params)=>{

      });
   }
}
*/


//?====================================================================================================
//? Обработка ошибок
//* для обработки ошибок можно создать страницу, куда делать редирект, если не найдена страница

//* ** означает все что угодно, чего нет в приложении, путей которых нет, будет ссылать сюда, и от сюда уже редирект делать на error.
/*
   { path: 'error', component: ErrorComponent },
   { path: '**', redirectTo: 'error' },
*/



//?====================================================================================================
//? Guard
//? https://angular.io/api/router/CanActivate

//? https://angular.io/api/router/CanActivateChild

//? https://angular.io/api/router/CanDeactivate

//? https://angular.io/api/router/CanLoad

//* Guard нужны для защиты определенных роут маршрутов, запрещаем допуск к ним при определенных условиях 

//* canActivate принимает текущий активный route и state.
/*
*Guard
import { Injectable } from "@angular/core";
import { ActivatedRouteSnapshot, CanActivate, CanActivateChild, RouterStateSnapshot } from "@angular/router";
import { Observable } from "rxjs";
import { AppAuthService } from './services/auth-service.service';

@Injectable({
   providedIn: 'root',
})
export class AuthGuardService implements CanActivate, CanActivateChild {
   constructor(private authService: AppAuthService) { }

   canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot,): Observable<boolean> | Promise<boolean> | boolean {
      return this.authService.getAutedStatus()
         .then(isAuth => {
            if (isAuth) {
               return true;
            } else {
               return false;
            }
         });
   }

   canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot,): Observable<boolean> | Promise<boolean> | boolean {
      return this.canActivate(route, state);
   }
}
*/


//?====================================================================================================
//? Resolver
//? https://angular.io/api/router/Resolve
//?Подключается в routes, в обьект роута, в значение resolve.

//* Resolver автоматически сработает при совпадении url строки, где можно сделать определенную логику, а затем в компоненте, где был применен resolver, можно получить значение его с помощью route.data
//* resolver нужен, чтобы как бы предзагрузить страницу, контент ее, прежде чем открыть ее, то есть, мы нажали на ссылку, контент начал грузиться, и как только он готов, мы переходим на эту страницу
//* страница не откроется, пока resover не отработает

/*
*resolver
@Injectable({
   providedIn: 'root'
})
export class SomeResolver implements Resolve<any> {
   constructor(
      private someService: SomeService,
   ){}

   resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot,): Observable<boolean> | Promise<boolean> | any {
      return this.someService.getById(+route.params.id);
   }
}

*компонент, где его применили, post в данном случае приходит из route, т.к. в routes настройках в обьекте мы указали post значение, которое вернет resolver(смотри выше про роутинг, там будет инфа)
class implements OnInit{
   constructor(private route: ActivatedRoute,){}

   ngOnInit() {
      this.route.data.subscribe(data=>{
         this.post = data.post;
      })
   }
}
*/



//!====================================================================================================
//? Модули Modules

/*
import {CommonModule} используется в других модулях, чтобы не импротировать BrowserModule второй раз, т.к. нельзя
import {BrowserModule, FormsModule, HttpClientModule}

//* Ошибка про роуты: если у нас 2 разных модуля, то роуты нужно разделить по модулям, чтобы они относились каждый к своему, иначе будет ошибка. Но в дочернем модуле, уже вместо RouterModule.forRoot() вызывается RouterModule.forChild(), а затем из дочернего модуля также экспортировать RouterModule, чтобы главный модуль знал про них.

@NgModule({

})
export class{}

*declarations - пайпы, компоненты, директивы
*imports - другие модули, которые мы хотим использовать в этом модуле
*exports - экспорт сущностей, которые должны быть доступны вне этого модуля(можно экспортировать что угодно)
*bootstrap - должен быть только один в приложении и содержит название главного компонента приложения App
*providers - сервисы (но можно в самом сервисе в providedIn зарегать его)
*entryComponents - список компонентов, которые будут в проекте, но их нет в шаблонах, то есть они добавляются динамически

//* ленивая загрузка! Ни в коем случае модуль не подключать к главному модудулю, если мы хотим его лениво загружать
*/



//!====================================================================================================
//? Forms Формы
/*
*В компоненте создается форма, через FormGroup при инициализации. Каждый инпут, который мы хотим получить мы передаем в обьект настроек при инициализации формы, ключ - это имя которое мы хотим, чтобы было у поля, и через FormControl создаем поле в классе, можно передать инициализирующее значение. В FormControl вторым аргументом передается массив валидаторов.

*В шаблоне форма связывается через [formGroup]="<name form from class>" и вешается обработчик submit, каждый инпут связывается с классом через formControlName="<name formControl from class>" и на каждый инпут формы, который помечен formControlName вешаются автоматически классы ангуляра

*Можно создавать подгруппы также через FormGroup, только в шаблоне уже эта группа указывается через formGroupName

*компонент
import { FormsModule, ReactiveFormsModule } from '@angular/forms' в модуле
export class AppComponent {
   form: FormGroup;

   constructor() { }

   ngOnInit() {
      this.form = new FormGroup({

         email: new FormControl('', [
            Validators.email,
            Validators.required,
            MyValidator.restrictedEmail,
         ], [MyValidator.isFreeEmail,]),

         password: new FormControl('', [
            Validators.required,
            Validators.minLength(6)
         ]),

         address: new FormGroup({
            country: new FormControl('by'),
            city: new FormControl('', Validators.required),
         }),

         skills: new FormArray([]),
      });
   }

   submit() {
      console.log(this.form);
      this.form.reset();
   }

   setCapitalByClick() {
      let cityMap: any = {
         ru: 'Москва',
         ua: 'Киев',
         by: 'Минск',
      };
      let city = cityMap[this.form.get('address')?.get('country')?.value];
      this.form.patchValue({
         address: { city }
      });
   }

   addSkill() {
      let control = new FormControl('', Validators.required);
      (<FormArray>this.form.get('skills')).push(control);
   }

   removeSkill(e: any) {
      this.form.get('skills').removeAt(e);
   }
}

*шаблон
<div class="container">

    <form class="card" [formGroup]="form" (ngSubmit)="submit()">
        <h1>Angular Forms</h1>

        <div class="form-control">
            <label>Email</label>
            <input formControlName="email" type="text" placeholder="Email">
            <div *ngIf="form.get('email')!.errors && form.get('email')!.touched" class="validation">

                <p *ngIf="form.get('email')!.errors!.email">Введите Email корректно</p>
                <p *ngIf="form.get('email')!.errors!.required">Поле обязательно</p>
                <p *ngIf="form.get('email')!.errors!.emailRestricted">Email {{form.get('email').value}} запрещен</p>
                <p *ngIf="form.get('email')!.errors!.isFreeEmail">Email {{form.get('email').value}} уже занят</p>
            </div>
        </div>

        <div class="form-control">
            <label>Пароль</label>
            <input formControlName="password" type="password" placeholder="Пароль">

            <div *ngIf="form.get('password')!.errors && form.get('password')!.touched" class="validation">
                <p *ngIf="form.get('password')!.errors!.required">Поле обязательно</p>
                <p *ngIf="form.get('password')!.errors!.minlength">
                    Минимальная длина: {{form.get('password')!.errors!.minlength.requiredLength}} символов
                </p>
            </div>
        </div>

        <div class="card" formGroupName="address">
            <h2>Адрес</h2>

            <div class="form-control">
                <label>Страна</label>
                <select formControlName="country">
                    <option value="ru">Россия</option>
                    <option value="ua">Украина</option>
                    <option value="by">Беларусь</option>
                </select>
            </div>

            <div class="form-control">
                <input type="text" formControlName="city">
            </div>
            <button class="btn" type="button" (click)="setCapitalByClick()">Выбрать столицу</button>
        </div>

        <div class="card" formGroupName="skills">
            <h2>Ваши навыки</h2>
            <button (click)="addSkill()" class="btn" type="button">Добавить умение</button>
            <div *ngFor="let item of form.get('skills')['controls']; let i = index" class="form-control">
               <label>Умение {{ i + 1 }}</label>
               <input [formControlName]="i" type="text">
               <span (click)="removeSkill(i)" style="cursor: pointer;">&times;</span>
            </div>
        </div>

        <button class="btn" type="submit" [disabled]="form.invalid || form.status === 'PENDING'">Отправить</button>
    </form>
</div>
*/


//?====================================================================================================
//? Кастомные валидаторы
//* Метод класса принимает control и возвращает обьект, с ошибкой, если есть ошибка какая то, либо null, если все хорошо. Этот обьект будет помещен в контрол, в ключ errors, откуда можно будет получить это значение ошибки по ключу.
/*
*класс
class MyValidators{
   static restrictedEmails(control: FormControl){
      if([d@mail.ru, dfads@mail.ru].includes(control.value)){
         return {restrictedEmail: true};
      }
      return null;
   }
}

*шаблон
<div *ngIf="gorm.get('email').errors.restrictedEmail">Показать ошибку</div>
*/


//?====================================================================================================
//? Ассинхронные валидаторы
//* Метод класса принимает control и возвращает обьект, с ошибкой, если есть ошибка какая то, либо null, если все хорошо. Этот обьект будет помещен в контрол, в ключ errors, откуда можно будет получить это значение ошибки по ключу. Передаются они 3им параметром в formcontrol
/*
*класс
class MyValidators{
   static asyncValidator(control: FormControl){
      return new Promise((resolve)=>{
         if(this.service.isLoginFree()){
            resolve(null);
         } else{
            resolve({loginIsNotFree: true});
      })
   }
}

*шаблон
<div *ngIf="gorm.get('email').errors.restrictedEmail">Показать ошибку</div>
*/


//?====================================================================================================
//? FormGroup
//? https://angular.io/api/forms/FormGroup
//* Обьединений полей формы в группы, можно использовать как для всей формы, так и для создания подгрупп формы


//?====================================================================================================
//? FormControl
//? https://angular.io/api/forms/FormControl
//* Создает контрол для поля формы.
//* В конструктор передается начальное значение, массив валидаторов, и массив ассинхронных валидаторов.


//?====================================================================================================
//? FormArray
//? https://angular.io/api/forms/FormArray
//* Для создания полей группы, но они создаются без имени(будут в массиве), также используется для динамического создания полей формы
/*
class {
   this.groupArray = new FormArray([]);

   onAdd(){
      this.groupArray.push(new FormControl('', Validators.required));
   }
}
*/


//?====================================================================================================
//? AbstractControl
//? https://angular.io/api/forms/AbstractControl#markAsPending



//!====================================================================================================
//? NgModel Custom
//? https://angular.io/api/forms/ControlValueAccessor
/*
*

*writeValue принимает входящее значение от родителя передаваемое в [(ngModel)]
*registerOnChange функция срабатываемая при изменении state и автоматически делает аутпут наверх, принимает функцию, которую нужно переопределить методу класса этого, чтобы делать аутпут наверх. То есть тут, при изменении state через функцию setState, мы в ней вызываем функцию onChange, которой присвоили функцию из registerOnChange, и теперь имеем возможность синхронизированно изменять значения и в родителе и в ребенке.

*ngModelChange вызывается в компоненте, где был навешан ngModel и срабатывает при любом изменении ngModel.

*компонент дочерний
let VALUE_ACCESSOR: Provider = {
   provide: NG_VALUE_ACCESSOR,
   useExisting: forwardRef(()=>SomeClass),
   nulti: true,
}
@Component({
   selector: 'app-some',
   providers: [
      VALUE_ACCESSOR,
   ]
})
export class Switch implements ControlValueAccessor {
   state = 'off';
   private onChange(value) {
   }
   setState(value) {
      this.state = value;
      this.onChange(value);
   }

   registerOnChange(fn) {
      this.onChange = fn;
   }
   writeValue(value) {
      this.state = value;
   }
   registerOnTouched() {
   }
   setDisabledState() {
   }
}
<button (click)="setState(true)">On</button>
<button (click)="setState(false)">On</button>

*компонент родительский
class{
   someState = 'off';

   onModelChange(){
      doSomething...
      console.log(someState);
   }
}
<div>{{someState}}</div>
<app-some [(ngModel)]="someState" (ngModelChange)="onModelChange()"></app-some>
*/



//!====================================================================================================
//? HttpClientModule
//? https://angular.io/api/common/http/HttpClientModule
//? https://angular.io/guide/http
/*
*Сервисы подключается в модуле в providers. HttpClientModule подключается в imports. Работа с запросами осуществляется через HttpClient

*http возвращает стримы, на которые можно подписаться и обрабатывать, в метод подписки приходит 3 функции, первая это когда успешно все завершилось, вторая - ошибка, третья - когда стрим выполнен успешно.


import { HttpClient, HttpHeaders, HttpParams } from "@angular/common/http";
import { Injectable } from "@angular/core";
import { Observable, throwError } from "rxjs";
import { catchError, delay, map, tap } from 'rxjs/operators';

export interface TodoListItem {
   completed: boolean
   id?: number
   title: string
}

@Injectable({
   providedIn: 'root',
})
export class AppTodosService {

   url = 'https://jsonplaceholder.typicode.com/todos/';

   constructor(private http: HttpClient) { }

   load(): Observable<TodoListItem[]> {
      return this.http.get<TodoListItem[]>(`${this.url}`, {
         params: new HttpParams().set('_limit', '3'),
         observe: "response",
      }).pipe(
         map(item => item.body),
         delay(2000),
      );
   }

   add(body: TodoListItem): Observable<TodoListItem> {
      return this.http.post<TodoListItem>(this.url, body, {
         withCredentials: true,
         responseType: "json",
         headers: new HttpHeaders({
            'MyCustomHeader': (Math.random() * 1000).toString(),
            'SecondCustomHeader': 'some text',
         })
      });
   }

   remove(id: number) {
      return this.http.delete(`${this.url} ${id}}`, {
         observe: "events"
      }).pipe(
         tap(event => {
            console.log(event);
         }),
      );
   }

   complete(item: TodoListItem) {
      return this.http.put(`${this.url}${item.id}`, { ...item, completed: true })
         .pipe(
               catchError(error => {
                  return throwError(error.message);
               }),
         );
   }
}
*/


//?====================================================================================================
//? Interceptor Интерсептор
//? https://angular.io/api/common/http/HttpInterceptor
//* Перехват запросов, их регистрируют в providers в модуле, но нужно создать для этого переменную, как в кастомной ngModel.

//? https://angular.io/api/common/http/HttpRequest
//? https://angular.io/api/common/http/HttpResponse
//? https://angular.io/api/common/http/HttpHandler

/*
class someClass implements HttpInterceptor{
   intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>{

      let cloned = req.clone({
         headers: req.headers.append('MyHeader', 'some token'),
      });

      return next.handle(cloned);
   }
}

*эта переменная передается в модуле в providers
let INTERCEPTOR_PROVIDER: Provider = {
   proveide: HTTP_INTERCEPTORS,
   useClass: someClass,
   multi: true,
}
*/


//?====================================================================================================
//? https://angular.io/api/common/http/HttpClient
//? HttpClient
//* Работа с http запросами.


//?====================================================================================================
//? https://angular.io/api/common/http/HttpParams
//? HttpParams
//* Добавление query параметров.


//?====================================================================================================
//? HttpHeaders
//? https://angular.io/api/common/http/HttpHeaders
//* Параметры конфигурации заголовков, можно добавлять headers.



//!====================================================================================================
//? RXJS
//? https://angular.io/guide/rx-library
//? https://rxjs-dev.firebaseapp.com/guide/overview

//* import { interval, Subscription} from 'rxjs'
//* import { } from 'rxjs/operators'

//? Суть работы: это оборачивание какого то кода в rxjs стрим, на который можно подписаться, отписаться т.д., это что то похожее на promise.

//? Стримы на конце должны иметь знак доллара(просто договоренность программистов).

//? мы создаем стрим, и в каком то месте любом подписываемся на него, и на каждое изменение будет срабатывать метод подписки, а затем можно отписаться. Отписываться следует, например, когда мы уходим со страницы, на которой установили таймер, тогда в методе жизненного цикла следует отписаться от стрима.

//? У стрима можно вызвать метод pipe, который принимает операторы rxjsa, они служат для обработки данных стрима.
/*
export class AppComponent {
    subscribtion: Subscription;
    constructor() {
        let intervalStrim$ = interval(1000);
        this.subscribtion = intervalStrim$.subscribe((value) => {
            console.log(value);
        });
        setTimeout(() => {
            this.subscribtion.unsubscribe();
        }, 3000);
    }
}
*/


//?====================================================================================================
//? Создание своего стрима
//? import { interval, Observable, Subscription } from 'rxjs'
//? Создается стрим через конструктор, который принимает callback а затем на этот стрим можно подписаться, на него , в отличии от subject можно только подписаться, а диспатчить значения можно только внутри метода консруктора observable.
/*
let stream$ = new Observable((observe) => {
    setTimeout(() => {
        observe.next(1);
    }, 500)

    observe.error();
    observe.complete();
});
*/

//? next - диспатч нового action
//? error - диспатч ошибки
//? complete - завершение стрима


//? Подписка на стрим принимает 3 колбэка, первый - при успешном выполнении, 2 - при ошибке, 3 - при завершении стрима(completed)
//? метод completed вызывается только, когда стрим завершился без ошибок
/*
stream$.subscribe(
    (res) => {
        console.log(res);
    },
    (error) => {
        console.log(error);
    }),
    () => {
        console.log('завершен стрим')
    };
)

*альтернативная запись
stream$.subscribe({
    next(val){},
    error(val){},
    complete(val){},
})
*/


//? of
//? https://rxjs-dev.firebaseapp.com/api/index/function/of


//?====================================================================================================
//? Subject
//? https://rxjs-dev.firebaseapp.com/api/index/class/Subject
//* главное отличие от observable, то, что можно диспатчить событие прямо в переменню стрима, из любого места.
/*
let stream$ = new Subject();
stream$.subscribe(value => console.log(vakue));
stream$.next();
*/


//?====================================================================================================
//? BehaviorSubject
//? https://rxjs-dev.firebaseapp.com/api/index/class/BehaviorSubject
//* тот же Subject, только принимает начальное значение, которое будет сразу отправлено в subscribe.
/*
let stream$ = new BehaviorSubject('helloworld!');
stream$.subscribe(value => console.log(vakue));
stream$.next(1);
*/


//?====================================================================================================
//? ReplaySubject
//? https://rxjs-dev.firebaseapp.com/api/index/class/ReplaySubject
//* он сохраняет предыдущие значение, то есть, если мы несколько раз задиспатчили значения, но не подписались на них, то при подписке они все появятся в подписке
//* принимает 3 параметра
//? 1 - размер буфера, сколько данных сохранит до подписки
//? 2 - сколько времени храняться данные
//? 3 - какое то планировщик
/*
let stream$ = new ReplaySubject('helloworld!');
stream$.next(1);
stream$.next(1);
stream$.next(1);

stream$.subscribe(value => console.log(vakue));
*/


//?====================================================================================================
//? Operators Операторы

//? map - трансформация значения стрима

//? filter - фильтрация значения стрима

//? tap - добавления сайдэффектов, существует в основном для дебага

//? take - принимает число, и останавливает подписку на стрим, то есть когда число срабатываний подписки будет равно аргументу, то подписка закончится 

//? takelast - принимает число, и когда мы остановим стрим, этот метод нам вернет последние срабатывания подписки равное аргументу 

//? takewhile - принимает условие и будет срабатывать подписка, пока это условие верно

//? scan - тот же reduce(из нативного), принимает колбэк и возвращает аккумулированое значение

//? reduce - аккумулирует все значение подписки сразу после завершения подписки, пока она есть, он не будет отрабатывать

//? switchMap - принимает значение из прошлого стрима, и должен вернуть новый стрим
/*
fromEvent(document, 'click').pipe(
    switchMap((event)=>{
        return interval(3000),
    })
).subscibe(()=>{});
*/

//? forkJoin это не оператор, это просто функция, которая принимает массив стримов, затем возвращает его и можно подписаться на него. По сути работа такая же как и Promise.all


