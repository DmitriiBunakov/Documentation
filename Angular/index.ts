//!================================================================================================================================================
//? /AOT/Компиляция/
//? Когда включен, при сборке будет собран js код оптимизированный, а также скомпилирует предварительную версию приложения
//? Сразу в бандл попадут стили и шаблоны
//? Меньший размер машины фреймворка, который запускает код
//? Ошибки на этапе сборки
//? Компилирует html заранее, поэтому лучше проверяются шаблоны на наличие уязвимостей










//!================================================================================================================================================
// https://angular.io/guide/elements
//? /Custom element/Пользовотельские элементы/
//? Angular использует нативное api браузера пользовотельские элементы, элементы которые можно создать через js и сообщить браузера их обрабатывать как обычные тэги. Для этого необходимо просто создать компонент и зарегестрировать его с помощью api angulara.
//? Api ангуляра за нас добавит компонент в дерево обнаружений и в целом в приложение и нам не нужно ничего думать
//? createCustomElement - можно создать свой кастомный элемент который под капотом сделает все что нужно и нам останется только вызвать document.createElement, либо можно вызывать createComponent









//!================================================================================================================================================
//? /IncrementalDom/
//? Каждый компонент компилируется в набор инструкций, и когда инструкция меняется, то точечно перерисовывается реальный DOM. Инту
//? В отличии от virtualDom ангуляр не создает компию всего дерева компонентов, из за этого очень сильно экономится память, что важно для мобилок а также размер пакета уменьшается.


//? /Tree shaking/
//? Из за того, что на какую то инструкцию нет ссылки, сборщик во время компиляции может выкинуть ее из сборки.
//? например contentChild/viewChild(Token) - где Token - это абстрактный класс, какая то легкая сущность, по которой будет получен di сущность, и нам не обязательно тянуть что то большое по этому токену в сборку
/*
**
***
****
*****/
//!================================================================================================================================================
//? /API/
// https://angular.io/api
//? ViewportScroller
//? ApplicationInitStatus
//? ErrorHandler
//? APP_BOOTSTRAP_LISTENER
//? APP_ID
//? PLATFORM_INITIALIZER
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Components/Компоненты/
// https://angular.io/guide/lifecycle-hooks

// https://habr.com/ru/company/infopulse/blog/358860/       обнаружений изменений
// https://habr.com/ru/post/327004/

//? @Component декоратор используется для пометки компонентов, наследуется от декоратора директивы
//? Все компоненты, которые мы хотим использовать в модуле, должны быть объявлены в модуле

//? Принимает обьект настроек:
//? 1) changeDetection
//? 2) encapsulation
//? 3) selector
//? 4) styles - стили в строку компонента
//? 5) stylesUrls - ссылки на стили         Стили также можно подключать через link, в шаблоне компонента
//? 6) template - верстка в строку
//? 7) templateUrl - ссылка на верстку
//? 8) providers - массив сервисов доступных для инжектирования вниз по дереву и для проецируемого контента тоже будут доступны эти сущности
//? 8) viewProviders - массив сервисов доступных для инжектирования в данном представлении и всех его потомков. Если в данном компоненте проецируется контент, то в проецируемый контент не будут они предоставлены, проецируемый контент возьмет данные из того места где он был вызван, а также из providers компонента куда он проецируется (для компонентов поиск приоритетней тут нежели чем poviders массив)
//? 9) standalone - boolean, можно ли не объявлять в модуле, но требуется напрямую импортировать зависимости в imports
//? 10) imports - импорты компонента при standalone
//? 11) schemas - 





//?================================================================================================================================================
//? /ChangeDetection/стратегии обнаружения изменений/DetectionStrategy/
// https://medium.com/@overthesanity/zone-js-%D0%BE%D1%82-%D0%B0-%D0%B4%D0%BE-%D1%8F-fdb995917968
// https://www.youtube.com/watch?v=2cV4i-g6Oxc&ab_channel=Angular-%D0%BC%D0%B8%D1%82%D0%B0%D0%BF%D1%8B%D0%B8%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F
// https://habr.com/ru/company/infopulse/blog/358860/
// https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html
// https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html


//? NgZone под капотом создает контексты выполнения, следит за тем, когда завершилась та или иная асинхронная операция и вызывает методы обнаружения изменений. Зона оборачивает все асинхронные операции в hoc, модифицируя их.



//? Стратегии обнаружений работают следующим образом:
//? Проверка изменений запускается с самого верхнего уровня и вниз по дереву при:
//? любые асинхронные операции (setTimeout/Promises/requestAnimationFrame)
//? (обработчики)/HostListener
//? input
//? async pipe
//? zone.run/runGuarded и тд

//? НЕ запускаются
//? signals просто помечают ДАННЫЙ компонент для проверки где они изменились и только его, грубо говоря markForCheck но только для этого компонента
//? runOutsideZone


//? /Default/
//? будут перерисовываться на все циклы


//? /OnPush/
//? изменение input
//? async pipe
//? обработчик события в дочернем элементе или в этом компоненте, при событии через ()/hostListener с этого до самого верхнего будет помечено дерево как грязное
//? detectChanges/markForChek/reattach





//? Чтобы отслеживать асинхронные изменения, нужно инжектировать ChangeDetectorRef и вызывать методы соответствующие.
//? 1) markForCheck - помечает явно компонент и все родительские, чтобы его проверить снова при следующем цикле, не запускает цикл самостоятельно
//? 2) detach - отсоединяет компонент от проверок. Он ничего не будет отрисовывать, пока его снова не подключить или вызвать метод detectChanges(при отключенной проверки, хук onChanges все равно будет запускаться в компоненте)
//? 3) detectChanges - происходит запуск цикл с данного компонента и вниз по дереву
//? 4) reattach - заново включает в циклы обнаружения изменений
// TODO 5) checkNoChange -


//? Геттеры в шаблоне вызываются при каждом цикле обнаружения изменений, чтобы они не вызывались, нужно компонент отсоединить от проверок
/*
**
***
****
*****/
//!=============================================================================
//? /Sigmals/
//? signal - метод который использоваться может вместо подписок и обычного состояния. Ангуляр везде где используются сигналы - будет их помечать как "зависимость данного компонента" и помечать markForCheck при изменении
//? можно устанавливать set, мутировать mutate, взять предыдущее значение и обновить update

//? computed - можно "зависеть" от других сигналов и возвращать новое значение, когда какой то из сигналов, что мы зависим изменит значение
//?




//?================================================================================================================================================
// https://netbasal.com/reduce-change-detection-cycles-with-event-coalescing-in-angular-c4037199859f
//? bootstrapModule
//? В maints файле при запуске приложения можно передать https://angular.io/api/core/BootstrapOptions обьект
//? ngZone - можно отключить зону, и нам нужно будет полностью управлять компонентами через detectChanges
//? ngZoneEventCoalescing - если у нас несколько вложенных друг в друга тэга, на каждом из них есть обработчик клика, то по дефолту каждое событие запустит цикл обнаружения, данная настройка объединит их в один цикл, чтобы экономить циклы
//? ngZoneRunCoalescing - объединяет множество вызовов ngZone.run в одно, чтобы не запускать цикл несколько раз подряд на синхронные операции
//? createPlatform - возвращает ссылку на платформу(PlatformRef), куда через bootstrapModule можно запустить несколько независимых модулей на страницу, у каждой из которых будет свой ngZone и свой root инжектор, а общий инжектор - платформа. PlatformRef можно инжектировать в какой то компонент и можно динамически bootstrapModule по клику условному сделать






//?================================================================================================================================================
// https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html
//? /NgZone/
//? Под капотом создает контексты выполнения, следит за тем, когда завершилась та или иная асинхронная операция и вызывает методы обнаружения изменений. Зона оборачивает все асинхронные операции в hoc, модифицируя их.

//? runOusideAngular - вызывает переданный колбэк вне зоны приложения, чтобы не запускать обнаружение изменений.

//? onMicrotaskEmpty - в очереди нет микрозадач

//? run - запуск синхронной задачи в зоне angular, а также все асинхронные задачи будут выполняться в зоне

//? runTask - запуск синхронной задачи в зоне angular и возвращает значение

//? runGuarded - то же что и run, только ошибки будут перехвачены

//? HostListener будет вызывать цикл обнаружения каждый раз при событии, поэтому он не будет корректно работать с runOusideAngular.
//? вызывает с самого верхнего до текущего компонента включительно проверку






//?================================================================================================================================================
//? /LifecycleHooks/Хуки жизненного цикла/
// https://angular.io/guide/lifecycle-hooks

//? У каждого компонента есть хуки жизненного цикла:
//? 1) ngOnChanges вызывается, когда есть Input в компоненте, именно, когда мы в шаблоне прокидываем параметр из родителя без него не будет вызываться. Вызывается каждый раз при изменении входных данных, если входной параметр это обьект, то хук сработает только при изменении ссылки на входной обьект

//? 2) ngOnInit вызывается при создании компонента. Именно тут должна быть сложная логика инициализации компонента, в конструктор ее помещать не нужно, т.к. компонент должен быть очень простым в создании, а тут уже можно запихнуть логику. Максимум, что может быть в конструкторе это присвоение локальных переменных

//? 3) ngDoCheck вызывается при любом цикле обнаружения изменений во всем приложении. Использовать его не желательно, даже если компонент имеет onPush стратегию всё равно заходить будет

//? 4) ngAfterContentInit вызывается и в родительском компоненте, который прокидывает слоты в дочерний, и в дочернем, который проецирует слоты. Вызывается после вставки содержимого. Также работает в директиве

//? 5) ngAfterContentChecked вызывается постоянно после ngDoCheck в компонентах, где есть проецирование слотов. Также работает в директиве

//? 6) ngAfterViewInit вызывается разово, после отрисовки компонента или директивы, а также отрисовки всех дочерних компонентов, поэтому в нем можно получать через querySelector элементы дочерних компонентов
//? то есть сначала вызовется на дочернем - потом у родителя(но если дочерний компонент создается через ngIf - порядок не гарантирован - скорее всего сначала вызовется у родителя)

//? 7) ngAfterViewChecked вызывается после ngAfterViewInit и каждый раз после ngAfterContentChecked, а также после любых изменений в компоненте. Работает и в компоненте и директиве
//? также сначала у дочернего - потом родительского

//? 8) ngOnDestroy вызывается перед тем, как фреймворк удалит компонент. Тут помещается логика по отпискам от таймеров, подписок, и т.д, чтобы память не засорять колбэками. Также вызывается на сервисах, НО, только если они провайдятся на уровне компонентов.





//?================================================================================================================================================
//? /Content projection/Проекция контента/ng-content
// https://angular.io/guide/content-projection

//? Если мы хотим спроецировать контент внуть другого компонента, нужно: в дочернем компоненте в нужном месте поместить тэг <ng-content></ng-content>
//? в родительской верстке вызвать дочерний селектор компонента и между тэгов поместить проецируемое значение, оно отобразится на месте ng-content

//? можно в тэге ng-container указать аттрибут [select] в который можно передать значение, по которому будет проецироваться определенный контент
//? например ниже, мы в дочернем устанавливаем 2 контента, с атрибутом и без, и если в родителе мы проецируем контент без аттрибута selected-content, то дефолтный контент отрисуется на месте тэга без аттрибута, а с аттрибутом, на соответствующем месте
/*
дочерний компонент
<ng-content [select]="selected-content"></ng-content>
<ng-content></ng-content>

родительский компонент, в котором мы прокидываем контент в дочерний
<div app-slot-child>
    <div class="default-content">
        Проецируемый контент дефолтный 2: {{value}}
    </div>
    <div class="selected-content" selected-content>
        Проецируемый контент select 2: {{value}}
    </div>
</div>
*/
// TODO





//?================================================================================================================================================
//? /Encapsulation/Инкапсуляция стили/
// https://angular.io/guide/view-encapsulation

//? Каждый компонент, сама оболочка(тэг, либо аттрибут, по которому создается компонент), это называется хост, host.
//? Чтобы применить стили к хост элементу, можно обратиться к нему либо из родителя напрячую по тэгу(аттрибуту специфичному для него), либо в стилях через :host {} селектор, но этот селектор работает, если у нас emulated инкапсуляция


//? Стили, примененные в компоненте в декораторе, при наследовании не наследуются

//? Стили также можно подключать через link, в шаблоне компонента


//? Есть 3 стратегии использования инапсуляции:
//? 1) None - полностью отключена
//? Такие стили будут полностью глобальными. Если в родителе отключена, а в дочернем включена инкапсуляция, то если из родителя обратиться к классу дочернего, можно переопределить стили, т.к. они будут глобальными

//? 2) Emulated(по дефолту) - на каждый компонент добавляется аттрибут уникальный для компонента, именно поэтому аттрибуту в стилях потом добавляется этот аттрибут, и стили становятся скрытыми для каждого компонента(если хост - _host<что то дальше>, если контент внутри хоста - _content<что то дальше>), они генерируются самим фреймворком, и к ним нельзя никогда обращаться в коде
//? При такой стратегии, стили заданные для дочернего хост элемента, можно перебить из родительского, просто обратившись в дочернему хосту, т.к. родительский компонент добавляет на дочерний хост такие же уникальные аттрибуты, что и на свой, именно поэтому можно переопределить только хост дочерний из родительского, внутри вложенные компоненты уже не получится

//? можно использовать host в компоненте(если none, то нельзя), чтобы из родителя достучаться до потомков используется ::ng-deep {} селектор, внутри которого пишутся стили для дочерних

//TODO ? 3) ShadowDom





//? ng-deep может пробить несколько к ряду написанных компонентов(их инкапсуляцию). Он делает этот стиль глобальным для всего проекта. Если мы и используем его, то нужно все таки точечно указывать, в каком селекторе что нам нужно поправить(делать вложенность), и лучше для каждого компонента использовать уникальный класс, также ОБЯЗАТЕЛЬНО использовать его внутри host, т.к. это повышает специфичность

//? host указывает на сам хост элемент, не доступен в none стратегии

//? host-context() - принимает класс из родителя, например .active где то в родительском компоненте, и в дочернем можно использовать его для стилезации





//?================================================================================================================================================
//? /Datapassing/Обмен данными/@Input/@Output/Component interaction/
// https://angular.io/guide/component-interaction
// https://angular.io/guide/inputs-outputs

//? Input декоратор для того, чтобы принимать в себя данные из родительского компонента. Со стратегией обнаружения onPush работает только при изменении ссылки
//? Данный декоратор можно использовать с геттером и сеттером, либо только с сеттером. При изменении входящих параметров, будет отрабатывать сеттер и будет происходить логика нами заложенная. Можно передать как аргумент имя аттрибута по которому компонент будет принимать данные




//? Output декоратор нужен для отправки события в родительский компонент
//? Создается свойство через EventEmitter украшенное декоратором, затем в компоненте есть обработчик события, на который мы эмитим событие
//? В родительском компоненте мы слушаем это созданное событие как обычный обработчик через (), а в саму функцию, которая будет вызвана эмиттером, придет $event значение, которое и содержит переданные данные из дочернего компонента. Можно передать как аргумент имя аттрибута по которому компонент будет отдавать данные




//? /ViewChild/
// https://angular.io/api/core/ViewChild
//? Принимает класс компонента, который мы отрисовываем внутри родительского. Он будет доступен как обычное свойство класса. Можно вызывать методы, и т.д.
//? Ищет в dom первый доступный компонент или директиву с таким классом, как только дом изменится, значение переменной обновится.
//? Важные моменты: если через цикл создаются компоненты, то получим самый первый компонент. Если мы получаем сервис, который объявлен для конкретного компонента в провайдерах, а этот компонент мы перебираем в цикле, то мы все равно получим сервис первого самого компонента из цикла, для остальных в цикле будут созданы другие сервисы

//? Можно использовать с сеттером или вместе с геттером и сеттером, т.е. по условию создается элемент динамически - мы в сеттере логику прописываем

//? Можно получать: через #reference или просто указть имя класса директивы или компонента
//? сервис, передав его класс
//? любой токен для инжектирования в виде строки
//? TemplateRef


//? static, можно указать, чтобы получить элемент в onInit хуке, подразумевает, что он сразу будет в шаблоне, т.е. без условий, false - по дефолту, получим только после afterViewInit, потому что элемент мог быть создан по условию






//?================================================================================================================================================
//? ContentChild
// https://angular.io/api/core/ContentChild

//? Если мы хотим получить доступ до html, который передан от родителя и получен через ng-content, нужно в компоненте ребенка получить ссылку на этот html через ContentChild.
/*
шаблон родителя
<div>
   <child-component *ngFor="let post of posts">
      <div #refoncontentformparent>
         <p *ngIf="post.text.length > 150; else otherContent">пост длинный</p>

         <ng-template #otherContent>
            <p>пост короткий</p>
         </ng-template>
      </div>
   </child-component>
</div>

шаблон ребенка
<div>
   <div></div>
   <ng-content></ng-content>
</div>

компонент ребенка
import {ElementRef, ContentChild};
class {
   @ContentChild('refoncontentformparent', {static: false}) element: ElementRef;
}
*/





//? providers
//? В метаданных компонента providers можно использовать сервис, который будет доступен во всех дочерних компонентах, за пределами этого дерево сервис будет не доступен. Также, если в дочернем компоненте еще раз определить сервис в providers, то этот компонент и все ниже, будут использовать один экземпляр сервиса, а выше, другой. Получится будет много экземпляров сервисов





//?================================================================================================================================================
//? /Dynamic components/Динамические компоненты/
// https://angular.io/guide/dynamic-component-loader
// https://angular.io/api/core/ViewContainerRef

//? ViewContainerRef
//? Динамическое обращение с контентом компонента или директивы

//? createComponent
//? Компоненты создаются динамически с помощью ViewContainerRef.createComponent, данный метод вставляет созданный компонент в хост элемент, к которому применен ViewContainerRef





//?================================================================================================================================================
//? /Templates/Шаблоны/
// https://angular.io/guide/interpolation#preventing-name-collisions
// https://angular.io/guide/template-reference-variables

//? В шаблонах можно вызывать функции, вставлять переменные, выражения, получать значения по условию, но нельзя делать какие то присваивания, некоторые операторы es5, инкремент и декремент, и объединять выражения через , или ;


//? Выражения должны быть очень простыми, т.к. они вызываются после каждого цикла обнаружения изменений, поэтому лучше их логику сократить


//? Можно использовать переменные определенный структурной директивой
/*
<ul>
    <li *ngFor="let customer of customers">{{customer.name}}</li>
</ul>
*/
//? Переменные шаблона, тут мы берем инпут и обращаемся к его значению
/*
<div>
    <input type="text" #input (input)="setValueFromInput(input.value)">
    <p>Значение из инпута: {{valueFromInput}}</p>
</div>
*/


//? В шаблоне могут быть одинаковые переменные, ангуляр будет использовать следующую логику для определения контекста, откуда взять переменную
//? 1) Имя переменной шаблона
//? 2) Имя в контексте директивы
//? 3) Имена членов компонента


//? К переменным определенным по вложенности выше(т.е. они являются в родительской области, скажем так) можно обращаться детям ниже по дереву
//? тут пример на одной вложенности, но не совсем, ngIf оборачивает контент в ng-template, поэтому он находися в дочерней области, поэтому можно получить доступ к переменной шаблона
/*
<input #ref1 type="text" [(ngModel)]="ref1Value">
<p *ngIf="true">Значение инпута: {{ref1.value}}</p>
*/


//? Можно объявить переменные входящие, которые зависят от внешних данных, а также можно ссылаться на ng-template
//? можно сослаться на переменную выше объявленную в цикле и переопределить ее, под каким нибудь другим именем будет доступна
/*
<ng-template #hero let-hero let-i="index" let-odd="isOdd">
    <div [class]="{'odd-row': odd}">{{i}}:{{hero.name}}</div>
</ng-template>


тут я ссылаюсь в ng-template на переменную выше объявленную в цикле, так можно переопределять под каким именем будет доступна переменная
<ng-container *ngFor="let name of names;">
    <ng-template let-item="name" #nameRef>
        <div>{{name.name}}</div>
    </ng-template>

    <ng-container [ngTemplateOutlet]="nameRef"></ng-container>
</ng-container>
*/



//? NgtemplateOutletGuard - статические методы, которые можно использовать для типизацию шаблонов, где используются структурные директивы





//? /Binding/Привязка/[]
// https://angular.io/guide/property-binding
// https://angular.io/guide/attribute-binding

//? Привязка - это привязывание изменения свойства класса, к свойству DOM элемента, либо же привязать к пропсу, который принимает дочерний компонент через Input
//? без скобок данное выражение справа будет расценено как обычная строка
/*
<img [src]="itemImageUrl">
*/


//? Также можно привязывать аттрибуты, для этого есть много разных директив, [attr], [class], [style] и т.д.
/*
<p [attr.attribute-you-are-targeting]="expression"></p>
<li [style.color]="'red'">В виде строки конкретный стиль</li>
<li [class.boolean]="true">Привязать конкретный класс вычесленным значением true</li>
*/




//? /Event/События/
// https://angular.io/guide/event-binding

//? Прослушивать события на элементах можно через (), куда в скобки передаем событие, которое будем слушать, либо же пользовательское событие через @Output EventEmitter
//? чтобы получить обьект события, нужно в метод прокинуть $event переменную, зарезервированную ангуляром





//? /2 way binding/Двухсторонняя привязка/
// https://angular.io/guide/two-way-binding
// https://www.youtube.com/watch?v=vkmwbZV-ob8

//? Для сокращения кода, можно писать более лакончиную связку одного и того же свойства в родительском и дочернем компонентах
//? для этого нужно в дочернем сделать инпут и аутпут, а аутпут свойсто нужно назвать также как входящее, но добавить обязательно Change к имени, иначе работать не будет

//? Также можно использовать ngModel на инпуте, чтобы при изменении сразу записывать новое значение
/*
Родитель
public twoWayBindValue: any;
public onInputChange(data: string): void {
    this.twoWayBindValue = data;
}

<p>Значение в родителе 2 сторонняя привязка {{twoWayBindValue}}</p>
<input type="text" #inputRef (input)="onInputChange(inputRef.value)">
<div app-binding-child
    [(text)]="twoWayBindValue"
></div>

<h4>NgModel метод</h4>
<input type="text" [(ngModel)]="twoWayBindValue">


Ребенок
@Input() public text: string;
@Output() public textChange: EventEmitter<string> = new EventEmitter();         событие должно быть названо также как свойство входящее + Change

public onChangeInput(event: Event): void {
    this.text = (event.target as HTMLInputElement).value;
    this.textChange.emit(this.text);
}

<p>Значение привязки в дочернем компоненте {{text}}</p>
<input type="text" (input)="onChangeInput($event)"/>
*/





//? /ng-container/
// https://angular.io/api/core/ng-container

//? Для группировки тэгов, к контейнеру могут быть применимы директивы. Также эта обертка не отображается в доме, аналогия - react.fragment, просто, чтобы сгруппировать тэги

//? Очень часто применяют к контейнеры директиву NgTemplateOutlet, которая вставляет TemplateRef в шаблон

//? ngComponentOutlet для рендера компонентов, а также туда можно прокидывать input/injector/ и тд












//!================================================================================================================================================
//? /Directives/Директивы/
// https://angular.io/guide/built-in-directives

//? Директива - класс, который добавляет поведение к элементам приложения
//? В angular 3 типа директив:
//? 1) компоненты - директивы с шаблоном
//? 2) директивы атрибутов - они меняют внешний вид или поведение компонента или другой директивы
//? 3) структурные директивы, они меняют дом


//? Самые распространенные директивы: *ngFor, *ngIf, *ngSwitchCase


//? В директиве работают некоторые хуки жизненного цикла
//? 1) ngOnInit
//? 2) ngDoCheck
//? 3) ngAfterContentInit
//? 4) ngAfterContentChecked
//? 5) ngAfterViewChecked





//? Directive
// https://stackoverflow.com/questions/49746274/how-to-use-exportas-in-angular-5-on-directives-to-get-its-reference-in-the-templ
//? exportAs - то, как в шаблоне можно обращаться напрямую к классу директивы и вызывать методы её






// https://stackoverflow.com/questions/41789702/how-to-use-angular-structural-directive-with-multiple-inputs
// https://gist.github.com/JanMalch/800cc0e1e448961fa5d93289e24e26fb
//? Структурные директивы пишутся с синтаксисом *. В нее можно заинжектировать templateRef(она сама обернет компонент в шаблон), и viewContainerRef(манипуляции с данным представлением), и с помощью них можно управлять контентом.
//? Синтаксис привязки странный:
/*
@Directive({
    selector: '[test]'
})
export class TestDirective {
    constructor(
        protected templateRef: TemplateRef<HTMLElement>,
        protected viewContainerRef: ViewContainerRef,
    ) {}

    @Input() public set test(data: boolean) {
        console.log(3);
        console.log(this);
        if (data) {
            this.viewContainerRef.createEmbeddedView(this.templateRef);
        } else {
            this.viewContainerRef.clear();
        }
    }

    @Input() set testBla(data: any) {
        console.log(data);
    }
}
<button *test="true;bla:12323">BUTTON</button>


type BaseContext<T = unknown> = Record<'$implicit' | 'letVariable', T>

type Context<T> = T & BaseContext<T>

type IfExtendsBaseContext<T, R> = T extends Partial<BaseContext> ? never : R

type ReturnNotExtendsBaseContext<T> = T extends object ? Context<T> : BaseContext<T>;

type ReturnContextType<T> = IfExtendsBaseContext<T, ReturnNotExtendsBaseContext<T>>

@Directive({
    standalone: true,
    selector: '[letVariable]',
    exportAs: 'letVariable',
})
export class LetVariableDirective<T> {
    protected readonly viewContainerRef = inject(ViewContainerRef);
    protected readonly templateRef = inject(TemplateRef);

    private view?: EmbeddedViewRef<ReturnContextType<T>>;
    private context?: ReturnContextType<T>;

    @Input() public set letVariable(data: T) {
        this.context = {
            $implicit: data,
            letVariable: data,
            ...(typeof data === 'object' ? data : {}),
        } as ReturnContextType<T>;

        if (this.view) {
            this.view.context = this.context;
            return;
        }

        this.view = this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    }

    @Input() public set letVariableRecreate(data: unknown) {
        this.recreateView();
    }

    public recreateView(): void {
        this.view = this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    }

    public static ngTemplateContextGuard<T>(_: LetVariableDirective<T>, _ctx: unknown): _ctx is ReturnContextType<T> {
        return true;
    }
}

<ng-container *letVariable="{
    id: column.name | idTemplate : element.element$,
    bla,
} as vm; recreate: recreate; let default; let id='id'; let bla='bla'">
*/















//!================================================================================================================================================
//? /Decorators/Декораторы/

//? /HostListener/
//? Объявляет событие dom для прослушивания и предоставляет метод обработчик
//? можно использовать глобальные события как префикс: document, window, body

//? HostListener будет вызывать цикл обнаружения каждый раз при событии, поэтому он не будет корректно работать с runOusideAngular.
/*
@HostListener('window:keydown.enter', ['$event'])
handleKeyDown(event: KeyboardEvent) {
    this.counter++;
}
*/




//? /HostBinding/
// https://angular.io/api/core/HostBinding

//? Привязать свойство dom к хост элеенту, при его изменении будет автоматом изменяться свойство
//? работает - когда цикл обнаружения изменений срабатывает в родителе - тогда обновит данный компонент, вместо него можно использовать renderer2 чтобы обновлять без вызова цикла обнаружения изменений













//? /Renderer/
// https://angular.io/api/core/Renderer2#createelement

//? С этим классом можно манипулировать элементом, менять стили, классы, добавлять тэги, элементы и т.д.
//? можно не использовать - там минорные какие то штуки есть, для чего он нужен(если приложение кросспратформенное)



















//!================================================================================================================================================
//? /Services/DI/Dependency Injection/Внедрение зависимостей/
// https://angular.io/guide/dependency-injection-providers
// https://angular.io/api/core/Injectable
// https://www.youtube.com/watch?v=fALKYP8voBQ&ab_channel=JavaScript.ru
// https://www.youtube.com/watch?v=u6gAVCEJjQ4&t=860s&ab_channel=devschacht


//? Логика работы подхода примерно такая: существует некий контейнер(коробка), где лежат все необходимые нам для внедрения сервисы, переменные и т.д, неважно что, и мы при инжектировании зависимостей достаем уже экземпляр класса, эта коробка сама создает внутри себя этот экземпляр и отдает нам его, также она может отдавать не только именно это экземпляр, но и создать другой экземпляр этого же класса.


//? В декораторе сервиса можно переопределить, какие значения будут инжектированы, когда мы будем указывать токен определенный
//? Когда мы опрделяем провайдера, сервис в providers массиве, под капотом ангуляр преобразует запись в более простую
/*
providers: [Logger]
в
providers: [
    {
        provide: Logger,
        useClass: Logger
    }
]
*/


//? Provider имеет provide свойство, где указывается токен, по которому инжектироваться значение, а вторым свойством может быть:
//? 1) useClass - класс для инжектирования(можно указать любой класс)
//? 2) useValue - мы можем передать любое значение, которое будет инжектировано
//? 3) useExisting - если мы хотим использоватьиспользуется с forwardRef(https://angular.io/api/core/forwardRef) 
//? 4) useFactory - функция используется, чтобы мы сами определили, какой класс или функционал мы хотим внедрить. Тут в этой функции мы можем вызвать по условию конструктор и вернуть его, либо же вернуть простой обьект и т.д.


//? Также мы можем подменять эти инжектируемые значения в модуле, где можно в функцию useFactory прокидывать зависимости, которая нам необходима при инжектировании через useFactory. Чтобы прокинуть какой то сервис или сущность, нужно, чтобы она была доступна для инжектирования, в массив deps зависимости для функции указываются
//? multi отвечает, что при инжектировании сущности будут помещены в массив, т.е. если в классе мы инжектируем mainService, то все, что возвращает этот инжектор, будет собрано в массив
/*
{
    provide: MainService,
    useFactory: (data: SecondService) => {
        console.log(data);
        return new MainService();     также можно просто создать класс
        return data;      можно просто вернуть класс уже готовый и т.д.
    },
    deps: [SecondService],
    multi: true,
},
*/



//? /Inject/
//? Данные, которые нам нужно заинжектировать в компонент или сервис, нужно пометить через @Inject декоратор
//? он инжектирует данные в сущность



//? /InjectionToken/
// https://angular.io/api/core/InjectionToken
//? Создается токен, по которому можно далее инжектировать значения
// new InjectionToken<string>('BASE_URL');
/*
**
***
****
*****/
//? /Lightweight token//





//? В ленивых модулях сервисы не доступны вне их, т.к. они ничего не знают о них


//? /providedIn/
//? any - все сервисы в ленивых модулях получат уникальный экземпляр класса, в обычных модулях будет синглтон
//? root - для всего приложения
//? platform - для всех приложений на странице




//? Сервисы являются синглтонами, если:
//? они объявлены в главном модуле
//? в главный модуль импортируется модуль, который уже содержит сервис


//? Создадутся заново:
//? Если в ленивом модуле зарегестрирован сервис и у него providedIn root, то он будет доступен во всем приложении, но в самом модуле будет создан новый экземпляр(а значит и в сборке он будет не лениво заргужен, данный сервис, потому что он уже инжектируется вне ленивого модуля)
//? Если в ленивом модуле зарегестрирован сервис с пустым декоратором, то будет экземпляр только на уровне модуля(всё загружено будет лениво)
//? providers & viewProviders компонента или директивы
//? если модуль содержащий service будет в imports у ленивого модуля - то будет также создан новый обьект





//? /Optional/
//? Декоратор инжектирования, чтобы не выдавать ошибку, если не найдет сущность для инжектирования


//? /SkipSelf/
//? Начать поиск с родительского elementInjector


//? /Self/
//? Найти сущность только в этом elementInjector


//? /Host/
//? это ограничитель поиска - последнее место где может найти сущность - это VIEW родителя(viewProviders), в котором создан данный компонент/директива
//? skipSelf and host - поиск пропустит данный инжектор и закончит искать в родительском viewProviders в котором создана наша сущность




//? /forRoot/forChild/
//? static forRoot(): ModuleWithProviders<DocumentsModule>
//? заводится статический метод который будет возвращать по токену класса модуля провайдеры и только провайдеры, то есть мы все декларации и тд подключаем также в декоратор модуля, но провайдеры мы помещаем в метод forRoot который вернет токены для DI





//? /ContentChild/Bridge/
//? мы можем работать с абстракцией через contentChild, по токену мы можем получить дочерний компонент - любой, который будет зарегистрирован по этому токену у себя в массиве providers
/*
const TOKEN = new Token()

class Parent {
    @ContentChild(TOKEN) child: any;
}

@Component({
    providers: [
        {
            provide: TOKEN,
            useExisting: Child
        }
    ]
})
class Child{}
*/
/*
**
***
****
*****/
//!================================================================================================================================================
//? /Pipes/Пайпы/
// https://angular.io/guide/pipes
//? Пайпы применяются для модифицирования данных в шаблоне, преобразования какого то

//? Есть 2 вида пайпов: чистые(по дефолту) и грязные
//? Чистые пайпы не вызываются, если входящие параметры не изменились, грязные - вызваются. Таким образом, если нам нужен метод преобразования в шаблоне можно обходить то, что он будет вызываться при каждом цикле обнаружения изменений, purepipe в этом помогают










//!================================================================================================================================================
//? /Modules/Модули/NgModule/
// https://angular.io/guide/frequent-ngmodules
// TODO https://angular.io/guide/hierarchical-dependency-injection

//? В приложении есть всегда один главный модуль. В Модуле определяются компоненты, которые определены в данном модуле, сервисы, также в модуль нужно импортировать другой модуль, функционал которого нам необходим в этом модуле. Также модули экспортируют функциональность, чтобы при импорте этого модуля в другие, мог передать функционал

//? @NgModule декоратор используют для определения модуля

//? declarations - компоненты, директивы, пайпы
//? exports - функционал для экспортирования
//? providers - сущности для инжектирования в модуле. Сервисы, резолверы и.д., кастомные сущности, доступные для инжектирования типа Provider
//? bootstrap - главный компонент входной приложения, который будет запущен. DoBootstrap может заменить этот параметр
//? entryComponents - динамические компоненты, котрые в шаблоне напрямую не вызваются
//? jit - тип компиляции модуля
//? id - id модуля, который может быть получен через getNgModuleById


//? Есть разные типы модулей
//? shared - для компонентов и тд которые общие для приложения - не должны содержать провайдеры
//? widget - тоже для компонентов и тд, но которые более узконаправленные и подключаются точечно - не должны содержать провайдеры
//? services - для сервисов и переиспользования
//? routing - роутинг




//? Lazyloading
//? для ленивого модуля создается отдельный инжектор, т.е. там будут новые экземпляры сервисов создаваться, если мы импортируем sharedModule в разные модули приложения





//?================================================================================================================================================
//? /DoBootstrap/
// https://angular.io/api/core/DoBootstrap

//? Данный хук вызывается на главном модуле приложения, если в главном модуле массив bootstrap не предоставлен, это ручной запуск приложения
//? принимает в себя ApplicationRef, где нам нужно вызвать bootstrap метод, который переданный компонент сделает главным в приложении










//!================================================================================================================================================
//? /Routing/Навигация/

//? /RouterModule/
//? Для работы с маршрутизацией необходим этот модуль
//? Все пути указываются в обьекте и прокидываются первым параметром в метод forRoot или forChild, вторым параметром идет обьект настроек ExtraOptions
//? все роуты должны быть в порядке от самого точного к наименее точному маршруту, т.к. используется стратегия первого совпадения





//? /Стратегии навигации приложения/
// https://angular.io/api/common/APP_BASE_HREF
// https://angular.io/guide/router#base-href-1
//? Чтобы в приложении использовать html5 стратегию навигации(pushState, добавление адреса в историю без запроса на сервер), тоже самое, что и путь файла на сервере, в index.html приложения нужно добавить <base href="/"> тэг сразу в head тэге, либо можно APP_BASE_HREF инжектировать в приложение


//? /HashLocationStrategy/
// https://angular.io/api/common/HashLocationStrategy
// https://angular.io/guide/router#hashlocationstrategy




//? /Base/Base href
// https://angular.io/guide/router#base-href
//? Этот тэг добавляется в head, чтобы указать относительно какого пути загружать изображения, css и т.д.





//? /Route/
//? Настройка роута конкретного
//? 1) path - путь, по которому будет доступен компонент. ** - используется для любого маршрута, который не был найден(404 error), '' - дефолтный маршрут. Также можно использовать параметры маршрута :id вот так они указываются, динамический путь зависит от id
//? 2) component - компонент для отображения
//? 3) redirectTo - редирект с этой страницы
//? 4) children - дочерние маршруты для данного маршрута, массив Route, обязательно в него нужно передать дочерние роуты, а также для данного компонента прописать директиву router-outlet
//? 5) resolve - классы, которые вызываются перед тем, как отобразить данный роут, пока они не отработают, страница не будет показана, также используются, чтобы прокинуть данные в компонент через ActivatedRoute
//? 6) loadChildren - функция колбэк, где import вызывается и лениво загружается модуль(нельзя использовать вместе с component, потому что так ленивая загрузка не будет работать). По дефолту будет из лениво загруженного модуля показываться роут с '' путем. Внутри таких модулей используется forChild методы для регистрации роутов, нужно вернуть либо модуль либо пути дочерние. ОБЯЗАТЕЛЬНО ВОЗВРАЩАЕТ МОДУЛЬ, если главный компонент инжектирует провайдеров из этого модуля.
//? 7) canActivate - можно ли активировать КОМПОНЕНТ - если уже активирован - вызван больше не будет
//? 8) canActivateChild - можно ли активировать дочерние КОМПОНЕНТЫ
//? 9) canDeactivate - можно ли уйти со страницы
//? 10) canMatch - можно ли загрузить и в целом сопоставить данный роут, будет вызван для всех роутов абсолютно по данному пути test/test2/test3 - то есть для каждого из этих путей будет вызван свой canMatch - при абсолютно любом изменении навигации
//? 11) pathMatch - точность совпадения пути. Может быть 'full или prefix', prefix по дефолту
//? 12) matcher - https://angular.io/guide/routing-with-urlmatcher кастомный сопоставитель пути
//? 13) data - данные для прокидывания в этот путь


//? последовательность - canMatch -> canActivate





//? /ExtraOptions/
// https://angular.io/api/router/ExtraOptions

//? Настройки роута главного родительского модуля
//? 1) preloadingStrategy - https://angular.io/api/router/PreloadingStrategy стратегия загрузки модулей, либо не предзагружать, либо после того, как главный модуль загружен, чтобы приложение могло работать, а затем остальные в фоне загружать
//? 2) enableTracing - 
//? 3) useHash - использовать ли стратегию хэшей в путях приложения
//? 4) initialNavigation - 
//? 5) errorHandler - 
//? 7) onSameUrlNavigation - 
//? 8) scrollPositionRestoration - 
//? 9) anchorScrolling - 
//? 10) scrollOffset - 
//? 11) paramsInheritanceStrategy - 
//? 12) malformedUriErrorHandler - 
//? 13) urlUpdateStrategy - 
//? 14) relativeLinkResolution - 
//? 15) canceledNavigationResolution - 





//? /ActivatedRoute/
// https://angular.io/api/router/ActivatedRoute
//? Информация о текущем роуте
//? можно получить доступ до snapshot(текущий снимок), т.е. при создании какие данные имеет данный роут, также можно подписываться на изменения параметров, пути и т.д




//? /Resolve/Резолвер/
// https://www.digitalocean.com/community/tutorials/angular-route-resolvers
// https://angular.io/api/router/Resolve
//? Вызывается перед тем, как отобразить страницу, их надо также определить в providers массиве модуля

//? данные класс реализует метод, который должен вернуть данные, которые попадут в activatedRoute.data, где дальше можно их использовать





//? /RouterLink/
// https://angular.io/api/router/RouterLink
//? Директива для навигации, которая применяется к ссылке, также имеет дополнительные входные параметры queryParams, fragment и т.д
//? пути можно задавать как относительные, так и абсолютные от корня приложения




//? /RouterLinkActive/
// https://angular.io/api/router/RouterLinkActive
//? Добавляет активный класс ссылке

//? routerLinkActiveOptions - параметры директивы
//? isActiveChange - событие смены активного и неактивного состояния





//? /RouterOutlet/
// https://angular.io/api/router/RouterOutlet
//? Директива, на месте которой будет рендерится компонент при совпадении пути, также должна вызываться в дочерних компонентах, если таковые есть в дочерних роутах


//? Можно использовать несколько директив сразу, т.е. будто будет 2 независимых роутинга в приложении, данный подход не работает ТОЛЬКО в лениво загруженных модулях
//? ниже пример, как настраивать и использовать данный подход
/*
{
    path: 'compose',
    component: ComposeMessageComponent,
    outlet: 'popup'
}

<a [routerLink]="[{ outlets: { popup: ['compose'] } }]">Contact</a>
<router-outlet name="popup"></router-outlet>
*/




//? /Router/
// https://angular.io/api/router/Router
//? Роутер, для навигации по проекту, работа с url
//? все данные по роутингу приложения а также работа с ним
/*
**
***
****
*****/
//? /Component less/Empty path/Пустой путь/
// https://www.youtube.com/watch?v=2QgcMLAmm1s
//? Можно использовать пустой путь, и в children поместить пути и компоненты, для которых нужны одни и те же guards/resolvers чтобы не вызывать одни и те же для разных роутов









//!================================================================================================================================================
//? /ReactiveForm/Формы/
// https://angular.io/guide/reactive-forms

//? /ReactiveFormsModule/
//? Модуль дает возможность использовать директивы реактивных форм, например formControl


//? /FormControl/
//? Создает контрол формы
//? нужно привязать конкретный экземпляр контрола к нужному элементу форму через эту директиву, если не хотим создавать переменную для контрола, то можно обойтись formControlName



//? /FormControlName/
//? Привязывает имя контрола из формы к конкретному элементу формы, таким образом можно не создавать переменную контрола




//? /FormGroup/
//? Создает группу формы, в которую передаются контролы, которые объеденены будут в целую форму
//? чтобы прослушивать отправку формы, на форму можно повесить ngSubmit форму встроенную




//? /FormBuilder/
//? Создание динамических форм




//? /Validators/AsyncValidators/Валидаторы/Асинхронные валидаторы/
//? В реактивных формах это либо просто функции, которые передаются в настройки, либо можно создавать инжектируемые классы, которые можно также использовать, и оттуда дергать метод validate




//? /Classes/
//? Каждый контрол имеет классы в соответсвии со своим статусом
//? ng-valid, ng-invalid и т.д.










//!================================================================================================================================================
//? /HTTPClientModule/Server/Сервер

//? Чтобы использовать http для запросов, в приложение нужно импортировать HttpClientModule, который предоставляет httpClient для работы с запросами




//? Методы запроса могут отдавать разные виды ответа, json, просто обьект



// https://angular.io/guide/http#starting-the-request
//? при каждой подписке будет сделан новый запрос
/*
const req = http.get<Heroes>('/api/heroes');
req.subscribe();
req.subscribe();
*/




//? JSONP
// TODO https://angular.io/guide/http#making-a-jsonp-request




//? Обработка ошибок
//? В pipe можно retry оператор засунуть, который будет несколько раз делать запрос
//? catchError будет ловить ошибку




//? Добавление параметров запроса, queryParams
// https://angular.io/guide/http#configuring-http-url-parameters
//? HttpParams используется, чтобы добавить параметры в запрос




//? /Interceptor/Перехватчик/
//? Запросы можно перехватывать, и добавлять параметры и вообще как то их модифицировать
//? для этого создается класс который реализует HttpInterceptor, он также является внедряемым
//? перехватчики работают во всем приложении, если модули ленивые, там работать не будут

//? перехватчики выполняются один за одним во всем приложении и потом идет отправка запроса на сервер, после этого ответ будет снова направлен перехватчикам и только потом он дойдет до места, где был вызов запроса на сервер

//? Между перехватчиками можно обмениваться данными через context, туда можно передавать нужные значения





//? Можно изменять дефолтные значения coockie с помощью HttpClientXsrfModule










//!================================================================================================================================================
//? /Интернационализация/
// TODO https://angular.io/guide/i18n-common-overview










//!================================================================================================================================================
//? /Animations/Анимации/
// TODO https://angular.io/guide/animations










//!================================================================================================================================================
//? /ServiceWorker/
// TODO https://angular.io/guide/service-worker-intro










//!================================================================================================================================================
//? /WebWorker/ВебВоркер/
// TODO https://angular.io/guide/web-worker










//!================================================================================================================================================
//? /SSR/ServerSiteRendering/
// TODO https://angular.io/guide/universal










//!================================================================================================================================================
//? /Configuration angular.json/Конфигурация/
// https://angular.io/guide/workspace-config
// https://angular.io/guide/npm-packages


/*
**
***
****
*****/
//!=============================================================================
//? //
//? НИКОГДА НАХУЙ НЕ НУЖНО ДЕЛАТЬ $Params как в абстрактном компоненте - нужно чтобы была динамика - нужно каждое свойство выносить ОТЕДельным инпутом






// 26 декабря





// Быв авы быв афыва ыфв а два ыфв а






// Маша учила splice/indexOf и решала задачу
// Я немного на нее прикрикнул

// В последнее время я стал много быть ею недовольным, почему не знаю, как будто я чувствую, что делаю больше и мне это не нравится
// Также есть обида, что я очень много работал, чтобы стать программистом а она не делает так же много, хотя сравнивать людей не всегда корректно и разные ситуации жизненные
// В общем я высказывать слишком много стал и много говорить плохого, возможно также - потому что я себя считаю молодцом, потому что занимаюсь спортом и тд и уделяю себе много времени, а она в течении года много раз говорила, что я не так учу программированию и тд, и в итоге мне теперь сложно воспринимать ее по другому

// Вечером был разговор из которого выяснили, что мне нужно:
// Быть более общительным и делиться радостями(например я прошел собеседование, почему бы не порадоваться)
// Также больше поддержки
// меньше тычков с моей стороны, и что советы нужно принимать только когда просят
// больше ободрение
// больше сюрпризов как с мороженным


// Что для нее важно
// Семья
// Самореализация
// Походы/время с друзьями/танцы/пение/

// Хочет быть маленькой девочкой и чтобы я к ней относился со снисходительностью, ведь я мужчина и мне нужно больше делать, поэтому я работал больше в учении проги и тд, потому что грубо говоря это мне это важнее, чем ей
// Возможно это и так

// Что я выяснил для себя: что она не хочет быть «родить ребенка и сказать «ну все, я все сделала - остальное это тебе муженек»», что всегда хочет развиваться и тд в чем ей интересно и легко(вот тут я с этим не согласен - я считаю надо - значит надо)
// Что хочет делать вещи, которые идут легко потому что она не любит делать через силу, не любит заставлять себя(заставлять может себя только что то связанное с работой)
// что она готова если что работать за нас двоих когда я в депрессии и тд
// что после рождения ребенка продолжит жить и разиваться и тд




// я сказал, что мне важно самореализация и семья
// также что я не люблю политкорректность и если людей что то не устраивает в друг друге - то разойтись - нормально


















/*
? с папой разговаривал насчет обучения маши(куала лумпур, когда в магазин ходил за том ямом), он сказал что под женщин прогибаться нельзя, что детей и тд нужно захотеть по собственному желанию и вообще, он скзаал, что мужчина ничего не обязан и брать на себя больше ответственности чем можешь - путь в никуда
? он сказал что с мамой ему очень повезло и он доволен супружеской жизнью, мама очень понимающая, а папа чувствует себя перед ней виноватым (много где видимо косячил)

? а насчет женщин в целом он сказал, если попадется которая пилит и тд то 2 выхода - либо развод либо веревка
? идеально - когда женщина молится на мужчину, когда он для нее все, и что женщинам переживать проще - нас сложнее это дается
? также говорил, что машу нужно тоже ценить за то, что делает, ну а если и что то не так - то мне точно не нужно переживать, главное это Я - я живу для себя в первую очередь

? был вопрос, открыывается от программирования или закрывается (то есть истинное лицо) (тут я скажу от себя, что маша всегда была хорошей булочкой, кроме как с программированием)



? хороший был разговор с папой, после этого я понял, что хочу проводить много времени с семьей, так долго в поездке и такой долгой разлуки еще не было(кроме армии), а еще переживания насчет уезда в америку, что вдруг кого то из них я больше никогда не увижу
*/