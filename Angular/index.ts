//!================================================================================================================================================
//? /AOT/Компиляция/
//? Когда включен, при сборке будет собран js код оптимизированный, а также скомпилирует предварительную версию приложения
//? Сразу в бандл попадут стили и шаблоны
//? Меньший размер машины фреймворка, который запускает код
//? Ошибки на этапе сборки
//? Компилирует html заранее, поэтому лучше проверяются шаблоны на наличие уязвимостей










//!================================================================================================================================================
//? /IncrementalDom/
//? Каждый компонент компилируется в набор инструкций, и когда инструкция меняется, то точечно перерисовывается реальный DOM.
//? В отличии от virtualDom ангуляр не создает компию всего дерева компонентов, из за этого очень сильно экономится память.









//!================================================================================================================================================
//? /API/
// https://angular.io/api










//!================================================================================================================================================
//? /Components/Компоненты/
// https://angular.io/guide/lifecycle-hooks

// https://habr.com/ru/company/infopulse/blog/358860/       обнаружений изменений
// https://habr.com/ru/post/327004/

//? @Component декоратор используется для пометки компонентов, наследуется от декоратора директивы
//? Все компоненты, которые мы хотим использовать в модуле, должны быть объявлены в модуле

//? Принимает обьект настроек:
//? 1) changeDetection
//? 2) encapsulation
//? 3) selector
//? 4) styles - стили в строку компонента
//? 5) stylesUrls - ссылки на стили         Стили также можно подключать через link, в шаблоне компонента
//? 6) template - верстка в строку
//? 7) templateUrl - ссылка на верстку
//? 8) providers - массив сервисов доступных для инжектирования вниз по дереву
//? 8) viewProviders - массив сервисов доступных для инжектирования в данном представлении, проецируемый контент, например в данный компонент не будет инжектировать сущности в viewProviders
//? 9) standalone - boolean, можно ли не объявлять в модуле, но требуется напрямую импортировать зависимости в imports
//? 10) imports - импорты компонента при standalone
//? 11) schemas - 





//?================================================================================================================================================
//? /ChangeDetection/стратегии обнаружения изменений/DetectionStrategy/
// https://medium.com/@overthesanity/zone-js-%D0%BE%D1%82-%D0%B0-%D0%B4%D0%BE-%D1%8F-fdb995917968
// https://www.youtube.com/watch?v=2cV4i-g6Oxc&ab_channel=Angular-%D0%BC%D0%B8%D1%82%D0%B0%D0%BF%D1%8B%D0%B8%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F
// https://habr.com/ru/company/infopulse/blog/358860/
// https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html
// https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html


//? NgZone под капотом создает контексты выполнения, следит за тем, когда завершилась та или иная асинхронная операция и вызывает методы обнаружения изменений. Зона оборачивает все асинхронные операции в hoc, модифицируя их.



//? Стратегии обнаружений работают следующим образом:
//? Проверка изменений запускается с самого верхнего уровня и вниз по дереву на любые асинхронные операции, обработчики событий, изменения инпут параметров, асинхронные пайпы.
//? если компоненты default стратегию имеют, то они будут перерисовываться на любую аснихронную операцию, обработчики, инпут параметры, асинхронные изменения пайпа. Также они будут запускать для дочерних компонентов changeDetection.
//? если компонент onPush - то он будет перерисовываться только при изменении инпут параметров, на обробатчики событий в самом компоненте, либо на обработчики событий запущенные из дочерних компонентов. Обработчики событий из дочерних компонентов запускают и почему то заставляют проверить все компоненты с onpush стратегией вниз по дереву до компонента, где этот обработчик был вызван. Также если компонент является onPush цикл обнаружений не зайдет в него, если только его не пометить markForCheck, detectChanges не вызвать в нем, или же если же обработчик был вызван в нем либо ниже по дереву.


//? Default - запускает цикл при любой асинхронной операции, изменении значения переменной, обработчиках событий.


//? OnPush - при изменении инпут параметрах, обработчиках в компоненте и ниже по дереву, а также при явном вызове обнаружения изменений, detectChanges, markForCheck, ApplicationRef.tick из самого компонента




//? Чтобы отслеживать асинхронные изменения, нужно инжектировать ChangeDetectorRef и вызывать методы соответствующие.
//? 1) markForCheck - помечает явно компонент и все родительские, чтобы его проверить снова при следующем цикле, не запускает цикл самостоятельно
//? 2) detach - отсоединяет компонент от проверок. Он ничего не будет отрисовывать, пока его снова не подключить или вызвать метод detectChanges(при отключенной проверки, хук onChanges все равно будет запускаться в компоненте)
//? 3) detectChanges - происходит запуск цикл с данного компонента и вниз по дереву
//? 4) reattach - заново включает в циклы обнаружения изменений
// TODO 5) checkNoChange -


//? Геттеры в шаблоне вызываются при каждом цикле обнаружения изменений, чтобы они не вызывались, нужно компонент отсоединить от проверок





//?================================================================================================================================================
// https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html
//? /NgZone/
//? Под капотом создает контексты выполнения, следит за тем, когда завершилась та или иная асинхронная операция и вызывает методы обнаружения изменений. Зона оборачивает все асинхронные операции в hoc, модифицируя их.

//? runOusideAngular - вызывает переданный колбэк вне зоны приложения, чтобы не запускать обнаружение изменений.

//? onMicrotaskEmpty - в очереди нет микрозадач

//? run - запуск синхронной задачи в зоне angular, а также все асинхронные задачи будут выполняться в зоне

//? runTask - запуск синхронной задачи в зоне angular и возвращает значение

//? runGuarded - то же что и run, только ошибки будут перехвачены

//? HostListener будет вызывать цикл обнаружения каждый раз при событии, поэтому он не будет корректно работать с runOusideAngular.






//?================================================================================================================================================
//? /LifecycleHooks/Хуки жизненного цикла/
// https://angular.io/guide/lifecycle-hooks

//? У каждого компонента есть хуки жизненного цикла:
//? 1) ngOnChanges вызывается, когда есть Input в компоненте, именно, когда мы в шаблоне прокидываем параметр из родителя без него не будет вызываться. Вызывается каждый раз при изменении входных данных, если входной параметр это обьект, то хук сработает только при изменении ссылки на входной обьект

//? 2) ngOnInit вызывается при создании компонента. Именно тут должна быть сложная логика инициализации компонента, в конструктор ее помещать не нужно, т.к. компонент должен быть очень простым в создании, а тут уже можно запихнуть логику. Максимум, что может быть в конструкторе это присвоение локальных переменных

//? 3) ngDoCheck вызывается при любом цикле обнаружения изменений во всем приложении. Использовать его не желательно, даже если компонент имеет onPush стратегию всё равно заходить будет

//? 4) ngAfterContentInit вызывается и в родительском компоненте, который прокидывает слоты в дочерний, и в дочернем, который проецирует слоты. Вызывается после вставки содержимого. Также работает в директиве

//? 5) ngAfterContentChecked вызывается постоянно после ngDoCheck в компонентах, где есть проецирование слотов. Также работает в директиве

//? 6) ngAfterViewInit вызывается разово, после отрисовки компонента или директивы, а также отрисовки всех дочерних компонентов, поэтому в нем можно получать через querySelector элементы дочерних компонентов

//? 7) ngAfterViewChecked вызывается после ngAfterViewInit и каждый раз после ngAfterContentChecked, а также после любых изменений в компоненте. Работает и в компоненте и директиве

//? 8) ngOnDestroy вызывается перед тем, как фреймворк удалит компонент. Тут помещается логика по отпискам от таймеров, подписок, и т.д, чтобы память не засорять колбэками





//?================================================================================================================================================
//? /Content projection/Проекция контента/ng-content
// https://angular.io/guide/content-projection

//? Если мы хотим спроецировать контент внуть другого компонента, нужно: в дочернем компоненте в нужном месте поместить тэг <ng-content></ng-content>
//? в родительской верстке вызвать дочерний селектор компонента и между тэгов поместить проецируемое значение, оно отобразится на месте ng-content

//? можно в тэге ng-container указать аттрибут [select] в который можно передать значение, по которому будет проецироваться определенный контент
//? например ниже, мы в дочернем устанавливаем 2 контента, с атрибутом и без, и если в родителе мы проецируем контент без аттрибута selected-content, то дефолтный контент отрисуется на месте тэга без аттрибута, а с аттрибутом, на соответствующем месте
/*
дочерний компонент
<ng-content [select]="selected-content"></ng-content>
<ng-content></ng-content>

родительский компонент, в котором мы прокидываем контент в дочерний
<div app-slot-child>
    <div class="default-content">
        Проецируемый контент дефолтный 2: {{value}}
    </div>
    <div class="selected-content" selected-content>
        Проецируемый контент select 2: {{value}}
    </div>
</div>
*/
// TODO





//?================================================================================================================================================
//? /Encapsulation/Инкапсуляция стили/
// https://angular.io/guide/view-encapsulation

//? Каждый компонент, сама оболочка(тэг, либо аттрибут, по которому создается компонент), это называется хост, host.
//? Чтобы применить стили к хост элементу, можно обратиться к нему либо из родителя напрячую по тэгу(аттрибуту специфичному для него), либо в стилях через :host {} селектор, но этот селектор работает, если у нас emulated инкапсуляция


//? Стили, примененные в компоненте в декораторе, при наследовании не наследуются

//? Стили также можно подключать через link, в шаблоне компонента


//? Есть 3 стратегии использования инапсуляции:
//? 1) None - полностью отключена
//? Такие стили будут полностью глобальными. Если в родителе отключена, а в дочернем включена инкапсуляция, то если из родителя обратиться к классу дочернего, можно переопределить стили, т.к. они будут глобальными

//? 2) Emulated(по дефолту) - на каждый компонент добавляется аттрибут уникальный для компонента, именно поэтому аттрибуту в стилях потом добавляется этот аттрибут, и стили становятся скрытыми для каждого компонента(если хост - _host<что то дальше>, если контент внутри хоста - _content<что то дальше>), они генерируются самим фреймворком, и к ним нельзя никогда обращаться в коде
//? При такой стратегии, стили заданные для дочернего хост элемента, можно перебить из родительского, просто обратившись в дочернему хосту, т.к. родительский компонент добавляет на дочерний хост такие же уникальные аттрибуты, что и на свой, именно поэтому можно переопределить только хост дочерний из родительского, внутри вложенные компоненты уже не получится

//? можно использовать host в компоненте(если none, то нельзя), чтобы из родителя достучаться до потомков используется ::ng-deep {} селектор, внутри которого пишутся стили для дочерних

//TODO ? 3) ShadowDom





//? ng-deep может пробить несколько к ряду написанных компонентов(их инкапсуляцию). Он делает этот стиль глобальным для всего проекта. Если мы и используем его, то нужно все таки точечно указывать, в каком селекторе что нам нужно поправить(делать вложенность), и лучше для каждого компонента использовать уникальный класс, также ОБЯЗАТЕЛЬНО использовать его внутри host, т.к. это повышает специфичность

//? host указывает на сам хост элемент, не доступен в none стратегии

//? host-context() - принимает класс из родителя, например .active где то в родительском компоненте, и в дочернем можно использовать его для стилезации





//?================================================================================================================================================
//? /Datapassing/Обмен данными/@Input/@Output/Component interaction/
// https://angular.io/guide/component-interaction
// https://angular.io/guide/inputs-outputs

//? Input декоратор для того, чтобы принимать в себя данные из родительского компонента. Со стратегией обнаружения onPush работает только при изменении ссылки
//? Данный декоратор можно использовать с геттером и сеттером, либо только с сеттером. При изменении входящих параметров, будет отрабатывать сеттер и будет происходить логика нами заложенная. Можно передать как аргумент имя аттрибута по которому компонент будет принимать данные




//? Output декоратор нужен для отправки события в родительский компонент
//? Создается свойство через EventEmitter украшенное декоратором, затем в компоненте есть обработчик события, на который мы эмитим событие
//? В родительском компоненте мы слушаем это созданное событие как обычный обработчик через (), а в саму функцию, которая будет вызвана эмиттером, придет $event значение, которое и содержит переданные данные из дочернего компонента. Можно передать как аргумент имя аттрибута по которому компонент будет отдавать данные




//? /ViewChild/
// https://angular.io/api/core/ViewChild
//? Принимает класс компонента, который мы отрисовываем внутри родительского. Он будет доступен как обычное свойство класса. Можно вызывать методы, и т.д.
//? Ищет в dom первый доступный компонент или директиву с таким классом, как только дом изменится, значение переменной обновится.
//? Важные моменты: если через цикл создаются компоненты, то получим самый первый компонент. Если мы получаем сервис, который объявлен для конкретного компонента в провайдерах, а этот компонент мы перебираем в цикле, то мы все равно получим сервис первого самого компонента из цикла, для остальных в цикле будут созданы другие сервисы

//? Можно использовать с сеттером или вместе с геттером и сеттером, т.е. по условию создается элемент динамически - мы в сеттере логику прописываем

//? Можно получать: через #reference или просто указть имя класса директивы или компонента
//? сервис, передав его класс
//? любой токен для инжектирования в виде строки
//? TemplateRef


//? static, можно указать, чтобы получить элемент в onInit хуке, подразумевает, что он сразу будет в шаблоне, т.е. без условий, false - по дефолту, получим только после afterViewInit, потому что элемент мог быть создан по условию.






//?================================================================================================================================================
//? ContentChild
// https://angular.io/api/core/ContentChild

//? Если мы хотим получить доступ до html, который передан от родителя и получен через ng-content, нужно в компоненте ребенка получить ссылку на этот html через ContentChild.
/*
шаблон родителя
<div>
   <child-component *ngFor="let post of posts">
      <div #refoncontentformparent>
         <p *ngIf="post.text.length > 150; else otherContent">пост длинный</p>

         <ng-template #otherContent>
            <p>пост короткий</p>
         </ng-template>
      </div>
   </child-component>
</div>

шаблон ребенка
<div>
   <div></div>
   <ng-content></ng-content>
</div>

компонент ребенка
import {ElementRef, ContentChild};
class {
   @ContentChild('refoncontentformparent', {static: false}) element: ElementRef;
}
*/





//? providers
//? В метаданных компонента providers можно использовать сервис, который будет доступен во всех дочерних компонентах, за пределами этого дерево сервис будет не доступен. Также, если в дочернем компоненте еще раз определить сервис в providers, то этот компонент и все ниже, будут использовать один экземпляр сервиса, а выше, другой. Получится будет много экземпляров сервисов





//?================================================================================================================================================
//? /Dynamic components/Динамические компоненты/
// https://angular.io/guide/dynamic-component-loader
// https://angular.io/api/core/ViewContainerRef

//? ViewContainerRef
//? Динамическое обращение с контентом компонента или директивы

//? createComponent
//? Компоненты создаются динамически с помощью ViewContainerRef.createComponent, данный метод вставляет созданный компонент в хост элемент, к которому применен ViewContainerRef





//?================================================================================================================================================
//? /Templates/Шаблоны/
// https://angular.io/guide/interpolation#preventing-name-collisions
// https://angular.io/guide/template-reference-variables

//? В шаблонах можно вызывать функции, вставлять переменные, выражения, получать значения по условию, но нельзя делать какие то присваивания, некоторые операторы es5, инкремент и декремент, и объединять выражения через , или ;


//? Выражения должны быть очень простыми, т.к. они вызываются после каждого цикла обнаружения изменений, поэтому лучше их логику сократить


//? Можно использовать переменные определенный структурной директивой
/*
<ul>
    <li *ngFor="let customer of customers">{{customer.name}}</li>
</ul>
*/
//? Переменные шаблона, тут мы берем инпут и обращаемся к его значению
/*
<div>
    <input type="text" #input (input)="setValueFromInput(input.value)">
    <p>Значение из инпута: {{valueFromInput}}</p>
</div>
*/


//? В шаблоне могут быть одинаковые переменные, ангуляр будет использовать следующую логику для определения контекста, откуда взять переменную
//? 1) Имя переменной шаблона
//? 2) Имя в контексте директивы
//? 3) Имена членов компонента


//? К переменным определенным по вложенности выше(т.е. они являются в родительской области, скажем так) можно обращаться детям ниже по дереву
//? тут пример на одной вложенности, но не совсем, ngIf оборачивает контент в ng-template, поэтому он находися в дочерней области, поэтому можно получить доступ к переменной шаблона
/*
<input #ref1 type="text" [(ngModel)]="ref1Value">
<p *ngIf="true">Значение инпута: {{ref1.value}}</p>
*/


//? Можно объявить переменные входящие, которые зависят от внешних данных, а также можно ссылаться на ng-template
//? можно сослаться на переменную выше объявленную в цикле и переопределить ее, под каким нибудь другим именем будет доступна
/*
<ng-template #hero let-hero let-i="index" let-odd="isOdd">
    <div [class]="{'odd-row': odd}">{{i}}:{{hero.name}}</div>
</ng-template>


тут я ссылаюсь в ng-template на переменную выше объявленную в цикле, так можно переопределять под каким именем будет доступна переменная
<ng-container *ngFor="let name of names;">
    <ng-template let-item="name" #nameRef>
        <div>{{name.name}}</div>
    </ng-template>

    <ng-container [ngTemplateOutlet]="nameRef"></ng-container>
</ng-container>
*/





//? /Binding/Привязка/[]
// https://angular.io/guide/property-binding
// https://angular.io/guide/attribute-binding

//? Привязка - это привязывание изменения свойства класса, к свойству DOM элемента, либо же привязать к пропсу, который принимает дочерний компонент через Input
//? без скобок данное выражение справа будет расценено как обычная строка
/*
<img [src]="itemImageUrl">
*/


//? Также можно привязывать аттрибуты, для этого есть много разных директив, [attr], [class], [style] и т.д.
/*
<p [attr.attribute-you-are-targeting]="expression"></p>
<li [style.color]="'red'">В виде строки конкретный стиль</li>
<li [class.boolean]="true">Привязать конкретный класс вычесленным значением true</li>
*/




//? /Event/События/
// https://angular.io/guide/event-binding

//? Прослушивать события на элементах можно через (), куда в скобки передаем событие, которое будем слушать, либо же пользовательское событие через @Output EventEmitter
//? чтобы получить обьект события, нужно в метод прокинуть $event переменную, зарезервированную ангуляром





//? /2 way binding/Двухсторонняя привязка/
// https://angular.io/guide/two-way-binding

//? Для сокращения кода, можно писать более лакончиную связку одного и того же свойства в родительском и дочернем компонентах
//? для этого нужно в дочернем сделать инпут и аутпут, а аутпут свойсто нужно назвать также как входящее, но добавить обязательно Change к имени, иначе работать не будет

//? Также можно использовать ngModel на инпуте, чтобы при изменении сразу записывать новое значение
/*
Родитель
public twoWayBindValue: any;
public onInputChange(data: string): void {
    this.twoWayBindValue = data;
}

<p>Значение в родителе 2 сторонняя привязка {{twoWayBindValue}}</p>
<input type="text" #inputRef (input)="onInputChange(inputRef.value)">
<div app-binding-child
    [(text)]="twoWayBindValue"
></div>

<h4>NgModel метод</h4>
<input type="text" [(ngModel)]="twoWayBindValue">


Ребенок
@Input() public text: string;
@Output() public textChange: EventEmitter<string> = new EventEmitter();         событие должно быть названо также как свойство входящее + Change

public onChangeInput(event: Event): void {
    this.text = (event.target as HTMLInputElement).value;
    this.textChange.emit(this.text);
}

<p>Значение привязки в дочернем компоненте {{text}}</p>
<input type="text" (input)="onChangeInput($event)"/>
*/





//? /ng-container/
// https://angular.io/api/core/ng-container

//? Для группировки тэгов, к контейнеру могут быть применимы директивы. Также эта обертка не отображается в доме, аналогия - react.fragment, просто, чтобы сгруппировать тэги

//? Очень часто применяют к контейнеры директиву NgTemplateOutlet, которая вставляет TemplateRef в шаблон












//!================================================================================================================================================
//? /Directives/Директивы/
// https://angular.io/guide/built-in-directives

//? Директива - класс, который добавляет поведение к элементам приложения
//? В angular 3 типа директив:
//? 1) компоненты - директивы с шаблоном
//? 2) директивы атрибутов - они меняют внешний вид или поведение компонента или другой директивы
//? 3) структурные директивы, они меняют дом


//? Самые распространенные директивы: *ngFor, *ngIf, *ngSwitchCase


//? В директиве работают некоторые хуки жизненного цикла
//? 1) ngOnInit
//? 2) ngDoCheck
//? 3) ngAfterContentInit
//? 4) ngAfterContentChecked
//? 5) ngAfterViewChecked





//? Directive
// https://stackoverflow.com/questions/49746274/how-to-use-exportas-in-angular-5-on-directives-to-get-its-reference-in-the-templ
//? exportAs - то, как в шаблоне можно обращаться напрямую к классу директивы и вызывать методы её






// https://stackoverflow.com/questions/41789702/how-to-use-angular-structural-directive-with-multiple-inputs
//? Структурные директивы пишутся с синтаксисом *. В нее можно заинжектировать templateRef(она сама обернет компонент в шаблон), и viewContainerRef(манипуляции с данным представлением), и с помощью них можно управлять контентом.
//? Синтаксис привязки странный:
/*
@Directive({
    selector: '[test]'
})
export class TestDirective {
    constructor(
        protected templateRef: TemplateRef<HTMLElement>,
        protected viewContainerRef: ViewContainerRef,
    ) {}

    @Input() public set test(data: boolean) {
        console.log(3);
        console.log(this);
        if (data) {
            this.viewContainerRef.createEmbeddedView(this.templateRef);
        } else {
            this.viewContainerRef.clear();
        }
    }

    @Input() set testBla(data: any) {
        console.log(data);
    }
}
<button *test="true;bla:12323">BUTTON</button>
*/















//!================================================================================================================================================
//? /Decorators/Декораторы/

//? /HostListener/
//? Объявляет событие dom для прослушивания и предоставляет метод обработчик
//? можно использовать глобальные события как префикс: document, window, body

//? HostListener будет вызывать цикл обнаружения каждый раз при событии, поэтому он не будет корректно работать с runOusideAngular.
/*
@HostListener('window:keydown.enter', ['$event'])
handleKeyDown(event: KeyboardEvent) {
    this.counter++;
}
*/




//? /HostBinding/
// https://angular.io/api/core/HostBinding

//? Привязать свойство dom к хост элеенту, при его изменении будет автоматом изменяться свойство













//? /Renderer/
// https://angular.io/api/core/Renderer2#createelement

//? С этим классом можно манипулировать элементом, менять стили, классы, добавлять тэги, элементы и т.д.



















//!================================================================================================================================================
//? /Services/DI/Dependency Injection/Внедрение зависимостей/
// https://angular.io/guide/dependency-injection-providers
// https://angular.io/api/core/Injectable
// https://www.youtube.com/watch?v=fALKYP8voBQ&ab_channel=JavaScript.ru
// https://www.youtube.com/watch?v=u6gAVCEJjQ4&t=860s&ab_channel=devschacht


//? Логика работы подхода примерно такая: существует некий контейнер(коробка), где лежат все необходимые нам для внедрения сервисы, переменные и т.д, неважно что, и мы при инжектировании зависимостей достаем уже экземпляр класса, эта коробка сама создает внутри себя этот экземпляр и отдает нам его, также она может отдавать не только именно это экземпляр, но и создать другой экземпляр этого же класса.


//? В декораторе сервиса можно переопределить, какие значения будут инжектированы, когда мы будем указывать токен определенный
//? Когда мы опрделяем провайдера, сервис в providers массиве, под капотом ангуляр преобразует запись в более простую
/*
providers: [Logger]
в
providers: [
    {
        provide: Logger,
        useClass: Logger
    }
]
*/


//? Provider имеет provide свойство, где указывается токен, по которому инжектироваться значение, а вторым свойством может быть:
//? 1) useClass - класс для инжектирования(можно указать любой класс)
//? 2) useValue - мы можем передать любое значение, которое будет инжектировано
//? 3) useExisting - если мы хотим использоватьиспользуется с forwardRef(https://angular.io/api/core/forwardRef) 
//? 4) useFactory - функция используется, чтобы мы сами определили, какой класс или функционал мы хотим внедрить. Тут в этой функции мы можем вызвать по условию конструктор и вернуть его, либо же вернуть простой обьект и т.д.


//? Также мы можем подменять эти инжектируемые значения в модуле, где можно в функцию useFactory прокидывать зависимости, которая нам необходима при инжектировании через useFactory. Чтобы прокинуть какой то сервис или сущность, нужно, чтобы она была доступна для инжектирования, в массив deps зависимости для функции указываются
//? multi отвечает, что при инжектировании сущности будут помещены в массив, т.е. если в классе мы инжектируем mainService, то все, что возвращает этот инжектор, будет собрано в массив
/*
{
    provide: MainService,
    useFactory: (data: SecondService) => {
        console.log(data);
        return new MainService();     также можно просто создать класс
        return data;      можно просто вернуть класс уже готовый и т.д.
    },
    deps: [SecondService],
    multi: true,
},
*/



//? /Inject/
//? Данные, которые нам нужно заинжектировать в компонент или сервис, нужно пометить через @Inject декоратор
//? он инжектирует данные в сущность



//? /InjectionToken/
// https://angular.io/api/core/InjectionToken
//? Создается токен, по которому можно далее инжектировать значения
// new InjectionToken<string>('BASE_URL');





//? В ленивых модулях сервисы не доступны вне их, т.к. они ничего не знают о них


//? /providedIn/
//? any - все сервисы в ленивых модулях получат уникальный экземпляр класса, в обычных модулях будет синглтон
//? root - для всего приложения
//? platform - для всех приложений на странице
//? <moduleName> - если сделаем так, то сервис будет удален из сборки, если он нигде не используется, а также только в данном модуле будет





//? Сервисы являются синглтонами, если:
//? они объявлены в главном модуле
//? в главный модуль импортируется модуль, который уже содержит сервис


//? Создадутся заново:
//? Если в ленивом модуле зарегестрирован сервис и у него providedIn root, то он будет доступен во всем приложении, но в самом модуле будет создан новый экземпляр(а значит и в сборке он будет не лениво заргужен, данный сервис, потому что он уже инжектируется вне ленивого модуля)
//? Если в ленивом модуле зарегестрирован сервис с пустым декоратором, то будет экземпляр только на уровне модуля(всё загружено будет лениво)
//? providers & viewProviders компонента или директивы





//? /Optional/
//? Декоратор инжектирования, чтобы не выдавать ошибку, если не найдет сущность для инжектирования


//? /SkipSelf/
//? Начать поиск с родительского компонента на уровень выше по дереву инжекторов


//? /Host/
//? Выше компонента поиск не пойдет. Т.е. если директива в компоненте должна заинжектировать сущность, то поиск продолжится только до данного компонента, в котором она вызвана


//? /Self/
//? Найти сущность только на этом уровне










//!================================================================================================================================================
//? /Pipes/Пайпы/
// https://angular.io/guide/pipes
//? Пайпы применяются для модифицирования данных в шаблоне, преобразования какого то

//? Есть 2 вида пайпов: чистые(по дефолту) и грязные
//? Чистые пайпы не вызываются, если входящие параметры не изменились, грязные - вызваются. Таким образом, если нам нужен метод преобразования в шаблоне можно обходить то, что он будет вызываться при каждом цикле обнаружения изменений, purepipe в этом помогают










//!================================================================================================================================================
//? /Modules/Модули/NgModule/
// https://angular.io/guide/frequent-ngmodules
// TODO https://angular.io/guide/hierarchical-dependency-injection

//? В приложении есть всегда один главный модуль. В Модуле определяются компоненты, которые определены в данном модуле, сервисы, также в модуль нужно импортировать другой модуль, функционал которого нам необходим в этом модуле. Также модули экспортируют функциональность, чтобы при импорте этого модуля в другие, мог передать функционал

//? @NgModule декоратор используют для определения модуля

//? declarations - компоненты, директивы, пайпы
//? exports - функционал для экспортирования
//? providers - сущности для инжектирования в модуле. Сервисы, резолверы и.д., кастомные сущности, доступные для инжектирования типа Provider
//? bootstrap - главный компонент входной приложения, который будет запущен. DoBootstrap может заменить этот параметр
//? entryComponents - динамические компоненты, котрые в шаблоне напрямую не вызваются
//? jit - тип компиляции модуля
//? id - id модуля, который может быть получен через getNgModuleById





//? Lazyloading
//? для ленивого модуля создается отдельный инжектор, т.е. там будут новые экземпляры сервисов создаваться, если мы импортируем sharedModule в разные модули приложения





//?================================================================================================================================================
//? /DoBootstrap/
// https://angular.io/api/core/DoBootstrap

//? Данный хук вызывается на главном модуле приложения, если в главном модуле массив bootstrap не предоставлен, это ручной запуск приложения
//? принимает в себя ApplicationRef, где нам нужно вызвать bootstrap метод, который переданный компонент сделает главным в приложении










//!================================================================================================================================================
//? /Routing/Навигация/

//? /RouterModule/
//? Для работы с маршрутизацией необходим этот модуль
//? Все пути указываются в обьекте и прокидываются первым параметром в метод forRoot или forChild, вторым параметром идет обьект настроек ExtraOptions
//? все роуты должны быть в порядке от самого точного к наименее точному маршруту, т.к. используется стратегия первого совпадения





//? /Стратегии навигации приложения/
// https://angular.io/api/common/APP_BASE_HREF
// https://angular.io/guide/router#base-href-1
//? Чтобы в приложении использовать html5 стратегию навигации(pushState, добавление адреса в историю без запроса на сервер), тоже самое, что и путь файла на сервере, в index.html приложения нужно добавить <base href="/"> тэг сразу в head тэге, либо можно APP_BASE_HREF инжектировать в приложение


//? /HashLocationStrategy/
// https://angular.io/api/common/HashLocationStrategy
// https://angular.io/guide/router#hashlocationstrategy




//? /Base/Base href
// https://angular.io/guide/router#base-href
//? Этот тэг добавляется в head, чтобы указать относительно какого пути загружать изображения, css и т.д.





//? /Route/
//? Настройка роута конкретного
//? 1) path - путь, по которому будет доступен компонент. ** - используется для любого маршрута, который не был найден(404 error), '' - дефолтный маршрут. Также можно использовать параметры маршрута :id вот так они указываются, динамический путь зависит от id
//? 2) component - компонент для отображения
//? 3) redirectTo - редирект с этой страницы
//? 4) children - дочерние маршруты для данного маршрута, массив Route, обязательно в него нужно передать дочерние роуты, а также для данного компонента прописать директиву router-outlet
//? 5) resolve - классы, которые вызываются перед тем, как отобразить данный роут, пока они не отработают, страница не будет показана, также используются, чтобы прокинуть данные в компонент через ActivatedRoute
//? 6) loadChildren - функция колбэк, где import вызывается и лениво загружается модуль(нельзя использовать вместе с component, потому что так ленивая загрузка не будет работать). По дефолту будет из лениво загруженного модуля показываться роут с '' путем. Внутри таких модулей используется forChild методы для регистрации роутов, нужно вернуть либо модуль либо пути дочерние. ОБЯЗАТЕЛЬНО ВОЗВРАЩАЕТ МОДУЛЬ, если главный компонент инжектирует провайдеров из этого модуля.
//? 7) canActivate - можно ли активировать данный роут
//? 8) canActivateChild - можно ли активировать дочерние пути данного роута
//? 9) canDeactivate - можно ли уйти со страницы
//? 10) canLoad - можно ли начать загружать ленивый модуль или нет
//? 11) pathMatch - точность совпадения пути. Может быть 'full или prefix', prefix по дефолту
//? 12) matcher - https://angular.io/guide/routing-with-urlmatcher кастомный сопоставитель пути
//? 13) data - данные для прокидывания в этот путь





//? /ExtraOptions/
// https://angular.io/api/router/ExtraOptions

//? Настройки роута главного родительского модуля
//? 1) preloadingStrategy - https://angular.io/api/router/PreloadingStrategy стратегия загрузки модулей, либо не предзагружать, либо после того, как главный модуль загружен, чтобы приложение могло работать, а затем остальные в фоне загружать
//? 2) enableTracing - 
//? 3) useHash - использовать ли стратегию хэшей в путях приложения
//? 4) initialNavigation - 
//? 5) errorHandler - 
//? 7) onSameUrlNavigation - 
//? 8) scrollPositionRestoration - 
//? 9) anchorScrolling - 
//? 10) scrollOffset - 
//? 11) paramsInheritanceStrategy - 
//? 12) malformedUriErrorHandler - 
//? 13) urlUpdateStrategy - 
//? 14) relativeLinkResolution - 
//? 15) canceledNavigationResolution - 





//? /ActivatedRoute/
// https://angular.io/api/router/ActivatedRoute
//? Информация о текущем роуте
//? можно получить доступ до snapshot(текущий снимок), т.е. при создании какие данные имеет данный роут, также можно подписываться на изменения параметров, пути и т.д




//? /Resolve/Резолвер/
// https://www.digitalocean.com/community/tutorials/angular-route-resolvers
// https://angular.io/api/router/Resolve
//? Вызывается перед тем, как отобразить страницу, их надо также определить в providers массиве модуля

//? данные класс реализует метод, который должен вернуть данные, которые попадут в activatedRoute.data, где дальше можно их использовать





//? /RouterLink/
// https://angular.io/api/router/RouterLink
//? Директива для навигации, которая применяется к ссылке, также имеет дополнительные входные параметры queryParams, fragment и т.д
//? пути можно задавать как относительные, так и абсолютные от корня приложения




//? /RouterLinkActive/
// https://angular.io/api/router/RouterLinkActive
//? Добавляет активный класс ссылке

//? routerLinkActiveOptions - параметры директивы
//? isActiveChange - событие смены активного и неактивного состояния





//? /RouterOutlet/
// https://angular.io/api/router/RouterOutlet
//? Директива, на месте которой будет рендерится компонент при совпадении пути, также должна вызываться в дочерних компонентах, если таковые есть в дочерних роутах


//? Можно использовать несколько директив сразу, т.е. будто будет 2 независимых роутинга в приложении, данный подход не работает ТОЛЬКО в лениво загруженных модулях
//? ниже пример, как настраивать и использовать данный подход
/*
{
    path: 'compose',
    component: ComposeMessageComponent,
    outlet: 'popup'
}

<a [routerLink]="[{ outlets: { popup: ['compose'] } }]">Contact</a>
<router-outlet name="popup"></router-outlet>
*/




//? /Router/
// https://angular.io/api/router/Router
//? Роутер, для навигации по проекту, работа с url
//? все данные по роутингу приложения а также работа с ним










//!================================================================================================================================================
//? /ReactiveForm/Формы/
// https://angular.io/guide/reactive-forms

//? /ReactiveFormsModule/
//? Модуль дает возможность использовать директивы реактивных форм, например formControl


//? /FormControl/
//? Создает контрол формы
//? нужно привязать конкретный экземпляр контрола к нужному элементу форму через эту директиву, если не хотим создавать переменную для контрола, то можно обойтись formControlName



//? /FormControlName/
//? Привязывает имя контрола из формы к конкретному элементу формы, таким образом можно не создавать переменную контрола




//? /FormGroup/
//? Создает группу формы, в которую передаются контролы, которые объеденены будут в целую форму
//? чтобы прослушивать отправку формы, на форму можно повесить ngSubmit форму встроенную




//? /FormBuilder/
//? Создание динамических форм




//? /Validators/AsyncValidators/Валидаторы/Асинхронные валидаторы/
//? В реактивных формах это либо просто функции, которые передаются в настройки, либо можно создавать инжектируемые классы, которые можно также использовать, и оттуда дергать метод validate




//? /Classes/
//? Каждый контрол имеет классы в соответсвии со своим статусом
//? ng-valid, ng-invalid и т.д.










//!================================================================================================================================================
//? /HTTPClientModule/Server/Сервер

//? Чтобы использовать http для запросов, в приложение нужно импортировать HttpClientModule, который предоставляет httpClient для работы с запросами




//? Методы запроса могут отдавать разные виды ответа, json, просто обьект



// https://angular.io/guide/http#starting-the-request
//? при каждой подписке будет сделан новый запрос
/*
const req = http.get<Heroes>('/api/heroes');
req.subscribe();
req.subscribe();
*/




//? JSONP
// TODO https://angular.io/guide/http#making-a-jsonp-request




//? Обработка ошибок
//? В pipe можно retry оператор засунуть, который будет несколько раз делать запрос
//? catchError будет ловить ошибку




//? Добавление параметров запроса, queryParams
// https://angular.io/guide/http#configuring-http-url-parameters
//? HttpParams используется, чтобы добавить параметры в запрос




//? /Interceptor/Перехватчик/
//? Запросы можно перехватывать, и добавлять параметры и вообще как то их модифицировать
//? для этого создается класс который реализует HttpInterceptor, он также является внедряемым
//? перехватчики работают во всем приложении, если модули ленивые, там работать не будут

//? перехватчики выполняются один за одним во всем приложении и потом идет отправка запроса на сервер, после этого ответ будет снова направлен перехватчикам и только потом он дойдет до места, где был вызов запроса на сервер

//? Между перехватчиками можно обмениваться данными через context, туда можно передавать нужные значения





//? Можно изменять дефолтные значения coockie с помощью HttpClientXsrfModule










//!================================================================================================================================================
//? /Интернационализация/
// TODO https://angular.io/guide/i18n-common-overview










//!================================================================================================================================================
//? /Animations/Анимации/
// TODO https://angular.io/guide/animations










//!================================================================================================================================================
//? /ServiceWorker/
// TODO https://angular.io/guide/service-worker-intro










//!================================================================================================================================================
//? /WebWorker/ВебВоркер/
// TODO https://angular.io/guide/web-worker










//!================================================================================================================================================
//? /SSR/ServerSiteRendering/
// TODO https://angular.io/guide/universal










//!================================================================================================================================================
//? /Configuration angular.json/Конфигурация/
// https://angular.io/guide/workspace-config
// https://angular.io/guide/npm-packages
